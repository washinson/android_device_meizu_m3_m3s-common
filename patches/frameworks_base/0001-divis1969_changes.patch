diff --git a/Android.mk b/Android.mk
index 91b2a990..fbe51746 100755
--- a/Android.mk
+++ b/Android.mk
@@ -262,6 +262,8 @@ LOCAL_SRC_FILES += \
 	core/java/android/view/accessibility/IAccessibilityManagerClient.aidl \
 	core/java/android/view/IApplicationToken.aidl \
 	core/java/android/view/IAssetAtlas.aidl \
+	core/java/android/view/IGestureCallback.aidl \
+	core/java/android/view/IGestureManager.aidl \
 	core/java/android/view/IInputFilter.aidl \
 	core/java/android/view/IInputFilterHost.aidl \
 	core/java/android/view/IOnKeyguardExitResult.aidl \
@@ -413,6 +415,8 @@ LOCAL_SRC_FILES += \
 	packages/services/Proxy/com/android/net/IProxyCallback.aidl \
 	packages/services/Proxy/com/android/net/IProxyPortListener.aidl \
         telephony/java/com/android/ims/internal/IImsConfig.aidl \
+        core/java/meizu/os/IDeviceControlService.aidl \
+        core/java/com/mediatek/perfservice/IPerfService.aidl \
 
 
 # FRAMEWORKS_BASE_JAVA_SRC_DIRS comes from build/core/pathmap.mk
diff --git a/core/java/android/os/BatteryProperties.java b/core/java/android/os/BatteryProperties.java
index 3167a7b0..76568df4 100644
--- a/core/java/android/os/BatteryProperties.java
+++ b/core/java/android/os/BatteryProperties.java
@@ -41,6 +41,19 @@ public class BatteryProperties implements Parcelable {
     public int dockBatteryTemperature;
     public String dockBatteryTechnology;
 
+    // MTK
+    private static final boolean MTK_HEALTHD;
+
+    static {
+        // XXX: Magnificent hack relying on 3rd-party ROMs not including the
+        // (useless anyway) MTK-specific init scripts. Doing a string search
+        // on the healthd binary for some MTK-specific strings may be more
+        // reliable, but it's arguably more overhead.
+        MTK_HEALTHD = new java.io.File("/factory_init.rc").exists()
+                      || new java.io.File("/meta_init.rc").exists()
+                      || new java.io.File("/_have_mtk_healthd").exists();
+    }
+
     public BatteryProperties() {
     }
 
@@ -77,14 +90,26 @@ public class BatteryProperties implements Parcelable {
         chargerUsbOnline = p.readInt() == 1 ? true : false;
         chargerWirelessOnline = p.readInt() == 1 ? true : false;
         batteryStatus = p.readInt();
+        if (MTK_HEALTHD)
+        /* batteryStatus_smb = */ p.readInt();
         batteryHealth = p.readInt();
         batteryPresent = p.readInt() == 1 ? true : false;
+        if (MTK_HEALTHD)
+        /* batteryPresent_smb = */ p.readInt() /* == 1 ? true : false */;
         batteryLevel = p.readInt();
+        if (MTK_HEALTHD)
+        /* batteryLevel_smb = */ p.readInt();
         batteryVoltage = p.readInt();
+        if (MTK_HEALTHD) {
+        /* batteryCurrentNow = */ p.readInt();
+        /* batteryChargeCounter = */ p.readInt();
+        }
         batteryTemperature = p.readInt();
+        if (MTK_HEALTHD)
+        /* adjustPower = */ p.readInt();
         batteryTechnology = p.readString();
 
-        dockBatterySupported = p.readInt() == 1 ? true : false;
+        dockBatterySupported = MTK_HEALTHD ? false : p.readInt() == 1 ? true : false;
         if (dockBatterySupported) {
             chargerDockAcOnline = p.readInt() == 1 ? true : false;
             dockBatteryStatus = p.readInt();
@@ -111,13 +136,29 @@ public class BatteryProperties implements Parcelable {
         p.writeInt(chargerUsbOnline ? 1 : 0);
         p.writeInt(chargerWirelessOnline ? 1 : 0);
         p.writeInt(batteryStatus);
+        if (MTK_HEALTHD)
+            p.writeInt(0);  // batteryStatus_smb
         p.writeInt(batteryHealth);
         p.writeInt(batteryPresent ? 1 : 0);
+        if (MTK_HEALTHD)
+            p.writeInt(0);  // batteryPresent_smb
         p.writeInt(batteryLevel);
+        if (MTK_HEALTHD)
+            p.writeInt(50);  // batteryLevel_smb
         p.writeInt(batteryVoltage);
+        if (MTK_HEALTHD) {
+            p.writeInt(0);  // batteryCurrentNow
+            p.writeInt(0);  // batteryChargeCounter
+        }
         p.writeInt(batteryTemperature);
+        if (MTK_HEALTHD)
+            p.writeInt(0);  // adjustPower
         p.writeString(batteryTechnology);
 
+        if (MTK_HEALTHD) {
+            return;
+        }
+
         p.writeInt(dockBatterySupported ? 1 : 0);
         if (dockBatterySupported) {
             p.writeInt(chargerDockAcOnline ? 1 : 0);
diff --git a/core/java/android/os/BuildExt.java b/core/java/android/os/BuildExt.java
new file mode 100644
index 00000000..cb001d7b
--- /dev/null
+++ b/core/java/android/os/BuildExt.java
@@ -0,0 +1,532 @@
+//
+// Created from decompiled by Procyon v0.5.30
+//
+
+package android.os;
+
+import android.content.ContentResolver;
+import android.provider.Settings;
+import android.content.Context;
+
+public class BuildExt
+{
+    public static final Boolean CHINAMOBILE_TEST = getString("ro.chinamobile.test").equals("true");
+    private static final String COLOR_TYPE_PATH = "/proc/lk_info/colortype";
+    public static final String CTA = getString("ro.build.cta");
+    public static final Boolean CUSTOMIZE_CHINAMOBILE = isChinaMobile();
+    public static final Boolean CUSTOMIZE_CHINATELECOM = getString("ro.customize.isp").equals("chinatelecom");
+    public static final Boolean CUSTOMIZE_CHINAUNICOM = isChinaUnicom();
+    private static final String CUSTOMIZE_ISP_VALUE = getString("ro.customize.isp");
+    public static final Boolean HAS_DRIVE_MODE = true;
+    public static final Boolean HAS_PERMANENTKEY;
+    public static final String HAS_SMARTBAR = getString("ro.meizu.has_smartbar");
+    public static final Boolean HIDE_INFO = getString("ro.flyme.hideinfo").equals("true");
+    public static final String IS_FLYMEROM = getString("ro.meizu.rom.config");
+    public static final Boolean IS_M1 = (getString("ro.product.model").equals("m79") || getString("ro.product.model").equals("m1") || getString("ro.product.model").equals("k32v2"));
+    public static final Boolean IS_M1_NOTE = (getString("ro.product.model").equals("m71") || getString("ro.product.model").equals("m1 note") || getString("ro.product.model").equals("k52v2"));
+    public static final Boolean IS_M2 = (getString("ro.product.model").equals("mt6735") || getString("ro.product.model").equals("m2") || getString("ro.product.model").equals("M2 Mini"));
+    public static final Boolean IS_M2C = (getString("ro.product.model").equals("M578C") || getString("ro.product.model").equals("m88c") || getString("ro.product.model").equals("M578CA") || getString("ro.product.model").equals("M578CE"));
+    public static final Boolean IS_M2_NOTE = (getString("ro.product.model").equals("mt6753") || getString("ro.product.model").equals("m2 note"));;
+    public static final Boolean IS_M2_NOTEC = (getString("ro.product.model").equals("M571C") || getString("ro.product.model").equals("m81c"));
+    public static final Boolean IS_M71C = getString("ro.build.device.name").equals("m71c");
+    public static final Boolean IS_MA01 = getString("ro.product.model").equals("MA01");
+    public static final Boolean IS_MA01C = (getString("ro.product.model").equals("MA01C") || getString("ro.product.model").equals("m1c metal") || getString("ro.product.model").equals("M57AC"));
+    public static final Boolean IS_MOBILE_PUBLIC = getString("ro.customize.isp").equals("mobilepublic");
+    public static final Boolean IS_MX2 = getString("ro.product.device").equals("mx2");
+    public static final Boolean IS_MX3 = getString("ro.product.device").equals("mx3");
+    public static final Boolean IS_MX4 = (getString("ro.product.model").equals("m75") || getString("ro.product.model").equals("k95v2") || getString("ro.product.model").equals("M460A") || getString("ro.product.device").equals("mx4"));
+    public static final Boolean IS_MX4_Pro = (getString("ro.product.model").equals("m76") || getString("ro.product.model").equals("espresso5430") || (getString("ro.board.platform").equals("exynos5") && getString("ro.arch").equals("exynos5430")));
+    public static final Boolean IS_MX5 = (getString("ro.product.model").equals("MX5") || getString("ro.product.model").equals("mt6595"));
+    public static final Boolean IS_MX5_PRO = (getString("ro.product.model").equals("M86") || getString("ro.product.model").equals("NIUX") || getString("ro.product.model").equals("MX5 Pro"));
+    public static final boolean IS_PRODUCT = !getString("ro.error.receiver.default").equals("com.howell.logsnapshot");
+    public static final Boolean IS_SHOPDEMO = getString("ro.meizu.customize.demo").equals("true");
+    public static final Boolean IS_TD_PLATFORM = getString("ro.meizu.hardware.modem").equalsIgnoreCase("td-scdma");
+    public static final Boolean IS_WCDMA_PLATFORM = getString("ro.meizu.hardware.modem").equalsIgnoreCase("wcdma");
+    public static final String MANUFACTURER = getString("ro.product.manufacturer");
+    public static final String MZ_MODEL = getString("ro.meizu.product.model");
+    public static final String PERMANENTKEY = getString("ro.meizu.permanentkey");
+    private static final String TAG = "BuildExt";
+    private static String mDeviceTpColor = null;
+
+    static {
+        HAS_PERMANENTKEY = hasPermanentKey();
+    }
+
+    public static int getBrightnessMaxLevel() {
+        int result;
+        if (IS_MX3 || IS_MX4 || IS_MX4_Pro) {
+            result = 2040;
+        }
+        else if (IS_M1_NOTE || IS_M1) {
+            result = 2048;
+        }
+        else {
+            result = 255;
+        }
+        return result;
+    }
+
+    public static String getColorType() {
+        //
+        // This method could not be decompiled.
+        //
+        // Original Bytecode:
+        //
+        //     0: new             Ljava/io/File;
+        //     3: dup
+        //     4: ldc             "/proc/lk_info/colortype"
+        //     6: invokespecial   java/io/File.<init>:(Ljava/lang/String;)V
+        //     9: astore_2
+        //    10: new             Ljava/io/BufferedReader;
+        //    13: astore_0
+        //    14: new             Ljava/io/FileReader;
+        //    17: astore_1
+        //    18: aload_1
+        //    19: aload_2
+        //    20: invokespecial   java/io/FileReader.<init>:(Ljava/io/File;)V
+        //    23: aload_0
+        //    24: aload_1
+        //    25: invokespecial   java/io/BufferedReader.<init>:(Ljava/io/Reader;)V
+        //    28: aload_0
+        //    29: invokevirtual   java/io/BufferedReader.readLine:()Ljava/lang/String;
+        //    32: astore_1
+        //    33: aload_1
+        //    34: ifnull          44
+        //    37: aload_1
+        //    38: invokevirtual   java/lang/String.trim:()Ljava/lang/String;
+        //    41: astore_0
+        //    42: aload_0
+        //    43: areturn
+        //    44: aload_0
+        //    45: invokevirtual   java/io/BufferedReader.close:()V
+        //    48: ldc_w           "unknown"
+        //    51: astore_0
+        //    52: goto            42
+        //    55: astore_0
+        //    56: aload_0
+        //    57: invokevirtual   java/lang/Exception.printStackTrace:()V
+        //    60: goto            48
+        //    63: astore_0
+        //    64: goto            56
+        //    Exceptions:
+        //  Try           Handler
+        //  Start  End    Start  End    Type
+        //  -----  -----  -----  -----  ---------------------
+        //  10     28     55     56     Ljava/lang/Exception;
+        //  28     33     63     67     Ljava/lang/Exception;
+        //  37     42     63     67     Ljava/lang/Exception;
+        //  44     48     63     67     Ljava/lang/Exception;
+        //
+        // The error that occurred was:
+        //
+        // java.lang.IllegalStateException: Expression is linked from several locations: Label_0042:
+        //     at com.strobel.decompiler.ast.Error.expressionLinkedFromMultipleLocations(Error.java:27)
+        //     at com.strobel.decompiler.ast.AstOptimizer.mergeDisparateObjectInitializations(AstOptimizer.java:2592)
+        //     at com.strobel.decompiler.ast.AstOptimizer.optimize(AstOptimizer.java:235)
+        //     at com.strobel.decompiler.ast.AstOptimizer.optimize(AstOptimizer.java:42)
+        //     at com.strobel.decompiler.languages.java.ast.AstMethodBodyBuilder.createMethodBody(AstMethodBodyBuilder.java:214)
+        //     at com.strobel.decompiler.languages.java.ast.AstMethodBodyBuilder.createMethodBody(AstMethodBodyBuilder.java:99)
+        //     at com.strobel.decompiler.languages.java.ast.AstBuilder.createMethodBody(AstBuilder.java:757)
+        //     at com.strobel.decompiler.languages.java.ast.AstBuilder.createMethod(AstBuilder.java:655)
+        //     at com.strobel.decompiler.languages.java.ast.AstBuilder.addTypeMembers(AstBuilder.java:532)
+        //     at com.strobel.decompiler.languages.java.ast.AstBuilder.createTypeCore(AstBuilder.java:499)
+        //     at com.strobel.decompiler.languages.java.ast.AstBuilder.createTypeNoCache(AstBuilder.java:141)
+        //     at com.strobel.decompiler.languages.java.ast.AstBuilder.createType(AstBuilder.java:130)
+        //     at com.strobel.decompiler.languages.java.ast.AstBuilder.addType(AstBuilder.java:105)
+        //     at com.strobel.decompiler.languages.java.JavaLanguage.buildAst(JavaLanguage.java:71)
+        //     at com.strobel.decompiler.languages.java.JavaLanguage.decompileType(JavaLanguage.java:59)
+        //     at com.strobel.decompiler.DecompilerDriver.decompileType(DecompilerDriver.java:317)
+        //     at com.strobel.decompiler.DecompilerDriver.decompileJar(DecompilerDriver.java:238)
+        //     at com.strobel.decompiler.DecompilerDriver.main(DecompilerDriver.java:138)
+        //
+        throw new IllegalStateException("An error occurred while decompiling this method.");
+    }
+
+    private static int getInt(String s) {
+        return SystemProperties.getInt(s, -1);
+    }
+
+    private static String getString(String s) {
+        return SystemProperties.get(s, "unknown");
+    }
+
+    public static boolean hasEseSmartMX(Context context) {
+        boolean b = true;
+        if (Settings.Secure.getInt(context.getContentResolver(), "smartmx_ese", -1) != 1) {
+            b = false;
+        }
+        return b;
+    }
+
+    public static boolean hasNFC() {
+        return getString("ro.meizu.hardware.nfc").equals("true") || IS_MX4_Pro;
+    }
+
+    private static Boolean hasPermanentKey() {
+        Boolean b;
+        if (PERMANENTKEY != null && PERMANENTKEY.equals("true")) {
+            b = true;
+        }
+        else {
+            b = false;
+        }
+        return b;
+    }
+
+    public static boolean hasSmartBar() {
+        return true;
+    }
+
+    public static boolean isBlackDevice() {
+        final boolean b = true;
+        boolean b2;
+        if (IS_M1_NOTE) {
+            b2 = b;
+        }
+        else {
+            if (mDeviceTpColor == null) {
+                mDeviceTpColor = readFromFb("sys/devices/mx_tsp/appid");
+            }
+            if (mDeviceTpColor != null) {
+                b2 = b;
+                if (mDeviceTpColor.contains("B:")) {
+                    return b2;
+                }
+                b2 = b;
+                if (mDeviceTpColor.contains("BS:")) {
+                    return b2;
+                }
+            }
+            b2 = false;
+        }
+        return b2;
+    }
+
+    public static boolean isBrcm43341() {
+        return "brcm43341".equals(getString("ro.nfc.platform"));
+    }
+
+    private static Boolean isChinaMobile() {
+        Boolean b;
+        if (CUSTOMIZE_ISP_VALUE != null && CUSTOMIZE_ISP_VALUE.equals("chinamobile")) {
+            b = true;
+        }
+        else {
+            b = false;
+        }
+        return b;
+    }
+
+    private static Boolean isChinaUnicom() {
+        Boolean b;
+        if (CUSTOMIZE_ISP_VALUE != null && CUSTOMIZE_ISP_VALUE.equals("chinaunicom")) {
+            b = true;
+        }
+        else {
+            b = false;
+        }
+        return b;
+    }
+
+    public static boolean isFlymeRom() {
+        return IS_FLYMEROM != null && IS_FLYMEROM.equals("true");
+    }
+
+    public static boolean isIndiaVersion() {
+        return getString("ro.meizu.locale.region").equals("india");
+    }
+
+    public static boolean isLtgModem() {
+        return "TD".equalsIgnoreCase(getString("sys.baseband"));
+    }
+
+    public static boolean isLwgModem() {
+        return "UMTS".equalsIgnoreCase(getString("sys.baseband"));
+    }
+
+    public static boolean isMzProduct() {
+        return IS_MX2 || IS_MX3 || IS_MX4 || IS_MX4_Pro || IS_M1_NOTE || IS_M1;
+    }
+
+    public static boolean isNxpPn547() {
+        return "nxppn547".equals(getString("ro.nfc.platform"));
+    }
+
+    public static boolean isProductInternational() {
+        boolean b = false;
+        try {
+            if (!SystemProperties.get("ro.product.locale.language").equals("zh") || !SystemProperties.get("ro.product.locale.region").equals("CN")) {
+                b = true;
+            }
+            return b;
+        }
+        catch (Exception ex) {
+            ex.printStackTrace();
+            return b;
+        }
+    }
+
+    public static boolean isShopDemoVersion() {
+        return IS_SHOPDEMO;
+    }
+
+    private static String readFromFb(String p0) {
+        //
+        // This method could not be decompiled.
+        //
+        // Original Bytecode:
+        //
+        //     0: aconst_null
+        //     1: astore          8
+        //     3: aconst_null
+        //     4: astore          9
+        //     6: aconst_null
+        //     7: astore          7
+        //     9: sipush          128
+        //    12: newarray        B
+        //    14: astore          11
+        //    16: aconst_null
+        //    17: astore          6
+        //    19: aconst_null
+        //    20: astore          10
+        //    22: aconst_null
+        //    23: astore          4
+        //    25: aconst_null
+        //    26: astore          5
+        //    28: aload           9
+        //    30: astore_2
+        //    31: aload           10
+        //    33: astore_3
+        //    34: new             Ljava/io/FileInputStream;
+        //    37: astore_1
+        //    38: aload           9
+        //    40: astore_2
+        //    41: aload           10
+        //    43: astore_3
+        //    44: new             Ljava/io/File;
+        //    47: astore          12
+        //    49: aload           9
+        //    51: astore_2
+        //    52: aload           10
+        //    54: astore_3
+        //    55: aload           12
+        //    57: aload_0
+        //    58: invokespecial   java/io/File.<init>:(Ljava/lang/String;)V
+        //    61: aload           9
+        //    63: astore_2
+        //    64: aload           10
+        //    66: astore_3
+        //    67: aload_1
+        //    68: aload           12
+        //    70: invokespecial   java/io/FileInputStream.<init>:(Ljava/io/File;)V
+        //    73: aload_1
+        //    74: aload           11
+        //    76: invokevirtual   java/io/FileInputStream.read:([B)I
+        //    79: pop
+        //    80: new             Ljava/lang/String;
+        //    83: astore_0
+        //    84: aload_0
+        //    85: aload           11
+        //    87: ldc_w           "UTF-8"
+        //    90: invokespecial   java/lang/String.<init>:([BLjava/lang/String;)V
+        //    93: new             Ljava/lang/StringBuilder;
+        //    96: astore_2
+        //    97: aload_2
+        //    98: invokespecial   java/lang/StringBuilder.<init>:()V
+        //   101: ldc             "BuildExt"
+        //   103: aload_2
+        //   104: ldc_w           "cat sys/devices/mx_tsp/appid : "
+        //   107: invokevirtual   java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
+        //   110: aload_0
+        //   111: invokevirtual   java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
+        //   114: invokevirtual   java/lang/StringBuilder.toString:()Ljava/lang/String;
+        //   117: invokestatic    android/util/Slog.d:(Ljava/lang/String;Ljava/lang/String;)I
+        //   120: pop
+        //   121: aload_1
+        //   122: invokevirtual   java/io/FileInputStream.close:()V
+        //   125: aload_1
+        //   126: ifnull          140
+        //   129: aload_1
+        //   130: invokevirtual   java/io/FileInputStream.close:()V
+        //   133: aload_0
+        //   134: areturn
+        //   135: astore_0
+        //   136: aload_0
+        //   137: invokevirtual   java/io/IOException.printStackTrace:()V
+        //   140: aconst_null
+        //   141: astore_0
+        //   142: goto            133
+        //   145: astore          4
+        //   147: aload           5
+        //   149: astore_1
+        //   150: aload           7
+        //   152: astore_0
+        //   153: aload_0
+        //   154: astore_2
+        //   155: aload_1
+        //   156: astore_3
+        //   157: ldc             "BuildExt"
+        //   159: ldc_w           "readFromFb error: "
+        //   162: aload           4
+        //   164: invokestatic    android/util/Slog.e:(Ljava/lang/String;Ljava/lang/String;Ljava/lang/Throwable;)I
+        //   167: pop
+        //   168: aload_0
+        //   169: ifnull          186
+        //   172: aload_0
+        //   173: invokevirtual   java/io/FileInputStream.close:()V
+        //   176: aload_1
+        //   177: astore_0
+        //   178: goto            133
+        //   181: astore_0
+        //   182: aload_0
+        //   183: invokevirtual   java/io/IOException.printStackTrace:()V
+        //   186: aconst_null
+        //   187: astore_0
+        //   188: goto            133
+        //   191: astore          4
+        //   193: aload           6
+        //   195: astore_1
+        //   196: aload           8
+        //   198: astore_0
+        //   199: aload_0
+        //   200: astore_2
+        //   201: aload_1
+        //   202: astore_3
+        //   203: ldc             "BuildExt"
+        //   205: ldc_w           "readFromFb error: "
+        //   208: aload           4
+        //   210: invokestatic    android/util/Slog.e:(Ljava/lang/String;Ljava/lang/String;Ljava/lang/Throwable;)I
+        //   213: pop
+        //   214: aload_0
+        //   215: ifnull          232
+        //   218: aload_0
+        //   219: invokevirtual   java/io/FileInputStream.close:()V
+        //   222: aload_1
+        //   223: astore_0
+        //   224: goto            133
+        //   227: astore_0
+        //   228: aload_0
+        //   229: invokevirtual   java/io/IOException.printStackTrace:()V
+        //   232: aconst_null
+        //   233: astore_0
+        //   234: goto            133
+        //   237: astore_0
+        //   238: aload_2
+        //   239: ifnull          256
+        //   242: aload_2
+        //   243: invokevirtual   java/io/FileInputStream.close:()V
+        //   246: aload_3
+        //   247: astore_0
+        //   248: goto            133
+        //   251: astore_0
+        //   252: aload_0
+        //   253: invokevirtual   java/io/IOException.printStackTrace:()V
+        //   256: aconst_null
+        //   257: astore_0
+        //   258: goto            133
+        //   261: astore_0
+        //   262: aload_1
+        //   263: astore_2
+        //   264: aload           4
+        //   266: astore_3
+        //   267: goto            238
+        //   270: astore_2
+        //   271: aload_1
+        //   272: astore_2
+        //   273: aload_0
+        //   274: astore_3
+        //   275: goto            238
+        //   278: astore          4
+        //   280: aload_1
+        //   281: astore_0
+        //   282: aload           6
+        //   284: astore_1
+        //   285: goto            199
+        //   288: astore          4
+        //   290: aload_0
+        //   291: astore_2
+        //   292: aload_1
+        //   293: astore_0
+        //   294: aload_2
+        //   295: astore_1
+        //   296: goto            199
+        //   299: astore          4
+        //   301: aload_1
+        //   302: astore_0
+        //   303: aload           5
+        //   305: astore_1
+        //   306: goto            153
+        //   309: astore          4
+        //   311: aload_0
+        //   312: astore_2
+        //   313: aload_1
+        //   314: astore_0
+        //   315: aload_2
+        //   316: astore_1
+        //   317: goto            153
+        //    Exceptions:
+        //  Try           Handler
+        //  Start  End    Start  End    Type
+        //  -----  -----  -----  -----  -------------------------------
+        //  34     38     145    153    Ljava/io/FileNotFoundException;
+        //  34     38     191    199    Ljava/io/IOException;
+        //  34     38     237    238    Any
+        //  44     49     145    153    Ljava/io/FileNotFoundException;
+        //  44     49     191    199    Ljava/io/IOException;
+        //  44     49     237    238    Any
+        //  55     61     145    153    Ljava/io/FileNotFoundException;
+        //  55     61     191    199    Ljava/io/IOException;
+        //  55     61     237    238    Any
+        //  67     73     145    153    Ljava/io/FileNotFoundException;
+        //  67     73     191    199    Ljava/io/IOException;
+        //  67     73     237    238    Any
+        //  73     93     299    309    Ljava/io/FileNotFoundException;
+        //  73     93     278    288    Ljava/io/IOException;
+        //  73     93     261    270    Any
+        //  93     125    309    320    Ljava/io/FileNotFoundException;
+        //  93     125    288    299    Ljava/io/IOException;
+        //  93     125    270    278    Any
+        //  129    133    135    140    Ljava/io/IOException;
+        //  157    168    237    238    Any
+        //  172    176    181    186    Ljava/io/IOException;
+        //  203    214    237    238    Any
+        //  218    222    227    232    Ljava/io/IOException;
+        //  242    246    251    256    Ljava/io/IOException;
+        //
+        // The error that occurred was:
+        //
+        // java.lang.IndexOutOfBoundsException: Index: 188, Size: 188
+        //     at java.util.ArrayList.rangeCheck(ArrayList.java:638)
+        //     at java.util.ArrayList.get(ArrayList.java:414)
+        //     at com.strobel.decompiler.ast.AstBuilder.convertToAst(AstBuilder.java:3303)
+        //     at com.strobel.decompiler.ast.AstBuilder.build(AstBuilder.java:113)
+        //     at com.strobel.decompiler.languages.java.ast.AstMethodBodyBuilder.createMethodBody(AstMethodBodyBuilder.java:210)
+        //     at com.strobel.decompiler.languages.java.ast.AstMethodBodyBuilder.createMethodBody(AstMethodBodyBuilder.java:99)
+        //     at com.strobel.decompiler.languages.java.ast.AstBuilder.createMethodBody(AstBuilder.java:757)
+        //     at com.strobel.decompiler.languages.java.ast.AstBuilder.createMethod(AstBuilder.java:655)
+        //     at com.strobel.decompiler.languages.java.ast.AstBuilder.addTypeMembers(AstBuilder.java:532)
+        //     at com.strobel.decompiler.languages.java.ast.AstBuilder.createTypeCore(AstBuilder.java:499)
+        //     at com.strobel.decompiler.languages.java.ast.AstBuilder.createTypeNoCache(AstBuilder.java:141)
+        //     at com.strobel.decompiler.languages.java.ast.AstBuilder.createType(AstBuilder.java:130)
+        //     at com.strobel.decompiler.languages.java.ast.AstBuilder.addType(AstBuilder.java:105)
+        //     at com.strobel.decompiler.languages.java.JavaLanguage.buildAst(JavaLanguage.java:71)
+        //     at com.strobel.decompiler.languages.java.JavaLanguage.decompileType(JavaLanguage.java:59)
+        //     at com.strobel.decompiler.DecompilerDriver.decompileType(DecompilerDriver.java:317)
+        //     at com.strobel.decompiler.DecompilerDriver.decompileJar(DecompilerDriver.java:238)
+        //     at com.strobel.decompiler.DecompilerDriver.main(DecompilerDriver.java:138)
+        //
+        throw new IllegalStateException("An error occurred while decompiling this method.");
+    }
+
+    public static void setEseSmartMX(Context context, boolean b) {
+        final ContentResolver contentResolver = context.getContentResolver();
+        int n;
+        if (b) {
+            n = 1;
+        }
+        else {
+            n = 0;
+        }
+        Settings.Secure.putInt(contentResolver, "smartmx_ese", n);
+    }
+}
diff --git a/core/java/android/provider/MzSettings.java b/core/java/android/provider/MzSettings.java
new file mode 100644
index 00000000..b34753c6
--- /dev/null
+++ b/core/java/android/provider/MzSettings.java
@@ -0,0 +1,223 @@
+//
+// Reworked decompiled by Procyon v0.5.30
+//
+
+package android.provider;
+
+import java.util.HashSet;
+
+public final class MzSettings
+{
+    public static final class Global
+    {
+        public static final String AUTO_ANSWER_INCOMING_RINGING = "auto_answer_incoming_ringing";
+        public static final String AUTO_RECORD_ALERT_COUNT = "auto_record_alert_count";
+        public static final String AUTO_RECORD_WHEN_CALLING = "auto_record_when_calling";
+        public static final String CHARGED_SOUND = "charged_sound";
+        public static final String MEIZU_ALI_ENABLE_TRANSFER = "ali_enable_transfer";
+        public static final String MEIZU_BLUETOOTH_CONNECT_AFTER_PAIR = "bluetooth_connect_after_pair";
+        public static final String MEIZU_BLUETOOTH_HOST_START_PAIR = "bluetooth_host_start_pair";
+        public static final String MEIZU_INFO_PHONE_NUMBER_ENABLE = "enable_query_info_phone_number";
+        public static final String MEIZU_LAKALA_ENABLE_TRANSFER = "lakala_enable_transfer";
+        public static final String MEIZU_NFC_SLEEP_MODE_WAKEUP_SCREEN = "nfc_sleep_mode_wakeup_screen";
+        public static final String MEIZU_SHOW_HIDDEN_MENU = "show_hidden_menu";
+        public static final String MEIZU_SHOW_NFC_STATUSBAR_SWITCH = "show_nfc_statusbar_switch";
+        public static final String MEIZU_SHOW_VPN_STATUSBAR_SWITCH = "show_vpn_statusbar_switch";
+        public static final String MEIZU_TETHER_ENABLE_BLUETOOTH = "tether_enable_bluetooth";
+        public static final String MZ_WIFI_SCAN_ALWAYS_AVAILABLE_REMEMBERED = "wifi_scan_always_enabled_remembered";
+        public static final String PLUDIN_SOUND = "plugin_sound";
+        public static final String PREFIX_DIALING_NUMBER = "prefix_dialing_number";
+        public static final String VIBRATE_WHEN_MOCALL_CONNECTED = "vibrate_when_mocall_connected";
+        public static final String WHITE_LIST_DISTURB_ENABLE = "white_list_disturb_enable";
+    }
+
+    public static final class Secure
+    {
+        public static final String ESE_SMARTMX = "smartmx_ese";
+        public static final String MEIZU_DEVICE_NAME = "meizu_device_name";
+        public static final String MEIZU_KEYGUARD_LOCK = "meizu_keyguard_lock";
+        public static final HashSet<String> MEIZU_NO_SECURE = new HashSet<String>(30);
+        public static final String MEIZU_PASSWORD_FRONT_FOUR = "meizu_password_fronts_four";
+        public static final String MEIZU_PASSWORD_LENGTH = "meizu_password_length";
+        public static final String MEIZU_PASSWORD_TYPE = "meizu_password_type";
+        public static final String MZ_BT_SESSION_STATUS = "mz_bt_session_status";
+        public static final String MZ_CURRENT_POWER_MODE = "mz_current_power_mode";
+        public static final String MZ_DRIVE_MODE = "mz_drive_mode";
+        public static final String MZ_DRIVE_MODE_BLUETOOTH_DEVICE = "mz_drive_mode_bluetooth_device";
+        public static final String MZ_DRIVE_MODE_BLUETOOTH_DEVICE_NAME = "mz_driver_mode_bluetooth_device_name";
+        public static final String MZ_DRIVE_MODE_BLUETOOTH_TRIGGER = "mz_drive_mode_bluetooth_trigger";
+        public static final String MZ_DRIVE_MODE_INCALL_VOICE = "mz_drive_mode_incall_voice";
+        public static final String MZ_DRIVE_MODE_INMSG_VOICE = "mz_drive_mode_inmsg_voice";
+        public static final String MZ_DRIVE_MODE_MUSIC_AUTOPLAY = "mz_drive_mode_music_autoplay";
+        public static final String MZ_DRIVE_MODE_REJECT_INCALL_MSG = "mz_drive_mode_reject_incall_msg";
+        public static final String MZ_DRIVE_MODE_REJECT_INCALL_MSG_CONTENT = "mz_drive_mode_reject_incall_msg_content";
+        public static final String MZ_ENABLE_TETHER_TOTAL = "mz_enable_tether_total";
+        public static final String MZ_FINGERPRINT_INDEX_LIST = "mz_fingerprint_index_list";
+        public static final String MZ_FINGERPRINT_LAST_ENROLLED_INDEX = "mz_fingerprint_last_enrolled_index";
+        public static final String MZ_FINGERPRINT_NAME_PREFIX = "mz_fingerprint_name_";
+        public static final String MZ_GUEST_MODE_PASSWORD = "mz_guest_mode_password";
+        public static final String MZ_NEED_COMPATIBLE_PASSWORD = "mz_need_compatible_password";
+        public static final String MZ_NFCP2P_DRAG_GUIDE = "mz_nfcp2p_drag_guide";
+        public static final String MZ_NFCP2P_ON = "mz_nfcp2p_on";
+        public static final String MZ_PASSWORD_LENGTH_APPLOCK = "mz_password_length_applock";
+        public static final String MZ_PASSWORD_LENGTH_DOCUMENT = "mz_password_length_document";
+        public static final String MZ_PASSWORD_TYPE_APPLOCK = "mz_password_type_app_lock";
+        public static final String MZ_PASSWORD_TYPE_DOCUMENT = "mz_password_type_document";
+        public static final String MZ_SHUTDOWN_VERIFY_PASSWORD = "meizu_shutdown_verify_password";
+
+        static {
+            MEIZU_NO_SECURE.add("mz_smartbar_hit_edge_count_inside");
+            MEIZU_NO_SECURE.add("mz_smartbar_hit_edge_count_outside");
+        }
+    }
+
+    public static final class System
+    {
+        public static final String ALARM_SOUND_FILE_PATH = "alarm_sound_file_path";
+        public static final String BUTTON_BRIGHTNESS = "button_brightness";
+        public static final String CALENDAR_SOUND = "calendar_sound";
+        public static final String CALENDAR_SOUND_FILE_PATH = "calendar_sound_file_path";
+        public static final String CAMERA_SOUND = "camera_sound";
+        public static final String CAMERA_SOUNDS_ENABLED = "camera_sounds_enabled";
+        public static final String CHOOSE_NETWORK_PROVIDER_MODE = "choose_network_provider_mode";
+        public static final String CPU_L = "cpu_l";
+        public static final String EMAIL_SOUND = "email_sound";
+        public static final String EMAIL_SOUND_FILE_PATH = "email_sound_file_path";
+        public static final String ENABLE_SIP_CALL = "enable_sip_call";
+        public static final String ENABLE_SIP_FEATURE = "enable_sip_feature";
+        public static final String FLYME_LOGOUT_CLEAR_FLAG = "flyme_logout_clear_flag";
+        public static final String HAPTIC_FEEDBACK_THEME = "haptic_feedback_theme";
+        public static final String HIFI_MUSIC = "hifi_music";
+        public static final String HIFI_MUSIC_ENABLED = "hifi_music_enabled";
+        public static final String HIFI_MUSIC_PARAM = "hifi_music_param";
+        public static final String INTERCEPT_POERKEY_BY_APPLICATION = "intercpt_powerkey";
+        public static final String INTERNET_CALL_SIP_ENABLE = "internet_call_switch";
+        public static final String KEY_SOUND = "key_sound";
+        public static final String KEY_SOUNDS_ENABLED = "key_sounds_enabled";
+        public static final String KEY_SYSTEM_TIPS_SOUND = "key_system_tips_sound";
+        public static final String LIGHT_FEEDBACK_ENABLED = "light_feedback_enabled";
+        public static final String LIST_HOLD_SOUND = "list_hold_sound";
+        public static final String MEIZU_KEY_WAKEUP_TYPE = "meizu_key_wakeup_type";
+        public static final String MEIZU_SHOPDEMO_TOOL_MUSIC = "meizu_shopdemo_tool_music";
+        public static final String MEIZU_SHOPDEMO_TOOL_MUSIC_VOLUME = "meizu_shopdemo_tool_music_volume";
+        public static final String MEIZU_SHOPDEMO_TOOL_PASSWORD = "meizu_shopdemo_tool_password";
+        public static final String MEIZU_SHOPDEMO_TOOL_PLAYTIME = "meizu_shopdemo_tool_playtime";
+        public static final String MEIZU_SHOPDEMO_TOOL_PLAYTIME_END = "meizu_shopdemo_tool_playtime_end";
+        public static final String MEIZU_SHOPDEMO_TOOL_PLAYTIME_END_DEFAULT_VALUE = "2000";
+        public static final String MEIZU_SHOPDEMO_TOOL_PLAYTIME_START = "meizu_shopdemo_tool_playtime_start";
+        public static final String MEIZU_SHOPDEMO_TOOL_PLAYTIME_START_DEFAULT_VALUE = "1000";
+        public static final String MEIZU_WEEK_START = "week_start";
+        public static final String MMS_SOUND = "mms_sound";
+        public static final String MMS_SOUND_FILE_PATH = "mms_sound_file_path";
+        public static final String MODE_RING_UP = "mode_ring_up";
+        public static final String MZ_APP_LOCK_CONTROL = "mz_app_lock_control";
+        public static final String MZ_CURRENT_NETWROK_SPEED = "mz_current_network_speed";
+        public static final String MZ_DATA_COLLECTION = "meizu_data_collection";
+        public static final String MZ_DATA_SERVICE_RUNNING = "mz_data_service_running";
+        public static final String MZ_DOCUMENT_LOCK = "mz_document_lock";
+        public static final String MZ_DO_NOT_DISTURB_ALLOW_EXIT_DIALOG_FLAG = "mz_do_not_disturb_allow_exit_dialog_flag";
+        public static final String MZ_DO_NOT_DISTURB_END_TIME = "mz_do_not_disturb_end_time";
+        public static final String MZ_DO_NOT_DISTURB_END_TIME_HOUR = "mz_do_not_disturb_end_time_hour";
+        public static final String MZ_DO_NOT_DISTURB_END_TIME_MINUTE = "mz_do_not_disturb_end_time_minutes";
+        public static final String MZ_DO_NOT_DISTURB_IS_WORKING = "mz_do_not_disturb_is_working";
+        public static final String MZ_DO_NOT_DISTURB_PRE_PULSE_STATE = "mz_do_not_disturb_pre_pulse_state";
+        public static final String MZ_DO_NOT_DISTURB_PRE_RINGER_MODE = "mz_do_not_disturb_pre_ringer_mode";
+        public static final String MZ_DO_NOT_DISTURB_PRE_VIBRATE_STATE = "mz_do_not_disturb_pre_vibrate_state";
+        public static final String MZ_DO_NOT_DISTURB_REMIND_REPEATING_COMING_CALL = "mz_do_not_disturb_remind_repeating_coming _call";
+        public static final String MZ_DO_NOT_DISTURB_REPEAT_DAYS = "mz_do_not_disturb_repeat_days";
+        public static final String MZ_DO_NOT_DISTURB_SCREEN_NOT_WAKEUP_BY_NOTIFICATION = "mz_do_not_disturb_screen_not_wakeup_by_notification";
+        public static final String MZ_DO_NOT_DISTURB_SCREEN_OFF_TIME = "mz_do_not_disturb_screen_off_time";
+        public static final String MZ_DO_NOT_DISTURB_START_TIME = "mz_do_not_disturb_start_time";
+        public static final String MZ_DO_NOT_DISTURB_START_TIME_HOUR = "mz_do_not_disturb_start_time_hour";
+        public static final String MZ_DO_NOT_DISTURB_START_TIME_MINUTE = "mz_do_not_disturb_start_time_minute";
+        public static final String MZ_DO_NOT_DISTURB_TIME_SWITCH = "mz_do_not_disturb_time_switch";
+        public static final String MZ_DO_NOT_DISTURB_WAKEUP_BREATH_LIGHT = "mz_do_not_disturb_wakeup_breath_light";
+        public static final String MZ_EASY_MODE = "mz_easy_mode";
+        public static final String MZ_ENABLE_ALARM_ALIGN = "mz_enable_alarm_align";
+        public static final String MZ_ENABLE_FULL_SCREEN_DRAG = "enable_full_screen_drag";
+        public static final String MZ_FLOAT_TOUCH_ENABLE = "mz_float_touch_enable";
+        public static final String MZ_FP_USE_PAYMENT = "mz_fingerprint_use_payment";
+        public static final String MZ_FP_USE_UNLOCK = "mz_fingerprint_use_unlock";
+        public static final String MZ_GUARD_MODE = "mz_guard_mode";
+        public static final String MZ_HOME_KEY_TOUCH_BEHAVIOR = "mz_home_key_touch_behavior";
+        public static final String MZ_INTELLIGENT_VOICE = "mz_intelligent_voice";
+        public static final String MZ_INTELLIGENT_VOICE_HEADSET_WAKEUP = "mz_intelligent_voice_headset_wakeup";
+        public static final String MZ_INTELLIGENT_VOICE_HOME_WAKEUP = "mz_intelligent_voice_home_wakeup";
+        public static final String MZ_KEYGUARD_PALM_REJECTION_ENABLED = "keyguard_palm_rejection";
+        public static final String MZ_MTP_UNLOCKED = "mz_mtp_unlocked";
+        public static final String MZ_POWER_BRIGHT_ALGOL = "mz_power_bright_algol";
+        public static final String MZ_POWER_MODE = "mz_power_mode";
+        public static final String MZ_QUICK_WAKEUP_DOUBLE_CLICK = "mz_quick_wakeup_double_click";
+        public static final String MZ_QUICK_WAKEUP_DRAW_C = "mz_quick_wakeup_draw_c";
+        public static final String MZ_QUICK_WAKEUP_DRAW_C_PACKAGE_DETAIL = "mz_quick_wakeup_draw_c_package_detail";
+        public static final String MZ_QUICK_WAKEUP_DRAW_E = "mz_quick_wakeup_draw_e";
+        public static final String MZ_QUICK_WAKEUP_DRAW_E_PACKAGE_DETAIL = "mz_quick_wakeup_draw_e_package_detail";
+        public static final String MZ_QUICK_WAKEUP_DRAW_M = "mz_quick_wakeup_draw_m";
+        public static final String MZ_QUICK_WAKEUP_DRAW_M_PACKAGE_DETAIL = "mz_quick_wakeup_draw_m_package_detail";
+        public static final String MZ_QUICK_WAKEUP_DRAW_O = "mz_quick_wakeup_draw_o";
+        public static final String MZ_QUICK_WAKEUP_DRAW_O_PACKAGE_DETAIL = "mz_quick_wakeup_draw_o_package_detail";
+        public static final String MZ_QUICK_WAKEUP_DRAW_S = "mz_quick_wakeup_draw_s";
+        public static final String MZ_QUICK_WAKEUP_DRAW_S_PACKAGE_DETAIL = "mz_quick_wakeup_draw_s_package_detail";
+        public static final String MZ_QUICK_WAKEUP_DRAW_V = "mz_quick_wakeup_draw_v";
+        public static final String MZ_QUICK_WAKEUP_DRAW_V_PACKAGE_DETAIL = "mz_quick_wakeup_draw_v_package_detail";
+        public static final String MZ_QUICK_WAKEUP_DRAW_W = "mz_quick_wakeup_draw_w";
+        public static final String MZ_QUICK_WAKEUP_DRAW_W_PACKAGE_DETAIL = "mz_quick_wakeup_draw_w_package_detail";
+        public static final String MZ_QUICK_WAKEUP_DRAW_Z = "mz_quick_wakeup_draw_z";
+        public static final String MZ_QUICK_WAKEUP_DRAW_Z_PACKAGE_DETAIL = "mz_quick_wakeup_draw_z_package_detail";
+        public static final String MZ_QUICK_WAKEUP_SLIDE_DOWN = "mz_quick_wakeup_slide_down";
+        public static final String MZ_QUICK_WAKEUP_SLIDE_LEFT = "mz_quick_wakeup_slide_left";
+        public static final String MZ_QUICK_WAKEUP_SLIDE_LEFT_RIGHT = "mz_quick_wakeup_slide_left_right";
+        public static final String MZ_QUICK_WAKEUP_SLIDE_RIGHT = "mz_quick_wakeup_slide_right";
+        public static final String MZ_QUICK_WAKEUP_SLIDE_RIGHT_PACKAGE_DETAIL = "mz_quick_wakeup_slide_right_package_detail";
+        public static final String MZ_QUICK_WAKEUP_SLIDE_UP = "mz_quick_wakeup_slide_up";
+        public static final String MZ_QUICK_WAKEUP_SWITCH = "mz_quick_wakeup_switch";
+        public static final String MZ_SCHEDULED_POWER_OFF = "mz_scheduled_power_off";
+        public static final String MZ_SCHEDULED_POWER_OFF_DAYS = "mz_scheduled_power_off_days";
+        public static final String MZ_SCHEDULED_POWER_OFF_H = "mz_scheduled_power_off_h";
+        public static final String MZ_SCHEDULED_POWER_OFF_M = "mz_scheduled_power_off_m";
+        public static final String MZ_SCHEDULED_POWER_OFF_TIME = "mz_scheduled_power_off_time";
+        public static final String MZ_SCHEDULED_POWER_ON = "mz_scheduled_power_on";
+        public static final String MZ_SCHEDULED_POWER_ON_DAYS = "mz_scheduled_power_on_days";
+        public static final String MZ_SCHEDULED_POWER_ON_H = "mz_scheduled_power_on_h";
+        public static final String MZ_SCHEDULED_POWER_ON_M = "mz_scheduled_power_on_m";
+        public static final String MZ_SCHEDULED_POWER_ON_TIME = "mz_scheduled_power_on_time";
+        public static final String MZ_SCREEN_ON_WHILE_NOTIFICATION = "mz_screen_on_while_notification";
+        public static final String MZ_SCREEN_SAVE_MODE = "mz_screen_save_mode";
+        public static final String MZ_SET_WALLPAPER_SIMULTANEOUSLY = "set_wallpaper_simultaneously";
+        public static final String MZ_SHOW_ACCESS_PASSWORD = "mz_show_access_password";
+        public static final String MZ_SHOW_MTP_NOTIFICATION = "mz_show_mtp_notification";
+        public static final String MZ_SHOW_USER_GUIDE = "mz_show_user_guide";
+        public static final String MZ_SMARTBAR_AUTO_HIDE = "mz_smartbar_auto_hide";
+        public static final String MZ_SMARTBAR_HEIGHT_VALUE = "mz_smartbar_height_value";
+        public static final String MZ_SMARTBAR_HIT_EDGE_COUNT_INSIDE = "mz_smartbar_hit_edge_count_inside";
+        public static final String MZ_SMARTBAR_HIT_EDGE_COUNT_OUTSIDE = "mz_smartbar_hit_edge_count_outside";
+        public static final String MZ_SMARTBAR_PADDING = "mz_smartbar_padding";
+        public static final String MZ_SMARTBAR_PADDING_VALUE = "mz_smartbar_padding_value";
+        public static final String MZ_SMART_TOUCH_BACK_DISABLE = "mz_float_touch_enable";
+        public static final String MZ_SMART_TOUCH_BEHAVIOR_ALPHA = "mz_smart_touch_behavior_alpha";
+        public static final String MZ_SMART_TOUCH_BEHAVIOR_CLICK = "mz_smart_touch_behavior_click";
+        public static final String MZ_SMART_TOUCH_BEHAVIOR_DOUBLECLICK = "mz_smart_touch_behavior_doubleclick";
+        public static final String MZ_SMART_TOUCH_BEHAVIOR_DOWN = "mz_smart_touch_behavior_down";
+        public static final String MZ_SMART_TOUCH_BEHAVIOR_LEFTRIGHT = "mz_smart_touch_behavior_leftright";
+        public static final String MZ_SMART_TOUCH_BEHAVIOR_LONG = "mz_smart_touch_behavior_long";
+        public static final String MZ_SMART_TOUCH_BEHAVIOR_UP = "mz_smart_touch_behavior_up";
+        public static final String MZ_SMART_TOUCH_SWITCH = "mz_smart_touch_switch";
+        public static final String MZ_SMART_VOICE_WAKEUP_BY_VOICE = "mz_smart_voice_wakeup_by_voice";
+        public static final String MZ_STATUS_BAR_TINT = "mz_status_bar_tint";
+        public static final String MZ_USE_FLYME_COMMUNICATION = "mz_use_flyme_communication";
+        public static final String NETWORK_PROVIDER_PACKAGE = "network_provider_package";
+        public static final String NOTIFICATION_SOUND_FILE_PATH = "notification_sound_file_path";
+        public static final String REJECT_WHEN_OUTOF_PHONEBOOK = "reject_when_outof_phonebook";
+        public static final String REJECT_WHEN_UNKOWN_UNMBER = "reject_when_unkown_number";
+        public static final String RINGTONE_SOUND_FILE_PATH = "ringtone_sound_file_path";
+        public static final String SCREEN_BRIGHTNESS_ANIMATION = "animation_brightness";
+        public static final String SCREEN_BRIGHTNESS_PREFERED = "prefer_screen_brightness";
+        public static final String SCREEN_LUX_PREFERED = "prefer_screen_lux";
+        public static final String SNS_ENALBE = "sns_enable";
+        public static final String SOUND_SPDIF = "sound_spdif";
+        public static final String SOUND_SPDIF_BUTTON = "sound_spdif_button";
+        public static final String SPAM_CALL_FILTER_ENABLE = "spam_call_filter_enable";
+        public static final String SPAM_CALL_FILTER_FROM_CLOUD_LEVEL = "spam_call_filter_from_cloud_level";
+        public static final String STATUSBAR_BATTERY_PERCENT = "statusbar_battery_percent";
+    }
+}
diff --git a/core/java/android/view/IGestureCallback.aidl b/core/java/android/view/IGestureCallback.aidl
new file mode 100644
index 00000000..cea80944
--- /dev/null
+++ b/core/java/android/view/IGestureCallback.aidl
@@ -0,0 +1,10 @@
+package android.view;
+
+/**
+ * Meizu interface
+ *
+ * @hide
+ */
+oneway interface IGestureCallback {
+    void onGestureTrigger(int p0);
+}
diff --git a/core/java/android/view/IGestureManager.aidl b/core/java/android/view/IGestureManager.aidl
new file mode 100644
index 00000000..bf551956
--- /dev/null
+++ b/core/java/android/view/IGestureManager.aidl
@@ -0,0 +1,23 @@
+package android.view;
+
+import android.view.IGestureCallback;
+
+/**
+ * Meizu interface
+ *
+ * @hide
+ */
+interface IGestureManager
+{
+    void pauseAllGesture();
+
+    void registeCallback(IGestureCallback p0, in String p1);
+
+    void removeCallback(IGestureCallback p0);
+
+    void resumeAllGesture();
+
+    // This method differs from original Meizu counterpart: we return true if
+    // this is a correct wakeup gesture
+    boolean triggerGesture();
+}
diff --git a/core/java/android/view/KeyEvent.java b/core/java/android/view/KeyEvent.java
index 8ae8ecce..6150c589 100644
--- a/core/java/android/view/KeyEvent.java
+++ b/core/java/android/view/KeyEvent.java
@@ -749,7 +749,19 @@ public class KeyEvent extends InputEvent implements Parcelable {
     /** Key code constant: Help key. */
     public static final int KEYCODE_HELP = 259;
 
-    private static final int LAST_KEYCODE = KEYCODE_HELP;
+    /* MTK/Meizu key codes */
+    public static final int KEYCODE_WIFI_TOGGLE = 260;
+    public static final int KEYCODE_BT_TOGGLE = 261;
+    public static final int KEYCODE_LOCK_TOGGLE = 262;
+    public static final int KEYCODE_IME_TOGGLE = 263;
+    public static final int KEYCODE_MESSAGING = 264;
+    public static final int KEYCODE_GALLERY = 265;
+    public static final int KEYCODE_GESTURE = 266;
+    public static final int KEYCODE_SLIDE = 267;
+    public static final int KEYCODE_UNLOCK = 268;
+    public static final int KEYCODE_FINGERPRINT = 269;
+
+    private static final int LAST_KEYCODE = KEYCODE_FINGERPRINT;
 
     // NOTE: If you add a new keycode here you must also add it to:
     //  isSystem()
diff --git a/core/java/com/android/internal/os/ZygoteInit.java b/core/java/com/android/internal/os/ZygoteInit.java
index bd0fafcd..1c8fa536 100644
--- a/core/java/com/android/internal/os/ZygoteInit.java
+++ b/core/java/com/android/internal/os/ZygoteInit.java
@@ -509,7 +509,13 @@ public class ZygoteInit {
             Process.setArgV0(parsedArgs.niceName);
         }
 
-        final String systemServerClasspath = Os.getenv("SYSTEMSERVERCLASSPATH");
+        // XXX: add back the two missing CM-specific packages due to possible
+        // MTK bootloader restriction
+        String tmpSystemServerClasspath = Os.getenv("SYSTEMSERVERCLASSPATH");
+        if (tmpSystemServerClasspath != null && !tmpSystemServerClasspath.contains("org.cyanogenmod")) {
+            tmpSystemServerClasspath = "/system/framework/org.cyanogenmod.platform.jar:/system/framework/org.cyanogenmod.hardware.jar:" + tmpSystemServerClasspath;
+        }
+        final String systemServerClasspath = tmpSystemServerClasspath;
         if (systemServerClasspath != null) {
             performSystemServerDexOpt(systemServerClasspath);
         }
diff --git a/core/java/com/mediatek/common/thermal/MtkThermalSwitchConfig.java b/core/java/com/mediatek/common/thermal/MtkThermalSwitchConfig.java
new file mode 100644
index 00000000..4a875262
--- /dev/null
+++ b/core/java/com/mediatek/common/thermal/MtkThermalSwitchConfig.java
@@ -0,0 +1,39 @@
+package com.mediatek.common.thermal;
+
+import java.util.*;
+
+public class MtkThermalSwitchConfig {
+    public static Map<String, Integer> appConfig;
+
+    static {
+        Map<String, Integer> tmp = new HashMap<String, Integer>();
+
+        // Add benchmark app: (package name, timeout value (unit: second))
+        // Sample: tmp.put("com.android.xxx", 180);
+        // Meizu:
+        tmp.put("com.antutu.ABenchMark5", 210);
+        tmp.put("com.andromeda.androbench2", 180);
+        tmp.put("com.antutu.ABenchMark", 410);
+        tmp.put("com.antutu.ABenchMark.GL2", 180);
+        tmp.put("com.appems.hawkeye", 180);
+        tmp.put("com.aurorasoftworks.quadrant.ui.standard", 180);
+        tmp.put("com.dianxinos.toolbox.benchmark", 180);
+        tmp.put("com.drolez.nbench", 200);
+        tmp.put("com.eembc.coremark", 100);
+        tmp.put("com.futuremark.dmandroid.application", 320);
+        tmp.put("com.ludashi.benchmark", 350);
+        tmp.put("com.primatelabs.geekbench", 180);
+        tmp.put("com.primatelabs.geekbench3", 180);
+        tmp.put("eu.chainfire.cfbench", 180);
+        tmp.put("org.zeroxlab.zeroxbenchmark", 300);
+        tmp.put("se.nena.nenamark1", 180);
+        tmp.put("com.greenecomputing.linpack", 300);
+        tmp.put("com.quicinc.vellamo", 560);
+        tmp.put("com.rightware.BasemarkX_Free", 300);
+        tmp.put("com.aurorasoftworks.quadrant.ui.advanced", 180);
+        tmp.put("com.futuremark.pcmark.android.benchmark", 300);
+        tmp.put("com.antutu.ABenchMark.GL2", 300);
+        tmp.put("com.antutu.ABenchMark.GL3", 300);
+        appConfig = Collections.unmodifiableMap(tmp);
+    }
+}
\ No newline at end of file
diff --git a/core/java/com/mediatek/common/thermal/MtkThermalSwitchManager.java b/core/java/com/mediatek/common/thermal/MtkThermalSwitchManager.java
new file mode 100644
index 00000000..183275c9
--- /dev/null
+++ b/core/java/com/mediatek/common/thermal/MtkThermalSwitchManager.java
@@ -0,0 +1,698 @@
+// 
+// Decompiled by Procyon v0.5.30
+// Note: the file was modified to match CyanogenMod PerformanceManager design
+// 
+
+
+package com.mediatek.common.thermal;
+
+import java.io.File;
+import java.io.OutputStreamWriter;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.io.FileInputStream;
+import java.io.BufferedReader;
+import java.io.IOException;
+import java.util.*;
+
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.database.ContentObserver;
+import android.app.AlertDialog;
+import android.content.BroadcastReceiver;
+import android.os.Handler;
+import android.os.HandlerThread;
+import android.os.IBinder;
+import android.os.Looper;
+import android.os.Message;
+import android.os.Process;
+import android.os.ServiceManager;
+import android.provider.Settings;
+import android.util.Log;
+
+import com.mediatek.common.thermal.MtkThermalSwitchConfig;
+
+import meizu.os.IDeviceControlService;
+
+public class MtkThermalSwitchManager {
+    private static final String TAG = "ThermalSwitchManager";
+    private HandlerThread mHandlerThread;
+    private ThermalThreadHandler mHandler;
+    private Context mContext;
+    private int mState;
+    // Meizu
+    private static final int POWER_MODE_HIGHPERFOR = 2;
+    private static final int POWER_MODE_BALANCE = 1;
+    private static final int POWER_MODE_SAVING = 0;
+    private String SettingsCPU_L;
+    private String mPrevious_SettingsCPU_L;
+    private static boolean mPowerModeBenchmark = false;
+    private Method mSaveCPUfreq;
+    private Method mSystemPropertiesGet;
+    private String mAppPackage;
+    private Map<String, Integer> processRecord;
+    Object mDeviceControlManager;
+    BroadcastReceiver mBroadcastReceiver;
+    private AlertDialog mThermalSwitchDialog;
+
+    public enum AppState {
+        Paused,
+        Resumed,
+        Destroyed,
+        Dead
+    }
+
+    class ThermalSwitchState {
+        public static final int Init = 0;
+        public static final int Ready = 1;      // May be TP or DTM
+        public static final int Disabling = 2;  // Switching to TP
+        public static final int Disabled= 3;    // Switched to TP 
+        public static final int Enabling = 4;   // Switching to DTM
+    }
+
+    public MtkThermalSwitchManager(Context context) {
+        super();
+        mContext = context;
+        mState = ThermalSwitchState.Init;
+        mHandlerThread = new HandlerThread(TAG, Process.THREAD_PRIORITY_FOREGROUND);
+        mHandlerThread.start();
+        mHandler = new ThermalThreadHandler(mHandlerThread.getLooper());
+        // Meizu
+        //SettingsCPU_L = "cpu_l";
+        SettingsCPU_L = Settings.Secure.PERFORMANCE_PROFILE;
+        mSaveCPUfreq = null;
+        mSystemPropertiesGet = null;
+        mPrevious_SettingsCPU_L = "cpu_l_p";
+        mBroadcastReceiver = new BroadcastReceiver() {
+            public void onReceive(Context context, Intent intent) {
+                String action = intent.getAction();
+                Log.d(TAG, "received intent " + action);
+                if (Intent.ACTION_BOOT_COMPLETED.equals(action)) {
+                    mHandler.sendMessageDelayed(mHandler.obtainMessage(ThermalThreadHandler.MESSAGE_ACTION_BOOT_COMPLETED), 0L);
+                    Log.d(TAG, "received intent " + action + ",Done!");
+                }
+            }
+        };
+        mPowerModeBenchmark = false;
+        // end Meizu
+        Log.i(TAG, "Created and started thermal switch thread");
+    }
+
+    public void systemReady() {
+        Log.i(TAG, "systemReady, register ACTION_BOOT_COMPLETED");
+        mContext.registerReceiver(mBroadcastReceiver, new IntentFilter(Intent.ACTION_BOOT_COMPLETED), null, mHandler);
+        // Meizu
+        int powerSavingMode = Settings.System.getInt(mContext.getContentResolver(), mPrevious_SettingsCPU_L, 1);
+        if (powerSavingMode > POWER_MODE_HIGHPERFOR || powerSavingMode < POWER_MODE_SAVING) {
+            powerSavingMode = Settings.Secure.getInt(mContext.getContentResolver(), SettingsCPU_L, POWER_MODE_BALANCE);
+            if (powerSavingMode > POWER_MODE_HIGHPERFOR || powerSavingMode < POWER_MODE_SAVING) {
+                powerSavingMode = POWER_MODE_BALANCE;
+            }
+        }
+        Settings.Secure.putInt(mContext.getContentResolver(), SettingsCPU_L, powerSavingMode);
+        Settings.System.putInt(mContext.getContentResolver(), mPrevious_SettingsCPU_L, powerSavingMode);
+        Log.d(TAG, "systemReady, set power mode: " + powerSavingMode);
+        setPowerSavingMode(powerSavingMode);
+    }
+ 
+    public void notifyAppState(String appPackage, AppState appState) {
+        //Log.i(TAG, "notify app state, app: " + appPackage + ", state: " + appState + ", thermal state: " + mState);
+
+        // Check whether appPackage is a benchmark app and whether appState is "Resume"
+//        if (MtkThermalSwitchConfig.appConfig.containsKey(appPackage) &&
+//            appState == AppState.Resumed &&
+//            mState != ThermalSwitchState.Disabling &&
+//            mState != ThermalSwitchState.Enabling) {
+//            Message msg = mHandler.obtainMessage();
+//            msg.what = ThermalThreadHandler.MESSAGE_APP_RESUMED;
+//            msg.arg1 = MtkThermalSwitchConfig.appConfig.get(appPackage);
+//            msg.sendToTarget();
+//        }
+        // Meizu
+        if (MtkThermalSwitchConfig.appConfig.containsKey(appPackage) &&
+                appState == AppState.Resumed &&
+                mState != ThermalSwitchState.Disabling &&
+                mState != ThermalSwitchState.Enabling) {
+            mAppPackage = appPackage;
+            Log.i(TAG, "it is a benchmark app And state is Resumed: " + mAppPackage);
+            sendPowerModeSwitchDialogMsg(mAppPackage);
+        }
+        else if (MtkThermalSwitchConfig.appConfig.containsKey(appPackage) &&
+                (appState == AppState.Dead || appState == AppState.Paused || appState == AppState.Destroyed) &&
+                mState != ThermalSwitchState.Disabling &&
+                mState != ThermalSwitchState.Enabling) {
+            MtkThermalSwitchManager.mPowerModeBenchmark = false;
+            int powerSavingMode = Settings.System.getInt(mContext.getContentResolver(), mPrevious_SettingsCPU_L, 1);
+            if (powerSavingMode > POWER_MODE_HIGHPERFOR || powerSavingMode < POWER_MODE_SAVING) {
+                powerSavingMode = Settings.Secure.getInt(mContext.getContentResolver(), SettingsCPU_L, POWER_MODE_SAVING);
+                if (powerSavingMode > POWER_MODE_HIGHPERFOR || powerSavingMode < POWER_MODE_SAVING) {
+                    powerSavingMode = POWER_MODE_SAVING;
+                }
+            }
+            if (powerSavingMode <= POWER_MODE_HIGHPERFOR && powerSavingMode >= POWER_MODE_SAVING) {
+                Log.i(TAG, "it is a benchmark app And state is Dead: " + appState + ",appPackage:" + appPackage + ", setPowerSavingMode previous state: " + powerSavingMode);
+                Settings.Secure.putInt(mContext.getContentResolver(), SettingsCPU_L, powerSavingMode);
+                Settings.System.putInt(mContext.getContentResolver(), mPrevious_SettingsCPU_L, powerSavingMode);
+                setPowerSavingMode(powerSavingMode);
+            }
+            processRecord.put(mAppPackage, 0);
+        }
+    }
+
+    private void execShellCommand(String shellCommand) {
+        java.lang.Process proc = null;
+        OutputStreamWriter osw = null;
+
+        try {
+            proc = Runtime.getRuntime().exec(shellCommand);
+            osw = new OutputStreamWriter(proc.getOutputStream());
+            if (null != osw) {
+                osw.write(shellCommand);
+                osw.write("\n");
+                osw.write("exit\n");
+                osw.flush();
+                osw.close();
+            }
+        }
+        catch (IOException ex) {
+            Log.e(TAG, "execCommandLine() IO Exception");
+            return;
+        }
+        finally {
+            if (null != osw) {
+                try {
+                    osw.close();
+                }
+                catch (IOException e) {}
+            }
+        }
+
+        try {
+            proc.waitFor();
+        }
+        catch (InterruptedException e) {}
+
+        if (proc.exitValue() != 0) {
+            Log.e(TAG, "execCommandLine() Err exit code: " + proc.exitValue());
+        }
+    }
+
+    private void changeToThermalProtection()
+    {
+        execShellCommand("/system/bin/thermal_manager /etc/.tp/thermal.off.conf");
+        // Meizu
+        int powerMode = Settings.Secure.getInt(mContext.getContentResolver(), SettingsCPU_L, POWER_MODE_BALANCE);
+        if (powerMode > POWER_MODE_HIGHPERFOR || powerMode < POWER_MODE_SAVING) {
+            powerMode = POWER_MODE_BALANCE;
+        }
+        Message message = mHandler.obtainMessage(ThermalThreadHandler.MESSAGE_BENCHMARK_PREVIOUS);
+        message.arg1 = powerMode;
+        mHandler.sendMessageDelayed(message, 1000L);
+        if (powerMode != POWER_MODE_HIGHPERFOR) {
+            Settings.Secure.putInt(mContext.getContentResolver(), SettingsCPU_L, POWER_MODE_HIGHPERFOR);
+        }
+        mPowerModeBenchmark = true;
+        Log.i(TAG, "begin antutu. set previous power mode is " + powerMode);
+    }
+
+    private void changeToDynamicThermalManagement()
+    {
+        // Meizu
+        execShellCommand(MTKToMeizuForDTM("/system/bin/thermal_manager /etc/.tp/thermal.conf"));
+        mPowerModeBenchmark = false;
+        int powerSavingMode = Settings.System.getInt(mContext.getContentResolver(), mPrevious_SettingsCPU_L, POWER_MODE_BALANCE);
+        if (powerSavingMode > POWER_MODE_HIGHPERFOR || powerSavingMode < POWER_MODE_SAVING) {
+            powerSavingMode = Settings.Secure.getInt(mContext.getContentResolver(), SettingsCPU_L, POWER_MODE_SAVING);
+            if (powerSavingMode > POWER_MODE_HIGHPERFOR || powerSavingMode < POWER_MODE_SAVING) {
+                powerSavingMode = POWER_MODE_BALANCE;
+            }
+        }
+        Log.i(TAG, "antutu time out set to powerMode is " + powerSavingMode);
+        if (powerSavingMode <= POWER_MODE_HIGHPERFOR && powerSavingMode >= POWER_MODE_SAVING) {
+            Settings.Secure.putInt(mContext.getContentResolver(), SettingsCPU_L, powerSavingMode);
+            Settings.System.putInt(mContext.getContentResolver(), mPrevious_SettingsCPU_L, powerSavingMode);
+            setPowerSavingMode(powerSavingMode);
+        }
+    }
+
+    private class ThermalThreadHandler extends Handler {
+        private static final int MESSAGE_APP_RESUMED = 0;
+        private static final int MESSAGE_TIMER = 1;
+        // Meizu
+        private static final int MESSAGE_SHOW_DIALOG = 2;
+        private static final int MESSAGE_SETTING_POWERMODE = 3;
+        private static final int MESSAGE_ACTION_BOOT_COMPLETED = 4;
+        private static final int MESSAGE_BENCHMARK_PREVIOUS = 5;
+
+        public ThermalThreadHandler(Looper looper) {
+            super(looper);
+        }
+
+        @Override
+        public void handleMessage(Message msg) {
+            try {
+                switch (msg.what) {
+                    case MESSAGE_APP_RESUMED:
+                    {
+                        // Get current thermal policy. Switch to TP only when current policy is DTM.
+                        boolean dtm = checkIsDTM();
+                        Log.d(TAG, "handleMessage " + msg.what + ", thermal state: " + mState + ", dtm: " + dtm);
+
+                        if (mState == ThermalSwitchState.Ready) {
+                            if (true == dtm) {
+                                // DTM: Change state to Disabling -> Switch to TP -> Start timer -> Change state to Disabled
+                                mState = ThermalSwitchState.Disabling;
+                                changeToThermalProtection();
+                                stopTimer();
+                                startTimer(msg.arg1);
+                                mState = ThermalSwitchState.Disabled;
+                            }
+                        }
+                        else if (mState == ThermalSwitchState.Disabled) {
+                            if (true == dtm) {
+                                // DTM: Change state to Disabling -> Stop timer -> Switch to TP -> Start timer -> Change state to Disabled
+                                mState = ThermalSwitchState.Disabling;
+                                stopTimer();
+                                changeToThermalProtection();
+                                startTimer(msg.arg1);
+                                mState = ThermalSwitchState.Disabled;
+                            }
+                            else {
+                                // TP: reset timer
+                                stopTimer();
+                                startTimer(msg.arg1);
+                            }
+                        }
+                        break;
+                    }
+
+                    case MESSAGE_TIMER:
+                    {
+                        // Get current thermal policy. Switch to TP only when current policy is DTM.
+                        boolean dtm = checkIsDTM();
+                        Log.d(TAG, "handleMessage " + msg.what + ", thermal state: " + mState + ", dtm: " + dtm);
+
+                        // Handle timeout message only when state is Disabled
+                        if (mState == ThermalSwitchState.Disabled) {
+                            if (true == dtm) {
+                                // DTM: Change state to Ready
+                                mState = ThermalSwitchState.Ready;
+                            }
+                            else {
+                                // TP: Change state to Enabling -> Switch to DTM -> Change state to Ready
+                                mState = ThermalSwitchState.Enabling;
+                                changeToDynamicThermalManagement();
+                                mState = ThermalSwitchState.Ready;
+                            }
+                        }
+                        break;
+                    }
+
+                    // Meizu
+                    case MESSAGE_SHOW_DIALOG: {
+                        showPowerModeSwitchDialog();
+                        break;
+                    }
+
+                    case MESSAGE_SETTING_POWERMODE: {
+                        setPowerSavingMode(msg.arg1);
+                        break;
+                    }
+
+                    case MESSAGE_ACTION_BOOT_COMPLETED: {
+                        HandleOnReceiveBootCompleted();
+                        break;
+                    }
+
+                    case MESSAGE_BENCHMARK_PREVIOUS: {
+                        Settings.System.putInt(mContext.getContentResolver(), mPrevious_SettingsCPU_L, msg.arg1);
+                        break;
+                    }
+
+                }
+            } catch (Exception e) {
+                Log.e(TAG, "Exception in ThermalThreadHandler.handleMessage: ", e);
+            }
+        }
+
+        private void startTimer(int delay) {
+            Message msg = obtainMessage(MESSAGE_TIMER);
+            sendMessageDelayed(msg, delay * 1000);
+        }
+
+        private void stopTimer() {
+            removeMessages(MESSAGE_TIMER);
+        }
+
+        private boolean checkIsDTM() {
+            boolean ret = false;
+            File f = new File("/data/.tp.settings");
+
+            if(f.exists() == false) {
+                // File not found -> apply one thermal policy and thermal will create the file
+                execShellCommand(MTKToMeizuForDTM("/system/bin/thermal_manager /etc/.tp/thermal.conf"));
+            }
+
+            f = new File("/data/.tp.settings");
+            if (f.exists()) {
+                try {
+                    // Open the file for reading
+                    InputStream instream = new FileInputStream(f);
+
+                    // If file is available for reading
+                    if (instream != null) {
+                        // Prepare the file for reading
+                        InputStreamReader inputReader = new InputStreamReader(instream);
+                        BufferedReader buffReader = new BufferedReader(inputReader);
+                        String line;
+
+                        if ((line = buffReader.readLine()) != null) {
+                            if (line.equals("/etc/.tp/thermal.conf") ||
+                                line.equals("/etc/.tp/thermal.high.conf") ||
+                                line.equals("/etc/.tp/thermal.mid.conf") ||
+                                line.equals("/etc/.tp/thermal.low.conf")) {
+                                ret = true;
+                            }
+                        }
+                    }
+
+                    // Close the file
+                    instream.close();
+                } catch (IOException e) {}
+            }
+
+            return ret;
+        }
+        
+        // TODO: rework this if need to be enabled (ThermalSwitchDialogBuilder to be ported)
+        private void showPowerModeSwitchDialog() {
+//            final boolean checkIsDTM = checkIsDTM();
+//            if (mThermalSwitchDialog == null && checkIsDTM) {
+//                ThermalSwitchDialogBuilder thermalSwitchDialogBuilder = new ThermalSwitchDialogBuilder(mContext);
+//                mThermalSwitchDialog = thermalSwitchDialogBuilder.create();
+//                thermalSwitchDialogBuilder.setOnThermalSwitchListener(new ThermalSwitchDialogBuilder.OnThermalSwitchClickListener() {
+//                    @Override
+//                    public void onThermalSwitchClick(boolean b) {
+//                        if (b) {
+//                            handlePowerModeSwitch(0);
+//                        }
+//                        else {
+//                            handlePowerModeSwitch(1);
+//                        }
+//                        mThermalSwitchDialog.dismiss();
+//                    }
+//                });
+//                thermalSwitchDialogBuilder.mDialogBuilderHomeWatcher.setOnHomePressedListener(new ThermalSwitchDialogBuilder.OnHomePressedListener() {
+//                    @Override
+//                    public void onHomeLongPressed() {
+//                        Log.d(TAG, "onHomeLongPressed");
+//                        mThermalSwitchDialog.dismiss();
+//                        mThermalSwitchDialog = null;
+//                        if (mAppPackage != null && processRecord != null && processRecord.containsKey(mAppPackage)) {
+//                            processRecord.put(mAppPackage, 0);
+//                        }
+//                    }
+//                    
+//                    @Override
+//                    public void onHomePressed() {
+//                        Log.d(TAG, "onHomePressed");
+//                        mThermalSwitchDialog.dismiss();
+//                        mThermalSwitchDialog = null;
+//                        if (mAppPackage != null && processRecord != null && processRecord.containsKey(mAppPackage)) {
+//                            processRecord.put(mAppPackage, 0);
+//                        }
+//                    }
+//                });
+//                mThermalSwitchDialog.getWindow().setType(2003);
+//                mThermalSwitchDialog.setCanceledOnTouchOutside(false);
+//                mThermalSwitchDialog.show();
+//                Log.d(TAG, "it is Create mThermalSwitchDialogBuilder*************");
+//            }
+//            else {
+//                if (!mThermalSwitchDialog.isShowing()) {
+//                    mThermalSwitchDialog.show();
+//                }
+//                Log.d(TAG, "The Dialog is not dismiss!");
+//            }
+        }
+
+    }
+
+
+// Meizu replaced the broadcast receiver with few functions
+//    BroadcastReceiver mBroadcastReceiver = new BroadcastReceiver() {
+//        public void onReceive(Context context, Intent intent) {
+//            String action = intent.getAction();
+//            Log.d(TAG, "received intent " + action);
+//
+//            // Check if app timeout is smaller than thermal reset time
+//            if (Intent.ACTION_BOOT_COMPLETED.equals(action)) {
+//                int appTimeout = Integer.MAX_VALUE;
+//                int resetTime = 60; // Default thermal reset time is 60s if can not get the value
+//                File f = new File("/data/.tp.settings");
+//
+//                // Get the smallest app timeout                
+//                for (Object o : MtkThermalSwitchConfig.appConfig.keySet()) {
+//                    if (MtkThermalSwitchConfig.appConfig.get(o) < appTimeout) {
+//                        appTimeout = MtkThermalSwitchConfig.appConfig.get(o);
+//                    }
+//                }
+//                Log.d(TAG, "smallest app timeout: " + appTimeout + " seconds");
+//
+//                // Get thermal reset time
+//                if(f.exists() == false) {
+//                    // File not found -> apply one thermal policy and thermal will create the file
+//                    execShellCommand("/system/bin/thermal_manager /etc/.tp/thermal.conf");
+//                }
+//
+//                f = new File("/data/.tp.settings");
+//                if (f.exists()) {
+//                    try {
+//                        // Open the file for reading
+//                        InputStream instream = new FileInputStream(f);
+//
+//                        // If file is available for reading
+//                        if (instream != null) {
+//                            // Prepare the file for reading
+//                            InputStreamReader inputReader = new InputStreamReader(instream);
+//                            BufferedReader buffReader = new BufferedReader(inputReader);
+//                            String line;
+//
+//                            if (buffReader.readLine() != null) {
+//                                if ((line = buffReader.readLine()) != null) {
+//                                    resetTime = Integer.parseInt(line.trim());
+//                                }
+//                            }
+//                        }
+//
+//                        // Close the file
+//                        instream.close();
+//                    } catch (IOException e) {}
+//                }
+//  
+//                Log.d(TAG, "thermal reset time: " + resetTime);
+//
+//                // Compare app timeout with thermal reset time
+//                assertFalse(appTimeout < resetTime);
+//
+//                mState = ThermalSwitchState.Ready;
+//            }
+//        }
+//    };
+
+    private String systemPropertiesGet(String property, String defValue) {
+        String result = null;
+        if (mSystemPropertiesGet == null) {
+            return null;
+        }
+        try {
+            result = (String)mSystemPropertiesGet.invoke(null, property, defValue);
+            Log.d(TAG, "systemPropertiesGet: systemProperties:" + property + ",result:" + result);
+            return result;
+        }
+        catch (IllegalAccessException ex) {
+            ex.printStackTrace();
+            return null;
+        }
+        catch (IllegalArgumentException ex2) {
+            ex2.printStackTrace();
+            return null;
+        }
+        catch (InvocationTargetException ex3) {
+            ex3.printStackTrace();
+            return null;
+        }
+    }
+
+    private boolean isBuildCTAMode() {
+        String ctaPropValue = systemPropertiesGet("ro.build.cta", "unknown");
+        boolean result = false;
+        if (ctaPropValue != null && ctaPropValue.length() > 0 && ctaPropValue.equals("cta")) {
+            Log.d(TAG, "set Build CTA true");
+            result = true;
+        }
+        return result;
+    }
+
+    private boolean isWifiTestMode() {
+        boolean result = false;
+        String wifTestPropValue = systemPropertiesGet("sys.wifiTestMode", "unknown");
+        if (wifTestPropValue != null && wifTestPropValue.length() > 0 && 
+                wifTestPropValue.charAt(0) == '1') {
+            Log.d(TAG, "set enableAdb true for wifitest");
+            result = true;
+        }
+        return result;
+    }
+
+    private void setPowerSavingMode(int n) {
+        Log.d(TAG, "setPowerSavingMode powerMode:" + n);
+        if (mSaveCPUfreq == null || mDeviceControlManager == null) {
+            Log.d(TAG, "setPowerSavingMode mSaveCPUfreq == " + mSaveCPUfreq + " || mDeviceControlManager == " + mDeviceControlManager);
+        } else {
+            try {
+                mSaveCPUfreq.invoke(mDeviceControlManager, n);
+                if (!MtkThermalSwitchManager.mPowerModeBenchmark) {
+                    String mtkToMeizuForDTM = MTKToMeizuForDTM("/system/bin/thermal_manager /etc/.tp/thermal.conf");
+                    Log.d(TAG, "setPowerSavingMode command:" + mtkToMeizuForDTM + ",powerMode:" + n);
+                    execShellCommand(mtkToMeizuForDTM);
+                }
+            }
+            catch (IllegalAccessException ex) {
+                ex.printStackTrace();
+            }
+            catch (IllegalArgumentException ex2) {
+                ex2.printStackTrace();
+            }
+            catch (InvocationTargetException ex3) {
+                ex3.printStackTrace();
+            }
+        }
+    }
+
+    public boolean setPowerMode(int powerMode) {
+        Message msg = mHandler.obtainMessage(ThermalThreadHandler.MESSAGE_SETTING_POWERMODE);
+        msg.arg1 = powerMode;
+        mHandler.sendMessageDelayed(msg, 0L);
+        return true;
+    }
+
+    private void initProcessStartRecord() {
+        processRecord = new HashMap<String, Integer>();
+        for (Map.Entry<String, Integer> entry : MtkThermalSwitchConfig.appConfig.entrySet()) {
+            processRecord.put(entry.getKey().toString(), 0);
+            Log.d(TAG, "ProcessStartRecord info.getkey()=" + entry.getKey().toString());
+        }
+    }
+
+    private void initPowerSavingMode() {
+        try {
+            
+            IBinder checkService = ServiceManager.checkService("device_control");
+            if (checkService != null) {
+                mDeviceControlManager = IDeviceControlService.Stub.asInterface(checkService);
+            }
+            //Class.forName("meizu.os.DeviceControlManager");
+            //mDeviceControlManager = mContext.getSystemService("device_control");
+            if (mDeviceControlManager != null) {
+                Log.d(TAG, "initPowerSavingMode  mDeviceControlManager successfull!");
+                mSaveCPUfreq = mDeviceControlManager.getClass().getMethod("saveCPUfreq", Integer.TYPE);
+                Log.d(TAG, "initPowerSavingMode  mDeviceControlManager mSaveCPUfreq:" + mSaveCPUfreq);
+                mSystemPropertiesGet = Class.forName("android.os.SystemProperties").getDeclaredMethod("get", String.class, String.class);
+                boolean nonCTA = true;
+                if (isWifiTestMode()) {
+                    return;
+                }
+                int initialPowerMode = Settings.Secure.getInt(mContext.getContentResolver(), SettingsCPU_L, POWER_MODE_BALANCE);
+                if (isBuildCTAMode()) {
+                    initialPowerMode = POWER_MODE_BALANCE;
+                    nonCTA = false;
+                }
+                setPowerMode(initialPowerMode);
+                Log.d(TAG, "initPowerSavingMode updateMode:" + nonCTA + ",powerMode:" + initialPowerMode);
+                if (nonCTA) {
+                    mContext.getContentResolver().registerContentObserver(Settings.Secure.getUriFor(SettingsCPU_L), false, (ContentObserver)new ContentObserver(null) {
+                        public void onChange(boolean b) {
+                            int powerMode = Settings.Secure.getInt(mContext.getContentResolver(), SettingsCPU_L, POWER_MODE_BALANCE);
+                            if (powerMode > POWER_MODE_HIGHPERFOR || powerMode < POWER_MODE_SAVING) {
+                                powerMode = POWER_MODE_BALANCE;
+                            }
+                            Settings.System.putInt(mContext.getContentResolver(), mPrevious_SettingsCPU_L, powerMode);
+                            Log.d(TAG, "initPowerSavingMode  onChange powerMode=" + powerMode);
+                            if (powerMode == POWER_MODE_BALANCE || powerMode == POWER_MODE_SAVING) {
+                                mPowerModeBenchmark = false;
+                            }
+                            // Disabled by divis1969 to allow high performance profile
+                            //if (powerMode != POWER_MODE_HIGHPERFOR) {
+                                setPowerMode(powerMode);
+                            //}
+                        }
+                    });
+                }
+            }
+        }
+        catch (ClassNotFoundException ex) {
+            ex.printStackTrace();
+        }
+        catch (NoSuchMethodException ex2) {
+            ex2.printStackTrace();
+        }
+    }
+
+    private String MTKToMeizuForDTM(String s) {
+        String string = s;
+        if (s.endsWith("/etc/.tp/thermal.conf")) {
+            int powerMode = Settings.Secure.getInt(mContext.getContentResolver(), SettingsCPU_L, POWER_MODE_BALANCE);
+            if (powerMode == POWER_MODE_HIGHPERFOR) {
+                s = "/etc/.tp/thermal.high.conf";
+            } else if (powerMode == POWER_MODE_SAVING) {
+                s = "/etc/.tp/thermal.low.conf";
+            } else {
+                s = "/etc/.tp/thermal.mid.conf";
+            }
+            string = "/system/bin/thermal_manager " + s;
+        }
+        return string;
+    }
+
+    private void HandleOnReceiveBootCompleted() {
+        if (!new File("/data/.tp.settings").exists()) {
+            execShellCommand(MTKToMeizuForDTM("/system/bin/thermal_manager /etc/.tp/thermal.conf"));
+        }
+        mState = ThermalSwitchState.Ready;
+        initProcessStartRecord();
+        initPowerSavingMode();
+    }
+
+    private void handlePowerModeSwitch(int n) {
+        String appPackage = mAppPackage;
+        if (appPackage == null) {
+            Log.d(TAG, "handlePowerModeSwitch mAppPackage == null!!!");
+        }
+        else if (n == POWER_MODE_BALANCE) {
+            Log.i(TAG, "handlePowerModeSwitch POWER_MODE_BALANCE");
+            Settings.Secure.putInt(mContext.getContentResolver(), SettingsCPU_L, POWER_MODE_BALANCE);
+        }
+        else if (n == POWER_MODE_HIGHPERFOR) {
+            Message obtainMessage = mHandler.obtainMessage(ThermalThreadHandler.MESSAGE_APP_RESUMED);
+            obtainMessage.arg1 = MtkThermalSwitchConfig.appConfig.get(appPackage);
+            mHandler.sendMessageDelayed(obtainMessage, 0L);
+            Log.i(TAG, "handlePowerModeSwitch powerMode:" + n + ",appPackage:" + appPackage + "/" + obtainMessage.arg1);
+        }
+    }
+
+    private void sendPowerModeSwitchDialogMsg(String app) {
+        int powerMode = Settings.Secure.getInt(mContext.getContentResolver(), SettingsCPU_L, POWER_MODE_BALANCE);
+        if (powerMode == 0) {
+            Log.i(TAG, "Don't Show Dialog! powerMode:" + powerMode);
+            handlePowerModeSwitch(POWER_MODE_HIGHPERFOR);
+        } else if (processRecord.get(app) == 0) {
+            Log.i(TAG, "Show Dialog! powerMode:" + powerMode);
+            mHandler.sendMessageDelayed(mHandler.obtainMessage(ThermalThreadHandler.MESSAGE_SHOW_DIALOG), 0L);
+            processRecord.put(app, 1);
+        }
+    }
+}
diff --git a/core/java/com/mediatek/perfservice/IPerfService.aidl b/core/java/com/mediatek/perfservice/IPerfService.aidl
new file mode 100644
index 00000000..d68c7b5b
--- /dev/null
+++ b/core/java/com/mediatek/perfservice/IPerfService.aidl
@@ -0,0 +1,63 @@
+//
+// Decompiled by Procyon v0.5.30
+//
+
+package com.mediatek.perfservice;
+
+import android.os.Parcel;
+import android.os.IBinder;
+import android.os.Binder;
+import android.os.RemoteException;
+import android.os.IInterface;
+
+interface IPerfService
+{
+    void boostEnable(int p0);
+
+    void boostDisable(int p0);
+
+    void boostEnableTimeout(int p0, int p1);
+
+    void boostEnableTimeoutMs(int p0, int p1);
+
+    void notifyAppState(String p0, String p1, int p2);
+
+    int userReg(int p0, int p1, int p2, int p3);
+
+    int userRegBigLittle(int p0, int p1, int p2, int p3, int p4, int p5);
+
+    void userUnreg(int p0);
+
+    int userGetCapability(int p0);
+
+    int userRegScn(int p0, int p1);
+
+    void userRegScnConfig(int p0, int p1, int p2, int p3, int p4, int p5);
+
+    void userUnregScn(int p0);
+
+    void userEnable(int p0);
+
+    void userEnableTimeout(int p0, int p1);
+
+    void userEnableTimeoutMs(int p0, int p1);
+
+    void userDisable(int p0);
+
+    void userResetAll();
+
+    void userDisableAll();
+
+    void userRestoreAll();
+
+    void dumpAll();
+
+    void setFavorPid(int p0);
+
+    void notifyFrameUpdate(int p0);
+
+    void notifyDisplayType(int p0);
+
+    void notifyUserStatus(int p0, int p1);
+
+}
\ No newline at end of file
diff --git a/core/java/com/mediatek/perfservice/IPerfServiceManager.java b/core/java/com/mediatek/perfservice/IPerfServiceManager.java
new file mode 100644
index 00000000..bbc3a3a1
--- /dev/null
+++ b/core/java/com/mediatek/perfservice/IPerfServiceManager.java
@@ -0,0 +1,78 @@
+//
+// Decompiled by Procyon v0.5.30
+//
+
+package com.mediatek.perfservice;
+
+public interface IPerfServiceManager
+{
+    public static final int DISPLAY_TYPE_GAME = 0;
+    public static final int DISPLAY_TYPE_OTHERS = 1;
+    public static final int NOTIFY_USER_TYPE_DISPLAY_TYPE = 2;
+    public static final int NOTIFY_USER_TYPE_FRAME_UPDATE = 1;
+    public static final int NOTIFY_USER_TYPE_PID = 0;
+    public static final int SCN_APP_LAUNCH = 8;
+    public static final int SCN_APP_ROTATE = 2;
+    public static final int SCN_APP_SWITCH = 1;
+    public static final int SCN_APP_TOUCH = 5;
+    public static final int SCN_DONT_USE1 = 6;
+    public static final int SCN_NONE = 0;
+    public static final int SCN_SW_CODEC = 3;
+    public static final int SCN_SW_CODEC_BOOST = 4;
+    public static final int SCN_SW_FRAME_UPDATE = 7;
+    public static final int STATE_DEAD = 3;
+    public static final int STATE_DESTROYED = 2;
+    public static final int STATE_PAUSED = 0;
+    public static final int STATE_RESUMED = 1;
+    public static final int STATE_STOPPED = 4;
+
+    void boostDisable(int p0);
+
+    void boostEnable(int p0);
+
+    void boostEnableTimeout(int p0, int p1);
+
+    void boostEnableTimeoutMs(int p0, int p1);
+
+    void dumpAll();
+
+    void notifyAppState(String p0, String p1, int p2);
+
+    void notifyDisplayType(int p0);
+
+    void notifyFrameUpdate(int p0);
+
+    void notifyUserStatus(int p0, int p1);
+
+    void setFavorPid(int p0);
+
+    void systemReady();
+
+    void userDisable(int p0);
+
+    void userDisableAll();
+
+    void userEnable(int p0);
+
+    void userEnableTimeout(int p0, int p1);
+
+    void userEnableTimeoutMs(int p0, int p1);
+
+    int userGetCapability(int p0);
+
+    int userReg(int p0, int p1, int p2, int p3);
+
+    int userRegBigLittle(int p0, int p1, int p2, int p3, int p4, int p5);
+
+    int userRegScn(int p0, int p1);
+
+    void userRegScnConfig(int p0, int p1, int p2, int p3, int p4, int p5);
+
+    void userResetAll();
+
+    void userRestoreAll();
+
+    void userUnreg(int p0);
+
+    void userUnregScn(int p0);
+}
diff --git a/core/java/com/mediatek/perfservice/IPerfServiceWrapper.java b/core/java/com/mediatek/perfservice/IPerfServiceWrapper.java
new file mode 100644
index 00000000..d874b32d
--- /dev/null
+++ b/core/java/com/mediatek/perfservice/IPerfServiceWrapper.java
@@ -0,0 +1,93 @@
+//
+// Decompiled by Procyon v0.5.30
+//
+
+package com.mediatek.perfservice;
+
+public interface IPerfServiceWrapper
+{
+    public static final int CMD_GET_CPU_FREQ_BIG_LEVEL_COUNT = 2;
+    public static final int CMD_GET_CPU_FREQ_LEVEL_COUNT = 0;
+    public static final int CMD_GET_CPU_FREQ_LITTLE_LEVEL_COUNT = 1;
+    public static final int CMD_GET_GPU_FREQ_LEVEL_COUNT = 3;
+    public static final int CMD_GET_MEM_FREQ_LEVEL_COUNT = 4;
+    public static final int CMD_SET_CPU_CORE_BIG_LITTLE_MAX = 3;
+    public static final int CMD_SET_CPU_CORE_BIG_LITTLE_MIN = 2;
+    public static final int CMD_SET_CPU_CORE_MAX = 1;
+    public static final int CMD_SET_CPU_CORE_MIN = 0;
+    public static final int CMD_SET_CPU_FREQ_BIG_LITTLE_MAX = 7;
+    public static final int CMD_SET_CPU_FREQ_BIG_LITTLE_MIN = 6;
+    public static final int CMD_SET_CPU_FREQ_MAX = 5;
+    public static final int CMD_SET_CPU_FREQ_MIN = 4;
+    public static final int CMD_SET_GPU_FREQ_MAX = 9;
+    public static final int CMD_SET_GPU_FREQ_MIN = 8;
+    public static final int CMD_SET_MEM_FREQ_MAX = 11;
+    public static final int CMD_SET_MEM_FREQ_MIN = 10;
+    public static final int CMD_SET_SCREEN_OFF_STATE = 12;
+    public static final int DISPLAY_TYPE_GAME = 0;
+    public static final int DISPLAY_TYPE_OTHERS = 1;
+    public static final int NOTIFY_USER_TYPE_DISPLAY_TYPE = 2;
+    public static final int NOTIFY_USER_TYPE_FRAME_UPDATE = 1;
+    public static final int NOTIFY_USER_TYPE_PID = 0;
+    public static final int SCN_APP_ROTATE = 2;
+    public static final int SCN_APP_SWITCH = 1;
+    public static final int SCN_APP_TOUCH = 5;
+    public static final int SCN_DONT_USE1 = 6;
+    public static final int SCN_NONE = 0;
+    public static final int SCN_SW_CODEC = 3;
+    public static final int SCN_SW_CODEC_BOOST = 4;
+    public static final int SCN_SW_FRAME_UPDATE = 7;
+    public static final int STATE_DEAD = 3;
+    public static final int STATE_DESTROYED = 2;
+    public static final int STATE_PAUSED = 0;
+    public static final int STATE_RESUMED = 1;
+    public static final int STATE_STOPPED = 4;
+
+    void boostDisable(final int p0);
+
+    void boostEnable(final int p0);
+
+    void boostEnableTimeout(final int p0, final int p1);
+
+    void boostEnableTimeoutMs(final int p0, final int p1);
+
+    void dumpAll();
+
+    void notifyAppState(final String p0, final String p1, final int p2);
+
+    void notifyDisplayType(final int p0);
+
+    void notifyFrameUpdate(final int p0);
+
+    void notifyUserStatus(final int p0, final int p1);
+
+    void setFavorPid(final int p0);
+
+    void userDisable(final int p0);
+
+    void userDisableAll();
+
+    void userEnable(final int p0);
+
+    void userEnableTimeout(final int p0, final int p1);
+
+    void userEnableTimeoutMs(final int p0, final int p1);
+
+    int userGetCapability(final int p0);
+
+    int userReg(final int p0, final int p1);
+
+    int userRegBigLittle(final int p0, final int p1, final int p2, final int p3);
+
+    int userRegScn();
+
+    void userRegScnConfig(final int p0, final int p1, final int p2, final int p3, final int p4, final int p5);
+
+    void userResetAll();
+
+    void userRestoreAll();
+
+    void userUnreg(final int p0);
+
+    void userUnregScn(final int p0);
+}
diff --git a/core/java/com/mediatek/perfservice/PerfServiceWrapper.java b/core/java/com/mediatek/perfservice/PerfServiceWrapper.java
new file mode 100644
index 00000000..b99411f1
--- /dev/null
+++ b/core/java/com/mediatek/perfservice/PerfServiceWrapper.java
@@ -0,0 +1,400 @@
+//
+// Decompiled by Procyon v0.5.30
+//
+
+package com.mediatek.perfservice;
+
+import android.os.RemoteException;
+import com.mediatek.xlog.Xlog;
+import android.os.IBinder;
+import android.os.ServiceManager;
+import android.content.Context;
+
+public class PerfServiceWrapper implements IPerfServiceWrapper
+{
+    private static final int RENDER_THREAD_UPDATE_DURATION = 400;
+    private static final String TAG = "PerfServiceWrapper";
+    private int inited;
+    private Context mContext;
+    private long mPreviousTime;
+    private IPerfService sService;
+    private int setTid;
+
+    public PerfServiceWrapper(Context context) {
+        sService = null;
+        inited = 0;
+        setTid = 0;
+        mPreviousTime = 0L;
+        mContext = context;
+        init();
+    }
+
+    private void init() {
+        if (inited == 0) {
+            IBinder checkService = ServiceManager.checkService("mtk-perfservice");
+            if (checkService != null) {
+                sService = IPerfService.Stub.asInterface(checkService);
+                if (sService != null) {
+                    inited = 1;
+                }
+                else {
+                    log("ERR: getService() sService is still null..");
+                }
+            }
+        }
+    }
+
+    private void log(String s) {
+        Xlog.d("PerfServiceWrapper", "[PerfServiceWrapper] " + s + " ");
+    }
+
+    private void loge(String s) {
+        Xlog.e("PerfServiceWrapper", "[PerfServiceWrapper] ERR: " + s + " ");
+    }
+
+    public static native int nativeGetPid();
+
+    public static native int nativeGetTid();
+
+    @Override
+    public void boostDisable(int n) {
+        try {
+            init();
+            if (sService != null) {
+                sService.boostDisable(n);
+            }
+        }
+        catch (RemoteException ex) {
+            loge("ERR: RemoteException in boostDisable:" + ex);
+        }
+    }
+
+    @Override
+    public void boostEnable(int n) {
+        try {
+            init();
+            if (sService != null) {
+                sService.boostEnable(n);
+            }
+        }
+        catch (RemoteException ex) {
+            loge("ERR: RemoteException in boostEnable:" + ex);
+        }
+    }
+
+    @Override
+    public void boostEnableTimeout(int n, int n2) {
+        try {
+            init();
+            if (sService != null) {
+                sService.boostEnableTimeout(n, n2);
+            }
+        }
+        catch (RemoteException ex) {
+            loge("ERR: RemoteException in boostEnableTimeout:" + ex);
+        }
+    }
+
+    @Override
+    public void boostEnableTimeoutMs(int n, int n2) {
+        try {
+            init();
+            if (sService != null) {
+                sService.boostEnableTimeoutMs(n, n2);
+            }
+        }
+        catch (RemoteException ex) {
+            loge("ERR: RemoteException in boostEnableTimeoutMs:" + ex);
+        }
+    }
+
+    @Override
+    public void dumpAll() {
+        try {
+            init();
+            if (sService != null) {
+                sService.dumpAll();
+            }
+        }
+        catch (RemoteException ex) {
+            loge("ERR: RemoteException in dumpAll:" + ex);
+        }
+    }
+
+    @Override
+    public void notifyAppState(String s, String s2, int n) {
+        try {
+            init();
+            if (sService != null) {
+                sService.notifyAppState(s, s2, n);
+            }
+        }
+        catch (RemoteException ex) {
+            loge("ERR: RemoteException in notifyAppState:" + ex);
+        }
+    }
+
+    @Override
+    public void notifyDisplayType(int n) {
+        try {
+            init();
+            if (sService != null) {
+                sService.notifyDisplayType(n);
+            }
+        }
+        catch (RemoteException ex) {
+            loge("ERR: RemoteException in notifyDisplayType:" + ex);
+        }
+    }
+
+    @Override
+    public void notifyFrameUpdate(int nativeGetTid) {
+        long currentTimeMillis = System.currentTimeMillis();
+        try {
+            init();
+            if (setTid == 0) {
+                nativeGetTid = nativeGetTid();
+                setTid = 1;
+            }
+            if (mPreviousTime == 0L || currentTimeMillis - mPreviousTime > 400L) {
+                if (sService != null) {
+                    sService.notifyFrameUpdate(nativeGetTid);
+                }
+                mPreviousTime = currentTimeMillis;
+            }
+        }
+        catch (RemoteException ex) {
+            loge("ERR: RemoteException in notifyFrameUpdate:" + ex);
+        }
+    }
+
+    @Override
+    public void notifyUserStatus(int n, int n2) {
+        try {
+            init();
+            if (sService != null) {
+                sService.notifyUserStatus(n, n2);
+            }
+        }
+        catch (RemoteException ex) {
+            loge("ERR: RemoteException in notifyUserStatus:" + ex);
+        }
+    }
+
+    @Override
+    public void setFavorPid(int favorPid) {
+        try {
+            init();
+            if (sService != null) {
+                sService.setFavorPid(favorPid);
+            }
+        }
+        catch (RemoteException ex) {
+            loge("ERR: RemoteException in setFavorPid:" + ex);
+        }
+    }
+
+    @Override
+    public void userDisable(int n) {
+        try {
+            init();
+            if (sService != null) {
+                sService.userDisable(n);
+            }
+        }
+        catch (RemoteException ex) {
+            loge("ERR: RemoteException in userDisable:" + ex);
+        }
+    }
+
+    @Override
+    public void userDisableAll() {
+        try {
+            init();
+            if (sService != null) {
+                sService.userDisableAll();
+            }
+        }
+        catch (RemoteException ex) {
+            loge("ERR: RemoteException in userDisableAll:" + ex);
+        }
+    }
+
+    @Override
+    public void userEnable(int n) {
+        try {
+            init();
+            if (sService != null) {
+                sService.userEnable(n);
+            }
+        }
+        catch (RemoteException ex) {
+            loge("ERR: RemoteException in userEnable:" + ex);
+        }
+    }
+
+    @Override
+    public void userEnableTimeout(int n, int n2) {
+        try {
+            init();
+            if (sService != null) {
+                sService.userEnableTimeout(n, n2);
+            }
+        }
+        catch (RemoteException ex) {
+            loge("ERR: RemoteException in userEnableTimeout:" + ex);
+        }
+    }
+
+    @Override
+    public void userEnableTimeoutMs(int n, int n2) {
+        try {
+            init();
+            if (sService != null) {
+                sService.userEnableTimeoutMs(n, n2);
+            }
+        }
+        catch (RemoteException ex) {
+            loge("ERR: RemoteException in userEnableTimeoutMs:" + ex);
+        }
+    }
+
+    @Override
+    public int userGetCapability(int n) {
+        int n2 = -1;
+        try {
+            init();
+            int userGetCapability = n2;
+            if (sService != null) {
+                userGetCapability = sService.userGetCapability(n);
+            }
+            return userGetCapability;
+        }
+        catch (RemoteException ex) {
+            loge("ERR: RemoteException in userGetCapability:" + ex);
+            return n2;
+        }
+    }
+
+    @Override
+    public int userReg(int n, int n2) {
+        int n3 = -1;
+        try {
+            init();
+            int nativeGetPid = nativeGetPid();
+            int nativeGetTid = nativeGetTid();
+            int userReg = n3;
+            if (sService != null) {
+                userReg = sService.userReg(n, n2, nativeGetPid, nativeGetTid);
+            }
+            return userReg;
+        }
+        catch (RemoteException ex) {
+            loge("ERR: RemoteException in userReg:" + ex);
+            return n3;
+        }
+    }
+
+    @Override
+    public int userRegBigLittle(int n, int n2, int n3, int n4) {
+        int n5 = -1;
+        try {
+            init();
+            int nativeGetPid = nativeGetPid();
+            int nativeGetTid = nativeGetTid();
+            int userRegBigLittle = n5;
+            if (sService != null) {
+                userRegBigLittle = sService.userRegBigLittle(n, n2, n3, n4, nativeGetPid, nativeGetTid);
+            }
+            return userRegBigLittle;
+        }
+        catch (RemoteException ex) {
+            loge("ERR: RemoteException in userRegBigLittle:" + ex);
+            return n5;
+        }
+    }
+
+    @Override
+    public int userRegScn() {
+        int n = -1;
+        try {
+            init();
+            int nativeGetPid = nativeGetPid();
+            int nativeGetTid = nativeGetTid();
+            int userRegScn = n;
+            if (sService != null) {
+                userRegScn = sService.userRegScn(nativeGetPid, nativeGetTid);
+            }
+            return userRegScn;
+        }
+        catch (RemoteException ex) {
+            loge("ERR: RemoteException in userRegScn:" + ex);
+            return n;
+        }
+    }
+
+    @Override
+    public void userRegScnConfig(int n, int n2, int n3, int n4, int n5, int n6) {
+        try {
+            init();
+            if (sService != null) {
+                sService.userRegScnConfig(n, n2, n3, n4, n5, n6);
+            }
+        }
+        catch (RemoteException ex) {
+            loge("ERR: RemoteException in userRegScnConfig:" + ex);
+        }
+    }
+
+    @Override
+    public void userResetAll() {
+        try {
+            init();
+            if (sService != null) {
+                sService.userResetAll();
+            }
+        }
+        catch (RemoteException ex) {
+            loge("ERR: RemoteException in userResetAll:" + ex);
+        }
+    }
+
+    @Override
+    public void userRestoreAll() {
+        try {
+            init();
+            if (sService != null) {
+                sService.userRestoreAll();
+            }
+        }
+        catch (RemoteException ex) {
+            loge("ERR: RemoteException in userRestoreAll:" + ex);
+        }
+    }
+
+    @Override
+    public void userUnreg(int n) {
+        try {
+            init();
+            if (sService != null) {
+                sService.userUnreg(n);
+            }
+        }
+        catch (RemoteException ex) {
+            loge("ERR: RemoteException in userUnreg:" + ex);
+        }
+    }
+
+    @Override
+    public void userUnregScn(int n) {
+        try {
+            init();
+            if (sService != null) {
+                sService.userUnregScn(n);
+            }
+        }
+        catch (RemoteException ex) {
+            loge("ERR: RemoteException in userUnregScn:" + ex);
+        }
+    }
+}
diff --git a/core/java/com/mediatek/xlog/Xlog.java b/core/java/com/mediatek/xlog/Xlog.java
new file mode 100644
index 00000000..a04c6779
--- /dev/null
+++ b/core/java/com/mediatek/xlog/Xlog.java
@@ -0,0 +1,95 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein is
+ * confidential and proprietary to MediaTek Inc. and/or its licensors. Without
+ * the prior written permission of MediaTek inc. and/or its licensors, any
+ * reproduction, modification, use or disclosure of MediaTek Software, and
+ * information contained herein, in whole or in part, shall be strictly
+ * prohibited.
+ * 
+ * MediaTek Inc. (C) 2010. All rights reserved.
+ * 
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER
+ * ON AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL
+ * WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR
+ * NONINFRINGEMENT. NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH
+ * RESPECT TO THE SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY,
+ * INCORPORATED IN, OR SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES
+ * TO LOOK ONLY TO SUCH THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO.
+ * RECEIVER EXPRESSLY ACKNOWLEDGES THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO
+ * OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES CONTAINED IN MEDIATEK
+ * SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE
+ * RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S
+ * ENTIRE AND CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE
+ * RELEASED HEREUNDER WILL BE, AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE
+ * MEDIATEK SOFTWARE AT ISSUE, OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE
+ * CHARGE PAID BY RECEIVER TO MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+*
+ * The following software/firmware and/or related documentation ("MediaTek
+ * Software") have been modified by MediaTek Inc. All revisions are subject to
+ * any receiver's applicable license agreements with MediaTek Inc.
+ */
+
+package com.mediatek.xlog;
+
+import android.util.Log;
+
+public final class Xlog {
+    public static int v(String tag, String msg) {
+        //return println_native(Log.LOG_ID_MAIN, Log.VERBOSE, tag, msg);
+        return Log.v(tag, msg);
+    }
+
+    public static int v(String tag, String msg, Throwable tr) {
+        //return println_native(Log.LOG_ID_MAIN, Log.VERBOSE, tag, msg + '\n' + Log.getStackTraceString(tr));
+        return Log.v(tag, msg + '\n' + Log.getStackTraceString(tr));
+    }
+
+    public static int d(String tag, String msg) {
+        //return println_native(Log.LOG_ID_MAIN, Log.DEBUG, tag, msg);
+        return Log.d(tag, msg);
+    }
+
+    public static int d(String tag, String msg, Throwable tr) {
+        //return println_native(Log.LOG_ID_MAIN, Log.DEBUG, tag, msg + '\n' + Log.getStackTraceString(tr));
+        return Log.d(tag, msg + '\n' + Log.getStackTraceString(tr));
+    }
+
+    public static int i(String tag, String msg) {
+        //return println_native(Log.LOG_ID_MAIN, Log.INFO, tag, msg);
+        return Log.i(tag, msg);
+    }
+
+    public static int i(String tag, String msg, Throwable tr) {
+        //return println_native(Log.LOG_ID_MAIN, Log.INFO, tag, msg + '\n' + Log.getStackTraceString(tr));
+        return Log.i(tag, msg + '\n' + Log.getStackTraceString(tr));
+    }
+
+    public static int w(String tag, String msg) {
+        //return println_native(Log.LOG_ID_MAIN, Log.WARN, tag, msg);
+        return Log.w(tag, msg);
+    }
+
+    public static int w(String tag, String msg, Throwable tr) {
+        //return println_native(Log.LOG_ID_MAIN, Log.WARN, tag, msg + '\n' + Log.getStackTraceString(tr));
+        return Log.w(tag, msg + '\n' + Log.getStackTraceString(tr));
+    }
+
+    public static int e(String tag, String msg) {
+        //return println_native(Log.LOG_ID_MAIN, Log.ERROR, tag, msg);
+        return Log.e(tag, msg);
+    }
+
+    public static int e(String tag, String msg, Throwable tr) {
+        //return println_native(Log.LOG_ID_MAIN, Log.ERROR, tag, msg + '\n' + Log.getStackTraceString(tr));
+        return Log.e(tag, msg + '\n' + Log.getStackTraceString(tr));
+    }
+
+    /** at hide */ /*public static native int println_native(int bufID,
+            int priority, String tag, String msg); */
+}
diff --git a/core/java/meizu/os/DeviceControlManager.java b/core/java/meizu/os/DeviceControlManager.java
new file mode 100644
index 00000000..42a5ab69
--- /dev/null
+++ b/core/java/meizu/os/DeviceControlManager.java
@@ -0,0 +1,282 @@
+//
+// Reworked decompiled by Procyon v0.5.30
+//
+
+package meizu.os;
+
+import android.os.RemoteException;
+import android.content.Context;
+//import android.annotation.FlymeHook;
+
+//@FlymeHook(level = FlymeHook.FlymeHookType.NEW_CLASS, note = "Porting DeviceControlManager interface", property = FlymeHook.FlymeRomType.MTK)
+public class DeviceControlManager
+{
+    public static final int DEVCFG_IR_CALIBRATE = 0;
+    public static final int DEVCFG_TOUCH_SCREEN = 1;
+    public static final int DEVCFG_BUTTON_LIGHT = 2;
+    public static final int DEVCFG_LIGHT_SENSOR = 3;
+    public static final int DEVCFG_GRAVITY_SENSOR = 4;
+    public static final int DEVCFG_ACTIVATE_STATS = 5;
+    public static final int DEVCFG_MAINTAIN_STATE = 6;
+    public static final int DEVCFG_SHOPDEMO_TOOL = 8;
+    public static final int DEVCFG_ACCELERATION_SENSOR = 9;
+    public static final int DEVCFG_GYROSCOPE_SENSOR = 10;
+
+    public static final String EARPOD_ADJUST_CMD_UP_KEY_CALIBRATE = "up_key_calibrate";
+    public static final String EARPOD_ADJUST_STATE_COMPLETE = "COMPLETE";
+    public static final String EARPOD_ADJUST_STATE_ERROR = "ERROR";
+    public static final String EARPOD_ADJUST_STATE_PENDING = "PENDING";
+    public Context mContext;
+    public IDeviceControlService mService;
+
+    private static boolean DEBUG = true;
+    private static String TAG = "DeviceControlManager";
+
+    public DeviceControlManager(Context context, IDeviceControlService service) {
+        mContext = context;
+        mService = service;
+    }
+
+    public int adjustGravitySensor(int[] array) {
+        try {
+            return mService.adjustGravitySensor(array);
+        }
+        catch (RemoteException ex) {
+            return -1;
+        }
+    }
+
+    public int calibrateAcceAndGyroSensor() {
+        try {
+            return mService.calibrateAcceAndGyroSensor();
+        }
+        catch (RemoteException ex) {
+            return -1;
+        }
+    }
+
+    public int calibrateAccelerationSensor() {
+        try {
+            return mService.calibrateAccelerationSensor();
+        }
+        catch (RemoteException ex) {
+            return -1;
+        }
+    }
+
+    public int calibrateGp2ap() {
+        try {
+            return mService.calibrateGp2ap();
+        }
+        catch (RemoteException ex) {
+            return -1;
+        }
+    }
+
+    public int calibrateGravitySensor() {
+        try {
+            return mService.calibrateGravitySensor();
+        }
+        catch (RemoteException ex) {
+            return -1;
+        }
+    }
+
+    public int enableTouchAdjust() {
+        try {
+            return mService.enableTouchAdjust();
+        }
+        catch (RemoteException ex) {
+            return -1;
+        }
+    }
+
+    public int readAccelerationSensorCalibValue(int[] array) {
+        try {
+            return mService.readAccelerationSensorCalibValue(array);
+        }
+        catch (RemoteException ex) {
+            return -1;
+        }
+    }
+
+    public int readAutoCabc() {
+        try {
+            return mService.readAutoCabc();
+        }
+        catch (RemoteException ex) {
+            return -1;
+        }
+    }
+
+    public int readCPUfreq() {
+        try {
+            return mService.readCPUfreq();
+        }
+        catch (RemoteException ex) {
+            return -1;
+        }
+    }
+
+    public int readCfgParam(int cfgParam, int[] array) {
+        try {
+            cfgParam = mService.readCfgParam(cfgParam, array);
+            return cfgParam;
+        }
+        catch (RemoteException ex) {
+            cfgParam = -1;
+            return cfgParam;
+        }
+    }
+
+    public String readEarpodAdjustState() {
+        try {
+            return mService.readEarpodAdjustState();
+        }
+        catch (RemoteException ex) {
+            return "ERROR";
+        }
+    }
+
+    public int readGp2apValue() {
+        try {
+            return mService.readGp2apValue();
+        }
+        catch (RemoteException ex) {
+            return -1;
+        }
+    }
+
+    public int readGravityValue(int[] array) {
+        try {
+            return mService.readGravityValue(array);
+        }
+        catch (RemoteException ex) {
+            return -1;
+        }
+    }
+
+    public int resetCalibration() {
+        try {
+            return mService.resetCalibration();
+        }
+        catch (RemoteException ex) {
+            return -1;
+        }
+    }
+
+    public int saveCPUfreq(int saveCPUfreq) {
+        try {
+            saveCPUfreq = mService.saveCPUfreq(saveCPUfreq);
+            return saveCPUfreq;
+        }
+        catch (RemoteException ex) {
+            saveCPUfreq = -1;
+            return saveCPUfreq;
+        }
+    }
+
+    public int saveKeyWakeupType(int saveKeyWakeupType) {
+        try {
+            saveKeyWakeupType = mService.saveKeyWakeupType(saveKeyWakeupType);
+            return saveKeyWakeupType;
+        }
+        catch (RemoteException ex) {
+            saveKeyWakeupType = -1;
+            return saveKeyWakeupType;
+        }
+    }
+
+    public int setAutoCabc(int setAutoCabc) {
+        try {
+            setAutoCabc = mService.setAutoCabc(setAutoCabc);
+            return setAutoCabc;
+        }
+        catch (RemoteException ex) {
+            setAutoCabc = -1;
+            return setAutoCabc;
+        }
+    }
+
+    public int set_hdmi_cable_status(int set_hdmi_cable_status) {
+        try {
+            set_hdmi_cable_status = mService.set_hdmi_cable_status(set_hdmi_cable_status);
+            return set_hdmi_cable_status;
+        }
+        catch (RemoteException ex) {
+            set_hdmi_cable_status = -1;
+            return set_hdmi_cable_status;
+        }
+    }
+
+    public int switchUsbFastCharger(int switchUsbFastCharger) {
+        try {
+            switchUsbFastCharger = mService.switchUsbFastCharger(switchUsbFastCharger);
+            return switchUsbFastCharger;
+        }
+        catch (RemoteException ex) {
+            switchUsbFastCharger = -1;
+            return switchUsbFastCharger;
+        }
+    }
+
+    public int updateLedBrightness(int updateLedBrightness) {
+        try {
+            updateLedBrightness = mService.updateLedBrightness(updateLedBrightness);
+            return updateLedBrightness;
+        }
+        catch (RemoteException ex) {
+            updateLedBrightness = -1;
+            return updateLedBrightness;
+        }
+    }
+
+    public int writeAccelerationSensorCalibValue(int[] array) {
+        try {
+            return mService.writeAccelerationSensorCalibValue(array);
+        }
+        catch (RemoteException ex) {
+            return -1;
+        }
+    }
+
+    public int writeCalibratorCmd(String s) {
+        try {
+            return mService.writeCalibratorCmd(s);
+        }
+        catch (RemoteException ex) {
+            return -1;
+        }
+    }
+
+    public int writeCfgParam(int writeCfgParam, int[] array) {
+        try {
+            writeCfgParam = mService.writeCfgParam(writeCfgParam, array);
+            return writeCfgParam;
+        }
+        catch (RemoteException ex) {
+            writeCfgParam = -1;
+            return writeCfgParam;
+        }
+    }
+
+    public int writeEarpodAdjustCmd(String s) {
+        try {
+            return mService.writeEarpodAdjustCmd(s);
+        }
+        catch (RemoteException ex) {
+            return -1;
+        }
+    }
+
+    public int writeGp2apValue(int writeGp2apValue) {
+        try {
+            writeGp2apValue = mService.writeGp2apValue(writeGp2apValue);
+            return writeGp2apValue;
+        }
+        catch (RemoteException ex) {
+            writeGp2apValue = -1;
+            return writeGp2apValue;
+        }
+    }
+}
diff --git a/core/java/meizu/os/IDeviceControlService.aidl b/core/java/meizu/os/IDeviceControlService.aidl
new file mode 100644
index 00000000..f1e1d806
--- /dev/null
+++ b/core/java/meizu/os/IDeviceControlService.aidl
@@ -0,0 +1,52 @@
+//
+// Reworked decompiled by Procyon v0.5.30
+//
+
+package meizu.os;
+
+interface IDeviceControlService
+{
+
+    int adjustGravitySensor(in int[] p0);
+    int calibrateGravitySensor();
+    int calibrateAcceAndGyroSensor();
+
+    int calibrateAccelerationSensor();
+
+    int calibrateGp2ap();
+    int readGp2apValue();
+    int writeGp2apValue(int p0);
+
+    int enableTouchAdjust();
+
+    int readAccelerationSensorCalibValue(out int[] p0);
+    int writeAccelerationSensorCalibValue(in int[] p0);
+
+    int readAutoCabc();
+    int setAutoCabc(int p0);
+
+    int readCPUfreq();
+    int saveCPUfreq(int p0);
+
+    int readCfgParam(int p0, out int[] p1);
+    int writeCfgParam(int p0, in int[] p1);
+
+    String readEarpodAdjustState();
+    int writeEarpodAdjustCmd(String p0);
+
+    int readGravityValue(out int[] p0);
+
+    int resetCalibration();
+
+    int saveKeyWakeupType(int p0);
+
+    int set_hdmi_cable_status(int p0);
+
+    int switchUsbFastCharger(int p0);
+
+    int updateLedBrightness(int p0);
+
+    int writeCalibratorCmd(String p0);
+
+}
+
diff --git a/core/jni/Android.mk b/core/jni/Android.mk
index b5747614..87f3b0e8 100644
--- a/core/jni/Android.mk
+++ b/core/jni/Android.mk
@@ -167,7 +167,8 @@ LOCAL_SRC_FILES:= \
 	com_android_internal_net_NetworkStatsFactory.cpp \
 	com_android_internal_os_Zygote.cpp \
 	com_android_internal_util_VirtualRefBasePtr.cpp \
-	com_android_internal_view_animation_NativeInterpolatorFactoryHelper.cpp
+	com_android_internal_view_animation_NativeInterpolatorFactoryHelper.cpp \
+	com_mediatek_perfservice_PerfServiceWrapper.cpp \
 
 LOCAL_C_INCLUDES += \
 	$(JNI_H_INCLUDE) \
diff --git a/core/jni/AndroidRuntime.cpp b/core/jni/AndroidRuntime.cpp
index 20817113..9dbb77af 100644
--- a/core/jni/AndroidRuntime.cpp
+++ b/core/jni/AndroidRuntime.cpp
@@ -188,6 +188,7 @@ extern int register_com_android_internal_content_NativeLibraryHelper(JNIEnv *env
 extern int register_com_android_internal_net_NetworkStatsFactory(JNIEnv *env);
 extern int register_com_android_internal_os_Zygote(JNIEnv *env);
 extern int register_com_android_internal_util_VirtualRefBasePtr(JNIEnv *env);
+extern int register_com_mediatek_perfservice_PerfServiceWrapper(JNIEnv* env);
 
 static AndroidRuntime* gCurRuntime = NULL;
 
@@ -1385,6 +1386,8 @@ static const RegJNIRec gRegJNI[] = {
     REG_JNI(register_android_animation_PropertyValuesHolder),
     REG_JNI(register_com_android_internal_content_NativeLibraryHelper),
     REG_JNI(register_com_android_internal_net_NetworkStatsFactory),
+
+    REG_JNI(register_com_mediatek_perfservice_PerfServiceWrapper),
 };
 
 /*
diff --git a/core/jni/android_media_AudioSystem.cpp b/core/jni/android_media_AudioSystem.cpp
index fee1ead3..5626a15b 100644
--- a/core/jni/android_media_AudioSystem.cpp
+++ b/core/jni/android_media_AudioSystem.cpp
@@ -1480,7 +1480,43 @@ exit:
     return jStatus;
 }
 
+static jint
+android_media_AudioSystem_setAudioData(JNIEnv *env, jobject clazz,
+                                       jint jA, jint jB, jbyteArray jArray)
+{
+    ALOGV("setAudioData");
+    if (jArray == NULL || env->GetArrayLength(jArray) == 0) {
+        ALOGE("setAudioData: emply buffer");
+        return (jint)AUDIO_JAVA_BAD_VALUE;
+    }
+
+    jbyte * buffer = env->GetByteArrayElements(jArray, NULL);
+
+    int status = AudioSystem::setAudioData((int)jA, (unsigned long)jB, (char*)buffer);
+
+    env->ReleaseByteArrayElements(jArray, buffer, 0);
+    ALOGV("setAudioData: status %d", status);
+    return (jint)status;
+}
 
+static jint
+android_media_AudioSystem_getAudioData(JNIEnv *env, jobject clazz,
+                                       jint jA, jint jB, jbyteArray jArray)
+{
+    ALOGV("getAudioData");
+    if (jArray == NULL || env->GetArrayLength(jArray) == 0) {
+        ALOGE("getAudioData: emply buffer");
+        return (jint)AUDIO_JAVA_BAD_VALUE;
+    }
+
+    jbyte * buffer = env->GetByteArrayElements(jArray, NULL);
+
+    int status = AudioSystem::getAudioData((int)jA, (unsigned long)jB, (char*)buffer);
+
+    env->ReleaseByteArrayElements(jArray, buffer, 0);
+    ALOGV("getAudioData: status %d", status);
+    return (jint)status;
+}
 
 // ----------------------------------------------------------------------------
 
@@ -1525,6 +1561,10 @@ static JNINativeMethod gMethods[] = {
                                     (void *)android_media_AudioSystem_getAudioHwSyncForSession},
     {"registerPolicyMixes",    "(Ljava/util/ArrayList;Z)I",
                                             (void *)android_media_AudioSystem_registerPolicyMixes},
+    {"getAudioData",    "(II[B)I",
+                        (void *)android_media_AudioSystem_getAudioData},
+    {"setAudioData",    "(II[B)I",
+                        (void *)android_media_AudioSystem_setAudioData},
 
 };
 
diff --git a/core/jni/com_mediatek_perfservice_PerfServiceWrapper.cpp b/core/jni/com_mediatek_perfservice_PerfServiceWrapper.cpp
new file mode 100644
index 00000000..7f51b0b8
--- /dev/null
+++ b/core/jni/com_mediatek_perfservice_PerfServiceWrapper.cpp
@@ -0,0 +1,56 @@
+/* //device/libs/android_runtime/com_mediatek_perfservice_PerfServiceWrapper.cpp
+**
+** Copyright 2006, The Android Open Source Project
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**     http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+*/
+
+#define LOG_TAG "PerfServiceWrapper"
+
+#include "JNIHelp.h"
+#include "jni.h"
+#include <utils/Log.h>
+#include <utils/misc.h>
+#include <utils/String8.h>
+#include <fcntl.h>
+
+
+namespace android {
+
+static jint com_mediatek_perfservice_PerfServiceWrapper_get_pid(JNIEnv*, jobject obj)
+{
+    return (jint)getpid();
+}
+
+static jint com_mediatek_perfservice_PerfServiceWrapper_get_tid(JNIEnv*, jobject obj)
+{
+    return (jint)gettid();
+}
+
+static JNINativeMethod sMethods[] = {
+     /* name, signature, funcPtr */
+    {"nativeGetPid", "()I", (void*)com_mediatek_perfservice_PerfServiceWrapper_get_pid},
+    {"nativeGetTid", "()I", (void*)com_mediatek_perfservice_PerfServiceWrapper_get_tid},
+};
+
+int register_com_mediatek_perfservice_PerfServiceWrapper(JNIEnv* env)
+{
+    int res;
+    ALOGE("Registering native methods\n");
+    res = jniRegisterNativeMethods(env, "com/mediatek/perfservice/PerfServiceWrapper",
+                                    sMethods, NELEM(sMethods));
+    ALOGE("Registering native methods result %d\n", res);
+    return res;
+}
+
+} /* namespace android */
diff --git a/core/res/res/values-mcc310-mnc170 b/core/res/res/values-mcc310-mnc170
deleted file mode 120000
index cfced175..00000000
--- a/core/res/res/values-mcc310-mnc170
+++ /dev/null
@@ -1 +0,0 @@
-./values-mcc310-mnc150
\ No newline at end of file
diff --git a/core/res/res/values-mcc310-mnc170 b/core/res/res/values-mcc310-mnc170
new file mode 100755
index 00000000..cfced175
--- /dev/null
+++ b/core/res/res/values-mcc310-mnc170
@@ -0,0 +1 @@
+./values-mcc310-mnc150
\ No newline at end of file
diff --git a/core/res/res/values-mcc310-mnc380 b/core/res/res/values-mcc310-mnc380
deleted file mode 120000
index cfced175..00000000
--- a/core/res/res/values-mcc310-mnc380
+++ /dev/null
@@ -1 +0,0 @@
-./values-mcc310-mnc150
\ No newline at end of file
diff --git a/core/res/res/values-mcc310-mnc380 b/core/res/res/values-mcc310-mnc380
new file mode 100755
index 00000000..cfced175
--- /dev/null
+++ b/core/res/res/values-mcc310-mnc380
@@ -0,0 +1 @@
+./values-mcc310-mnc150
\ No newline at end of file
diff --git a/core/res/res/values/attrs.xml b/core/res/res/values/attrs.xml
index 9e9618c3..71026176 100644
--- a/core/res/res/values/attrs.xml
+++ b/core/res/res/values/attrs.xml
@@ -1774,6 +1774,17 @@
         <enum name="KEYCODE_TV_MEDIA_CONTEXT_MENU" value="257" />
         <enum name="KEYCODE_TV_TIMER_PROGRAMMING" value="258" />
         <enum name="KEYCODE_HELP" value="259" />
+        <!-- MTK/Meizu key codes -->
+        <enum name="KEYCODE_WIFI_TOGGLE" value="260" />
+        <enum name="KEYCODE_BT_TOGGLE" value="261" />
+        <enum name="KEYCODE_LOCK_TOGGLE" value="262" />
+        <enum name="KEYCODE_IME_TOGGLE" value="263" />
+        <enum name="KEYCODE_MESSAGING" value="264" />
+        <enum name="KEYCODE_GALLERY" value="265" />
+        <enum name="KEYCODE_GESTURE" value="266" />
+        <enum name="KEYCODE_SLIDE" value="267" />
+        <enum name="KEYCODE_UNLOCK" value="268" />
+        <enum name="KEYCODE_FINGERPRINT" value="269" />
     </attr>
 
     <!-- ***************************************************************** -->
diff --git a/core/res/res/values/cm_symbols.xml b/core/res/res/values/cm_symbols.xml
index 8fd4d6f1..57ff0907 100644
--- a/core/res/res/values/cm_symbols.xml
+++ b/core/res/res/values/cm_symbols.xml
@@ -84,6 +84,9 @@
     <java-symbol type="integer" name="config_buttonBrightnessSettingDefault" />
     <java-symbol type="integer" name="config_keyboardBrightnessSettingDefault" />
 
+    <java-symbol type="bool" name="config_buttonBrightnessForceConfigurable" />
+    <java-symbol type="integer" name="config_buttonBrightnessOverriddenEnabledValue" />
+
     <java-symbol type="string" name="config_geofenceServicesProvider" />
     <java-symbol type="string" name="config_comboNetworkLocationProvider" />
     <java-symbol type="string" name="tethered_notification_no_device_message" />
diff --git a/core/res/res/values/config.xml b/core/res/res/values/config.xml
index 31ad7aa9..6ec1c9e1 100755
--- a/core/res/res/values/config.xml
+++ b/core/res/res/values/config.xml
@@ -1062,6 +1062,14 @@
     <integer name="config_keyboardBrightnessSettingDefault">0</integer>
     <bool name="config_deviceHasVariableButtonBrightness">false</bool>
 
+    <!-- True if button brightness should be configurable even if default
+         value is set to 0 -->
+    <bool name="config_buttonBrightnessForceConfigurable">false</bool>
+
+    <!-- Overridden brightness value of enabled state if button brightness is
+         forced to be configurable -->
+    <integer name="config_buttonBrightnessOverriddenEnabledValue">255</integer>
+
     <!-- Amount of time it takes for the light sensor to warm up in milliseconds.
          For this time after the screen turns on, the Power Manager
          will not debounce light sensor readings -->
@@ -2181,6 +2189,7 @@
         <item>CHINA\u0020\u0020MOBILE</item>
         <item>CMCC</item>
         <item>CHN-UNICOM</item>
+        <item>UNICOM</item>
         <item>China Mobile</item>
         <item>China Unicom</item>
         <item>China Telecom</item>
@@ -2197,6 +2206,7 @@
         <item>China_Mobile</item>
         <item>China_Mobile</item>
         <item>China_Unicom</item>
+        <item>China_Unicom</item>
         <item>China_Mobile</item>
         <item>China_Unicom</item>
         <item>China_Telecom</item>
diff --git a/core/res/res/values/flyme_strings.xml b/core/res/res/values/flyme_strings.xml
new file mode 100644
index 00000000..60482258
--- /dev/null
+++ b/core/res/res/values/flyme_strings.xml
@@ -0,0 +1,25 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+     Copyright (C) 2015 The CyanogenMod Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+
+    <private-symbols package="com.android.internal" />
+    <string name="gesture_control_path_string">/sys/devices/mx_tsp/gesture_control</string>
+    <java-symbol type="string" name="gesture_control_path_string" />
+    <string name="gesture_data_path_string">/sys/devices/mx_tsp/gesture_data</string>
+    <java-symbol type="string" name="gesture_data_path_string" />
+
+</resources>
diff --git a/libs/hwui/Android.mk b/libs/hwui/Android.mk
index 49560ffd..0dbdd619 100644
--- a/libs/hwui/Android.mk
+++ b/libs/hwui/Android.mk
@@ -78,7 +78,7 @@ ifeq ($(USE_OPENGL_RENDERER),true)
 	LOCAL_CFLAGS += -DUSE_OPENGL_RENDERER -DEGL_EGLEXT_PROTOTYPES -DGL_GLEXT_PROTOTYPES
 	LOCAL_CFLAGS += -Wno-unused-parameter
 	LOCAL_MODULE_CLASS := SHARED_LIBRARIES
-	LOCAL_SHARED_LIBRARIES := liblog libcutils libutils libEGL libGLESv2 libskia libui libgui
+	LOCAL_SHARED_LIBRARIES := liblog libcutils libutils libEGL libGLESv2 libskia libui libgui libdl
 	LOCAL_MODULE := libhwui
 	LOCAL_MODULE_TAGS := optional
 
diff --git a/libs/hwui/renderthread/CanvasContext.cpp b/libs/hwui/renderthread/CanvasContext.cpp
index 75bd0676..a1449de7 100644
--- a/libs/hwui/renderthread/CanvasContext.cpp
+++ b/libs/hwui/renderthread/CanvasContext.cpp
@@ -19,6 +19,7 @@
 #include <algorithm>
 #include <private/hwui/DrawGlInfo.h>
 #include <strings.h>
+#include <dlfcn.h>
 
 #include "EglManager.h"
 #include "RenderThread.h"
@@ -37,6 +38,10 @@ namespace android {
 namespace uirenderer {
 namespace renderthread {
 
+typedef int (*PerfServiceFrameUpdatePtr)(int);
+
+static PerfServiceFrameUpdatePtr gPerfServiceFrameUpdatePtr = NULL;
+
 CanvasContext::CanvasContext(RenderThread& thread, bool translucent,
         RenderNode* rootRenderNode, IContextFactory* contextFactory)
         : mRenderThread(thread)
@@ -50,6 +55,20 @@ CanvasContext::CanvasContext(RenderThread& thread, bool translucent,
         , mRootRenderNode(rootRenderNode) {
     mAnimationContext = contextFactory->createAnimationContext(mRenderThread.timeLord());
     mRenderThread.renderState().registerCanvasContext(this);
+    if (gPerfServiceFrameUpdatePtr == NULL) {
+        ALOGE("Opening libperfservicenative.so");
+        void * perfServiceLib = dlopen("libperfservicenative.so", RTLD_NOW);
+        if (perfServiceLib == NULL) {
+            ALOGE("Cannot open libperfservicenative.so");
+        } else {
+            gPerfServiceFrameUpdatePtr = (PerfServiceFrameUpdatePtr)
+                dlsym(perfServiceLib, "PerfServiceNative_notifyFrameUpdate");
+            if (gPerfServiceFrameUpdatePtr == NULL) {
+                ALOGE("Cannot get PerfServiceNative_notifyFrameUpdate ptr");
+                dlclose(perfServiceLib);
+            }
+        }
+    }
 }
 
 CanvasContext::~CanvasContext() {
@@ -203,6 +222,9 @@ void CanvasContext::draw() {
     LOG_ALWAYS_FATAL_IF(!mCanvas || mEglSurface == EGL_NO_SURFACE,
             "drawRenderNode called on a context with no canvas or surface!");
 
+    if (gPerfServiceFrameUpdatePtr != NULL) {
+        (void)gPerfServiceFrameUpdatePtr(0);
+    }
     profiler().markPlaybackStart();
 
     SkRect dirty;
diff --git a/location/java/android/location/GpsStatus.java b/location/java/android/location/GpsStatus.java
index 4af55a65..a6474888 100644
--- a/location/java/android/location/GpsStatus.java
+++ b/location/java/android/location/GpsStatus.java
@@ -164,6 +164,42 @@ public final class GpsStatus {
         }
     }
 
+    /**
+     * Used internally within {@link LocationManager} to copy GPS status
+     * data from the Location Manager Service to its cached GpsStatus instance.
+     * Is synchronized to ensure that GPS status updates are atomic.
+     *
+     * This is modified to become aware of explicit GNSS support of &gt;32
+     * satellites.
+     */
+    synchronized void setStatusFromGnss(int gnssSvCount, int[] prns, float[] snrs,
+            float[] elevations, float[] azimuths,
+            boolean[] ephemerisPresences,
+            boolean[] almanacPresences,
+            boolean[] usedInFix) {
+        int i;
+
+        for (i = 0; i < mSatellites.length; i++) {
+            mSatellites[i].mValid = false;
+        }
+
+        for (i = 0; i < gnssSvCount; i++) {
+            int prn = prns[i] - 1;
+
+            if (prn >= 0 && prn < mSatellites.length) {
+                GpsSatellite satellite = mSatellites[prn];
+
+                satellite.mValid = true;
+                satellite.mSnr = snrs[i];
+                satellite.mElevation = elevations[i];
+                satellite.mAzimuth = azimuths[i];
+                satellite.mHasEphemeris = ephemerisPresences[i];
+                satellite.mHasAlmanac = almanacPresences[i];
+                satellite.mUsedInFix = usedInFix[i];
+            }
+        }
+    }
+
     /**
      * Used by {@link LocationManager#getGpsStatus} to copy LocationManager's
      * cached GpsStatus instance to the client's copy.
diff --git a/location/java/android/location/IGpsStatusListener.aidl b/location/java/android/location/IGpsStatusListener.aidl
index 62b1c6b9..52865b71 100644
--- a/location/java/android/location/IGpsStatusListener.aidl
+++ b/location/java/android/location/IGpsStatusListener.aidl
@@ -29,5 +29,10 @@ oneway interface IGpsStatusListener
     void onSvStatusChanged(int svCount, in int[] prns, in float[] snrs, 
             in float[] elevations, in float[] azimuths, 
             int ephemerisMask, int almanacMask, int usedInFixMask);
+    void onGnssSvStatusChanged(int gnssSvCount, in int[] prns, in float[] snrs,
+            in float[] elevations, in float[] azimuths,
+            in boolean[] ephemerisPresences,
+            in boolean[] almanacPresences,
+            in boolean[] usedInFix);
     void onNmeaReceived(long timestamp, String nmea);
 }
diff --git a/location/java/android/location/LocationManager.java b/location/java/android/location/LocationManager.java
index 0eb4fdc6..b4682e76 100644
--- a/location/java/android/location/LocationManager.java
+++ b/location/java/android/location/LocationManager.java
@@ -1447,6 +1447,31 @@ public class LocationManager {
             }
         }
 
+        @Override
+        public void onGnssSvStatusChanged(int gnssSvCount, int[] prns, float[] snrs,
+                float[] elevations, float[] azimuths,
+                boolean[] ephemerisPresences,
+                boolean[] almanacPresences,
+                boolean[] usedInFix) {
+            if (mListener != null) {
+                mGpsStatus.setStatusFromGnss(
+                        gnssSvCount,
+                        prns,
+                        snrs,
+                        elevations,
+                        azimuths,
+                        ephemerisPresences,
+                        almanacPresences,
+                        usedInFix);
+
+                Message msg = Message.obtain();
+                msg.what = GpsStatus.GPS_EVENT_SATELLITE_STATUS;
+                // remove any SV status messages already in the queue
+                mGpsHandler.removeMessages(GpsStatus.GPS_EVENT_SATELLITE_STATUS);
+                mGpsHandler.sendMessage(msg);
+            }
+        }
+
         @Override
         public void onNmeaReceived(long timestamp, String nmea) {
             if (mNmeaListener != null) {
diff --git a/media/java/android/media/AudioSystem.java b/media/java/android/media/AudioSystem.java
index bf79e9a7..50b94ae5 100644
--- a/media/java/android/media/AudioSystem.java
+++ b/media/java/android/media/AudioSystem.java
@@ -604,5 +604,8 @@ public class AudioSystem
     public static native int getAudioHwSyncForSession(int sessionId);
 
     public static native int registerPolicyMixes(ArrayList<AudioMix> mixes, boolean register);
+
+    public static native int getAudioData(int par, int size, byte[] data);
+    public static native int setAudioData(int par, int size, byte[] data);
 }
 
diff --git a/media/java/android/media/CamcorderProfile.java b/media/java/android/media/CamcorderProfile.java
index 5a1186ca..924407b9 100644
--- a/media/java/android/media/CamcorderProfile.java
+++ b/media/java/android/media/CamcorderProfile.java
@@ -18,6 +18,7 @@ package android.media;
 
 import android.hardware.Camera;
 import android.hardware.Camera.CameraInfo;
+import android.util.Log;
 
 /**
  * Retrieves the
@@ -125,9 +126,16 @@ public class CamcorderProfile
      */
     public static final int QUALITY_HVGA = 19;
 
+    public static final int QUALITY_MEIZU_DUMMY_1 = 20;
+    public static final int QUALITY_MEIZU_DUMMY_2 = 21;
+    public static final int QUALITY_MEIZU_DUMMY_3 = 22;
+    public static final int QUALITY_MEIZU_DUMMY_4 = 23;
+    public static final int QUALITY_MEIZU_VGA = 24;
+
+
     // Start and end of quality list
     private static final int QUALITY_LIST_START = QUALITY_LOW;
-    private static final int QUALITY_LIST_END = QUALITY_HVGA;
+    private static final int QUALITY_LIST_END = QUALITY_MEIZU_VGA;
 
     /**
      * Time lapse quality level corresponding to the lowest available resolution.
@@ -242,6 +250,7 @@ public class CamcorderProfile
     private static final int QUALITY_HIGH_SPEED_LIST_START = QUALITY_HIGH_SPEED_LOW;
     private static final int QUALITY_HIGH_SPEED_LIST_END = QUALITY_HIGH_SPEED_2160P;
 
+    public static final int QUALITY_SLOW_MOTION_VGA = 2231;
     /**
      * Default recording duration in seconds before the session is terminated.
      * This is useful for applications like MMS has limited file size requirement.
@@ -382,7 +391,8 @@ public class CamcorderProfile
               (quality >= QUALITY_TIME_LAPSE_LIST_START &&
                quality <= QUALITY_TIME_LAPSE_LIST_END) ||
                (quality >= QUALITY_HIGH_SPEED_LIST_START &&
-               quality <= QUALITY_HIGH_SPEED_LIST_END))) {
+               quality <= QUALITY_HIGH_SPEED_LIST_END) ||
+               (quality == QUALITY_SLOW_MOTION_VGA))) {
             String errMessage = "Unsupported quality level: " + quality;
             throw new IllegalArgumentException(errMessage);
         }
diff --git a/media/jni/android_media_MediaProfiles.cpp b/media/jni/android_media_MediaProfiles.cpp
index 2f404f1c..a2ee1c1c 100644
--- a/media/jni/android_media_MediaProfiles.cpp
+++ b/media/jni/android_media_MediaProfiles.cpp
@@ -175,7 +175,8 @@ static bool isCamcorderQualityKnown(int quality)
             (quality >= CAMCORDER_QUALITY_TIME_LAPSE_LIST_START &&
              quality <= CAMCORDER_QUALITY_TIME_LAPSE_LIST_END) ||
              (quality >= CAMCORDER_QUALITY_HIGH_SPEED_LIST_START &&
-              quality <= CAMCORDER_QUALITY_HIGH_SPEED_LIST_END));
+              quality <= CAMCORDER_QUALITY_HIGH_SPEED_LIST_END) ||
+             (quality == CAMCORDER_QUALITY_SLOW_MOTION_VGA));
 }
 
 static jobject
diff --git a/opengl/java/android/opengl/GLSurfaceView.java b/opengl/java/android/opengl/GLSurfaceView.java
index 3c76115c..25511e33 100644
--- a/opengl/java/android/opengl/GLSurfaceView.java
+++ b/opengl/java/android/opengl/GLSurfaceView.java
@@ -31,12 +31,16 @@ import javax.microedition.khronos.opengles.GL10;
 
 import android.content.Context;
 import android.content.pm.ConfigurationInfo;
+import android.os.RemoteException;
+import android.os.ServiceManager;
 import android.os.SystemProperties;
 import android.util.AttributeSet;
 import android.util.Log;
 import android.view.SurfaceHolder;
 import android.view.SurfaceView;
 
+import com.mediatek.perfservice.IPerfService;
+
 /**
  * An implementation of SurfaceView that uses the dedicated surface for
  * displaying OpenGL rendering.
@@ -1226,6 +1230,10 @@ public class GLSurfaceView extends SurfaceView implements SurfaceHolder.Callback
             mRequestRender = true;
             mRenderMode = RENDERMODE_CONTINUOUSLY;
             mGLSurfaceViewWeakRef = glSurfaceViewWeakRef;
+            mPerfService = IPerfService.Stub.asInterface(ServiceManager.getService("mtk-perfservice"));
+            if (mPerfService == null) {
+                Log.i("GLThread", "mPerfService is null!");
+            }
         }
 
         @Override
@@ -1519,6 +1527,13 @@ public class GLSurfaceView extends SurfaceView implements SurfaceHolder.Callback
                     {
                         GLSurfaceView view = mGLSurfaceViewWeakRef.get();
                         if (view != null) {
+                            if (mPerfService != null) {
+                                try {
+                                    mPerfService.notifyFrameUpdate(0);
+                                } catch (RemoteException e) {
+                                    Log.e("GLThread", "Remote exception in notifyFrameUpdate:", e);
+                                }
+                            }
                             view.mRenderer.onDrawFrame(gl);
                         }
                     }
@@ -1758,6 +1773,9 @@ public class GLSurfaceView extends SurfaceView implements SurfaceHolder.Callback
 
         private EglHelper mEglHelper;
 
+        // MTK
+        private IPerfService mPerfService;
+
         /**
          * Set once at thread construction time, nulled out when the parent view is garbage
          * called. This weak reference allows the GLSurfaceView to be garbage collected while
diff --git a/packages/SystemUI/tests/src/com/android/systemui/EventLogTags.logtags b/packages/SystemUI/tests/src/com/android/systemui/EventLogTags.logtags
deleted file mode 120000
index 2f243d70..00000000
--- a/packages/SystemUI/tests/src/com/android/systemui/EventLogTags.logtags
+++ /dev/null
@@ -1 +0,0 @@
-../../../../../src/com/android/systemui/EventLogTags.logtags
\ No newline at end of file
diff --git a/packages/SystemUI/tests/src/com/android/systemui/EventLogTags.logtags b/packages/SystemUI/tests/src/com/android/systemui/EventLogTags.logtags
new file mode 100755
index 00000000..2f243d70
--- /dev/null
+++ b/packages/SystemUI/tests/src/com/android/systemui/EventLogTags.logtags
@@ -0,0 +1 @@
+../../../../../src/com/android/systemui/EventLogTags.logtags
\ No newline at end of file
diff --git a/policy/src/com/android/internal/policy/impl/PhoneWindowManager.java b/policy/src/com/android/internal/policy/impl/PhoneWindowManager.java
index 1ef905fb..fd504b9b 100644
--- a/policy/src/com/android/internal/policy/impl/PhoneWindowManager.java
+++ b/policy/src/com/android/internal/policy/impl/PhoneWindowManager.java
@@ -42,6 +42,7 @@ import android.content.res.TypedArray;
 import android.database.ContentObserver;
 import android.graphics.PixelFormat;
 import android.graphics.Rect;
+import android.hardware.SensorManager;
 import android.hardware.input.InputManager;
 import android.media.AudioAttributes;
 import android.media.AudioManager;
@@ -86,6 +87,7 @@ import android.view.Display;
 import android.view.Gravity;
 import android.view.HapticFeedbackConstants;
 import android.view.IApplicationToken;
+import android.view.IGestureManager;
 import android.view.IWindowManager;
 import android.view.InputChannel;
 import android.view.InputDevice;
@@ -916,7 +918,7 @@ public class PhoneWindowManager implements WindowManagerPolicy {
 
     class MyOrientationListener extends WindowOrientationListener {
         MyOrientationListener(Context context, Handler handler) {
-            super(context, handler);
+            super(context, handler, SensorManager.SENSOR_DELAY_NORMAL);
         }
 
         @Override
@@ -5718,6 +5720,14 @@ public class PhoneWindowManager implements WindowManagerPolicy {
                     msg.sendToTarget();
                 }
             }
+            // START Meizu
+            case KeyEvent.KEYCODE_GESTURE: {
+                if (wakeUpSystemByGestureIfNeeded(this, keyCode, down, this.isScreenOn())) {
+                    isWakeKey = true;
+                    result &= ~ACTION_PASS_TO_USER;
+                }
+            }
+            // END Meizu
         }
 
         if (useHapticFeedback) {
@@ -7545,4 +7555,19 @@ public class PhoneWindowManager implements WindowManagerPolicy {
 
         return false;
     }
+
+    // Meizu
+    private static boolean wakeUpSystemByGestureIfNeeded(PhoneWindowManager windowManager, int key, boolean down, boolean screenOn) {
+        if (key != KeyEvent.KEYCODE_GESTURE || screenOn || !down) {
+            return false;
+        }
+        Log.e("GestureManager", "IGestureManager handling gesture keycode");
+        IGestureManager interface1 = IGestureManager.Stub.asInterface(ServiceManager.getService("gesture_manager"));
+        try {
+            return interface1.triggerGesture();
+        } catch (RemoteException ex) {
+            Log.e("GestureManager", "IGestureManager threw RemoteException", ex);
+        }
+        return false;
+    }
 }
diff --git a/policy/src/com/android/internal/policy/impl/WindowOrientationListener.java b/policy/src/com/android/internal/policy/impl/WindowOrientationListener.java
index 32772fdf..a112ea94 100644
--- a/policy/src/com/android/internal/policy/impl/WindowOrientationListener.java
+++ b/policy/src/com/android/internal/policy/impl/WindowOrientationListener.java
@@ -80,10 +80,8 @@ public abstract class WindowOrientationListener {
      * {@link android.hardware.SensorManager SensorManager}). Use the default
      * value of {@link android.hardware.SensorManager#SENSOR_DELAY_NORMAL 
      * SENSOR_DELAY_NORMAL} for simple screen orientation change detection.
-     *
-     * This constructor is private since no one uses it.
      */
-    private WindowOrientationListener(Context context, Handler handler, int rate) {
+    protected WindowOrientationListener(Context context, Handler handler, int rate) {
         mHandler = handler;
         mSensorManager = (SensorManager)context.getSystemService(Context.SENSOR_SERVICE);
         mRate = rate;
diff --git a/services/core/java/com/android/server/DeviceControlService.java b/services/core/java/com/android/server/DeviceControlService.java
new file mode 100644
index 00000000..3f86b81e
--- /dev/null
+++ b/services/core/java/com/android/server/DeviceControlService.java
@@ -0,0 +1,751 @@
+//
+// Reworked decompiled by Procyon v0.5.30
+//
+
+package com.android.server;
+
+import android.util.Slog;
+import java.util.Iterator;
+import java.io.File;
+import android.util.Log;
+import android.hardware.SensorEvent;
+import android.hardware.SensorManager;
+import android.os.SystemProperties;
+
+import java.util.ArrayList;
+import android.content.Context;
+import android.hardware.SensorEventListener;
+import android.hardware.Sensor;
+//import android.annotation.FlymeHook$FlymeRomType;
+//import android.annotation.FlymeHook$FlymeHookType;
+//import android.annotation.FlymeHook;
+import meizu.os.IDeviceControlService;
+
+//@FlymeHook(level = FlymeHook$FlymeHookType.NEW_CLASS, note = "Porting DeviceControlService interface", property = FlymeHook$FlymeRomType.MTK)
+public class DeviceControlService extends IDeviceControlService.Stub
+{
+    private static final String ACCELERATION_FILE_PATH = "/data/inv_cal_data.bin";
+    private static boolean DEBUG = true;
+    public static final int DEVCFG_IR_CALIBRATE = 0;
+    public static final int DEVCFG_TOUCH_SCREEN = 1;
+    public static final int DEVCFG_BUTTON_LIGHT = 2;
+    public static final int DEVCFG_LIGHT_SENSOR = 3;
+    public static final int DEVCFG_GRAVITY_SENSOR = 4;
+    public static final int DEVCFG_ACTIVATE_STATS = 5;
+    public static final int DEVCFG_MAINTAIN_STATE = 6;
+    public static final int DEVCFG_MAX_INT_FIELDS = 7;
+    public static final int DEVCFG_SHOPDEMO_TOOL = 8;
+    public static final int DEVCFG_ACCELERATION_SENSOR = 9;
+    public static final int DEVCFG_GYROSCOPE_SENSOR = 10;
+    public static final String EARPOD_ADJUST_CMD_UP_KEY_CALIBRATE = "up_key_calibrate";
+    public static final String EARPOD_ADJUST_STATE_COMPLETE = "COMPLETE";
+    public static final String EARPOD_ADJUST_STATE_ERROR = "ERROR";
+    public static final String EARPOD_ADJUST_STATE_PENDING = "PENDING";
+    private static final long CALIBRATE_TIME_OUT = 6000L;
+    private static final long REGISTER_LISTENER_TIME_OUT = 1000L;
+    private static final long SAMPLE_TIME_OUT = 60L;
+    private static final int SAMPLE_COUNT = 50;
+    private static String TAG = "DeviceControlService";
+    private static final float X_MAX_VALUE = 0.1f;
+    private static final float Y_MAX_VALUE = 0.1f;
+    private static final float Z_MAX_VALUE = 10.0f;
+    private static final float Z_MIN_VALUE = 9.6f;
+    private Sensor mAccelerometer;
+    private final SensorEventListener mAccelerometerListener;
+    private boolean mAccelerometerSensorEnabled;
+    public Context mContext;
+    private ArrayList<Sample> mSamples;
+    private SensorManager mSensorManager;
+    private int[] mValues;
+    private float mXValue;
+    private float mYValue;
+    private float mZValue;
+
+    public DeviceControlService() {
+        mAccelerometerSensorEnabled = false;
+        mValues = new int[] { 0, 0, 0 };
+        mSamples = new ArrayList<Sample>();
+        mAccelerometerListener = new SensorEventListener() {
+            public void onAccuracyChanged(Sensor sensor, int n) {
+            }
+
+            public void onSensorChanged(SensorEvent sensorEvent) {
+                if (mAccelerometerSensorEnabled) {
+                    mXValue = sensorEvent.values[0];
+                    mYValue = sensorEvent.values[1];
+                    mZValue = sensorEvent.values[2];
+                }
+            }
+        };
+    }
+
+    public DeviceControlService(Context context) {
+        mAccelerometerSensorEnabled = false;
+        mValues = new int[] { 0, 0, 0 };
+        mSamples = new ArrayList<Sample>();
+        mAccelerometerListener = new SensorEventListener() {
+            public void onAccuracyChanged(Sensor sensor, int n) {
+            }
+
+            public void onSensorChanged(SensorEvent sensorEvent) {
+                if (mAccelerometerSensorEnabled) {
+                    mXValue = sensorEvent.values[0];
+                    mYValue = sensorEvent.values[1];
+                    mZValue = sensorEvent.values[2];
+                }
+            }
+        };
+        mContext = context;
+        mSensorManager = (SensorManager)mContext.getSystemService("sensor");
+        mAccelerometer = mSensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER);
+    }
+
+    private int calibrateAccelerationAndGyroscopeSensor(final int p0) {
+        // 
+        // This method could not be decompiled.
+        // 
+        // Original Bytecode:
+        // 
+        //     0: iconst_m1      
+        //     1: istore_3       
+        //     2: aload_0        
+        //     3: ldc             "/sys/devices/14e30000.i2c/i2c-66/66-003a/input/input0/calibrator_cmd"
+        //     5: new             Ljava/lang/StringBuilder;
+        //     8: dup            
+        //     9: invokespecial   java/lang/StringBuilder.<init>:()V
+        //    12: ldc             "7 1 "
+        //    14: invokevirtual   java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
+        //    17: iload_1        
+        //    18: invokevirtual   java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder;
+        //    21: invokevirtual   java/lang/StringBuilder.toString:()Ljava/lang/String;
+        //    24: invokespecial   com/android/server/DeviceControlService.writeCalibrationData:(Ljava/lang/String;Ljava/lang/String;)I
+        //    27: pop            
+        //    28: ldc2_w          2500
+        //    31: invokestatic    java/lang/Thread.sleep:(J)V
+        //    34: aconst_null    
+        //    35: astore          4
+        //    37: iconst_0       
+        //    38: istore_2       
+        //    39: iload_2        
+        //    40: bipush          8
+        //    42: if_icmpge       129
+        //    45: aload_0        
+        //    46: ldc             "/sys/devices/14e30000.i2c/i2c-66/66-003a/input/input0/calibrator_cmd"
+        //    48: ldc             "6 0 0"
+        //    50: invokespecial   com/android/server/DeviceControlService.writeCalibrationData:(Ljava/lang/String;Ljava/lang/String;)I
+        //    53: pop            
+        //    54: ldc2_w          100
+        //    57: invokestatic    java/lang/Thread.sleep:(J)V
+        //    60: aload_0        
+        //    61: ldc             "/sys/devices/14e30000.i2c/i2c-66/66-003a/input/input0/calibrator_cmd"
+        //    63: invokespecial   com/android/server/DeviceControlService.readCalibrationData:(Ljava/lang/String;)Ljava/lang/String;
+        //    66: astore          4
+        //    68: getstatic       com/android/server/TAG:Ljava/lang/String;
+        //    71: new             Ljava/lang/StringBuilder;
+        //    74: dup            
+        //    75: invokespecial   java/lang/StringBuilder.<init>:()V
+        //    78: ldc             "Sensor test "
+        //    80: invokevirtual   java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
+        //    83: iload_2        
+        //    84: invokevirtual   java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder;
+        //    87: ldc             " times: "
+        //    89: invokevirtual   java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
+        //    92: aload           4
+        //    94: invokevirtual   java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
+        //    97: invokevirtual   java/lang/StringBuilder.toString:()Ljava/lang/String;
+        //   100: invokestatic    android/util/Log.i:(Ljava/lang/String;Ljava/lang/String;)I
+        //   103: pop            
+        //   104: aload           4
+        //   106: ifnull          148
+        //   109: aload           4
+        //   111: ldc             "0"
+        //   113: invokevirtual   java/lang/String.equals:(Ljava/lang/Object;)Z
+        //   116: ifne            148
+        //   119: aload           4
+        //   121: ldc             "1"
+        //   123: invokevirtual   java/lang/String.equals:(Ljava/lang/Object;)Z
+        //   126: ifne            148
+        //   129: aload           4
+        //   131: ifnull          160
+        //   134: aload           4
+        //   136: ldc             "2"
+        //   138: invokevirtual   java/lang/String.equals:(Ljava/lang/Object;)Z
+        //   141: ifne            160
+        //   144: iload_3        
+        //   145: istore_2       
+        //   146: iload_2        
+        //   147: ireturn        
+        //   148: ldc2_w          400
+        //   151: invokestatic    java/lang/Thread.sleep:(J)V
+        //   154: iinc            2, 1
+        //   157: goto            39
+        //   160: aload_0        
+        //   161: ldc             "/sys/devices/14e30000.i2c/i2c-66/66-003a/input/input0/calibrator_cmd"
+        //   163: new             Ljava/lang/StringBuilder;
+        //   166: dup            
+        //   167: invokespecial   java/lang/StringBuilder.<init>:()V
+        //   170: iload_1        
+        //   171: invokevirtual   java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder;
+        //   174: ldc             " 1 1"
+        //   176: invokevirtual   java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
+        //   179: invokevirtual   java/lang/StringBuilder.toString:()Ljava/lang/String;
+        //   182: invokespecial   com/android/server/DeviceControlService.writeCalibrationData:(Ljava/lang/String;Ljava/lang/String;)I
+        //   185: pop            
+        //   186: aload_0        
+        //   187: ldc             "/sys/devices/14e30000.i2c/i2c-66/66-003a/input/input0/calibrator_cmd"
+        //   189: invokespecial   com/android/server/DeviceControlService.readCalibrationData:(Ljava/lang/String;)Ljava/lang/String;
+        //   192: astore          4
+        //   194: iload_3        
+        //   195: istore_2       
+        //   196: aload_0        
+        //   197: aload           4
+        //   199: iload_1        
+        //   200: invokespecial   com/android/server/DeviceControlService.writeSensorCalibVals:(Ljava/lang/String;I)I
+        //   203: iflt            146
+        //   206: getstatic       com/android/server/TAG:Ljava/lang/String;
+        //   209: new             Ljava/lang/StringBuilder;
+        //   212: dup            
+        //   213: invokespecial   java/lang/StringBuilder.<init>:()V
+        //   216: ldc             "Calibration return is: "
+        //   218: invokevirtual   java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
+        //   221: aload           4
+        //   223: invokevirtual   java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
+        //   226: invokevirtual   java/lang/StringBuilder.toString:()Ljava/lang/String;
+        //   229: invokestatic    android/util/Log.i:(Ljava/lang/String;Ljava/lang/String;)I
+        //   232: pop            
+        //   233: aload_0        
+        //   234: ldc             "/sys/devices/14e30000.i2c/i2c-66/66-003a/input/input0/calibrator_cmd"
+        //   236: aload           4
+        //   238: invokespecial   com/android/server/DeviceControlService.writeCalibrationData:(Ljava/lang/String;Ljava/lang/String;)I
+        //   241: pop            
+        //   242: iconst_0       
+        //   243: istore_2       
+        //   244: goto            146
+        //   247: astore          4
+        //   249: goto            34
+        //   252: astore          4
+        //   254: goto            60
+        //   257: astore          5
+        //   259: goto            154
+        //    Exceptions:
+        //  Try           Handler
+        //  Start  End    Start  End    Type                 
+        //  -----  -----  -----  -----  ---------------------
+        //  28     34     247    252    Ljava/lang/Exception;
+        //  54     60     252    257    Ljava/lang/Exception;
+        //  148    154    257    262    Ljava/lang/Exception;
+        // 
+        // The error that occurred was:
+        // 
+        // java.lang.IndexOutOfBoundsException: Index: 121, Size: 121
+        //     at java.util.ArrayList.rangeCheck(ArrayList.java:638)
+        //     at java.util.ArrayList.get(ArrayList.java:414)
+        //     at com.strobel.decompiler.ast.AstBuilder.convertToAst(AstBuilder.java:3303)
+        //     at com.strobel.decompiler.ast.AstBuilder.build(AstBuilder.java:113)
+        //     at com.strobel.decompiler.languages.java.ast.AstMethodBodyBuilder.createMethodBody(AstMethodBodyBuilder.java:210)
+        //     at com.strobel.decompiler.languages.java.ast.AstMethodBodyBuilder.createMethodBody(AstMethodBodyBuilder.java:99)
+        //     at com.strobel.decompiler.languages.java.ast.AstBuilder.createMethodBody(AstBuilder.java:757)
+        //     at com.strobel.decompiler.languages.java.ast.AstBuilder.createMethod(AstBuilder.java:655)
+        //     at com.strobel.decompiler.languages.java.ast.AstBuilder.addTypeMembers(AstBuilder.java:532)
+        //     at com.strobel.decompiler.languages.java.ast.AstBuilder.createTypeCore(AstBuilder.java:499)
+        //     at com.strobel.decompiler.languages.java.ast.AstBuilder.createTypeNoCache(AstBuilder.java:141)
+        //     at com.strobel.decompiler.languages.java.ast.AstBuilder.createType(AstBuilder.java:130)
+        //     at com.strobel.decompiler.languages.java.ast.AstBuilder.addType(AstBuilder.java:105)
+        //     at com.strobel.decompiler.languages.java.JavaLanguage.buildAst(JavaLanguage.java:71)
+        //     at com.strobel.decompiler.languages.java.JavaLanguage.decompileType(JavaLanguage.java:59)
+        //     at com.strobel.decompiler.DecompilerDriver.decompileType(DecompilerDriver.java:317)
+        //     at com.strobel.decompiler.DecompilerDriver.decompileJar(DecompilerDriver.java:238)
+        //     at com.strobel.decompiler.DecompilerDriver.main(DecompilerDriver.java:138)
+        // 
+        throw new IllegalStateException("An error occurred while decompiling this method.");
+    }
+
+    private int calibrateAccelerometerSensor() {
+        int ret = calibrateAccelerationSensor();
+        if (DEBUG) {
+            Log.d(TAG, "startCalibrate......ret = " + ret);
+        }
+        int n = -1;
+        if (ret < 0) {
+            setAccelerometerSensorEnabled(false);
+        } else {
+            threadSleep(CALIBRATE_TIME_OUT);
+            ret = readAccelerationSensorCalibValue(mValues);
+            if (DEBUG) {
+                Log.d(TAG, "readAccelerationSensorCalibValue ret = " + ret);
+                Log.d(TAG, "readAccelerationSensorCalibValue x =" + mValues[0] + " y = " + mValues[1] + " z = " + mValues[2]);
+            }
+            if (ret < 0 || mValues[0] == 0 || mValues[1] == 0 || mValues[2] == 0) {
+                setAccelerometerSensorEnabled(false);
+                n = -1;
+            } else {
+                ret = writeAccelerationSensorCalibValue(mValues);
+                if (DEBUG) {
+                    Log.d(TAG, "writeAccelerationSensorCalibValue ret = " + ret);
+                }
+                if (ret >= 0) {
+                    setAccelerometerSensorEnabled(true);
+                    threadSleep(REGISTER_LISTENER_TIME_OUT);
+                    mSamples.clear();
+                    while (mSamples.size() < SAMPLE_COUNT) {
+                        Sample sample = new Sample();
+                        sample.x = mXValue;
+                        sample.y = mYValue;
+                        sample.z = mZValue;
+                        mSamples.add(sample);
+                        if (DEBUG) {
+                            Log.d(TAG, "X = " + sample.x + "Y = " + sample.y + " Z = " + sample.z);
+                        }
+                        threadSleep(SAMPLE_TIME_OUT);
+                    }
+                    boolean b = true;
+                    Iterator<Sample> iterator = mSamples.iterator();
+                    while (iterator.hasNext()) {
+                        Sample sample2 = iterator.next();
+                        float x = sample2.x;
+                        float y = sample2.y;
+                        float z = sample2.z;
+                        if (Math.abs(x) <= X_MAX_VALUE && Math.abs(y) <= Y_MAX_VALUE && Math.abs(z) >= Z_MIN_VALUE && Math.abs(z) <= Z_MAX_VALUE) {
+                            continue;
+                        }
+                        b = false;
+                        break;
+                    }
+                    if (b) {
+                        ret = writeCfgParam(DEVCFG_ACCELERATION_SENSOR, mValues);
+                        if (DEBUG) {
+                            Log.d(TAG, "writeCfgParam ret = " + ret);
+                        }
+                        File file = new File(ACCELERATION_FILE_PATH);
+                        boolean deleted;
+                        if (file.exists()) {
+                            deleted = file.delete();
+                            if (DEBUG) {
+                                Log.d(TAG, "delete file = " + file.toString() + " is " + deleted);
+                            }
+                         } else {
+                             deleted = true;
+                             if (DEBUG) {
+                                 Log.d(TAG, "file = " + file.toString() + " is not exists!");
+                             }
+                         }
+                         if (ret >= 0) {
+                             if (deleted) {
+                                 n = 0;
+                             }
+                         }
+                    } else {
+                        setAccelerometerSensorEnabled(false);
+                        n = -1;
+                    }
+                } else {
+                    n = -1;
+                }
+            }
+        }
+        return n;
+    }
+
+    private static String expandIntToString(int[] array) {
+        String string = "";
+        for (int i = 0; i < 7; ++i) {
+            for (int j = 0; j < 4; ++j) {
+                int n = array[i] >> (3 - j) * 8 & 0xFF;
+                int n2;
+                if ((n2 = n) < 0) {
+                    n2 = 256 - n;
+                }
+                string = string + " " + n2;
+            }
+        }
+        String s = string.substring(0, string.length() - 1);
+        for (int k = 0; k < 6; ++k) {
+            if (k == 0) {
+                s += 0;
+            }
+            else {
+                s += " 0";
+            }
+        }
+        if (DEBUG) {
+            Slog.d(TAG, "result string: " + s);
+        }
+        return s;
+    }
+
+    private static native int native_adjust_gravity_sensor(int[] p0);
+
+    private static native int native_calibrate_acceleration_sensor();
+
+    private static native int native_calibrate_gp2ap();
+
+    private static native int native_calibrate_gravity_sensor();
+
+    private static native int native_enable_touch_adjust();
+
+    private static native int native_read_acceleration_sensor_value(int[] p0);
+
+    private static native int native_read_auto_cabc();
+
+    private static native String native_read_calibration_data(String p0);
+
+    private static native int native_read_cfgparam(int p0, int[] p1);
+
+    private static native int native_read_cpu_value();
+
+    private static native int native_read_earpod_adjust_state();
+
+    private static native int native_read_gp2ap();
+
+    private static native int native_read_gravity_value(int[] p0);
+
+    private static native int native_reset_calibration();
+
+    private static native int native_save_cpu_value(int p0);
+
+    private static native int native_set_auto_cabc(int p0);
+
+    private static native int native_set_hdmi_cable_status(int p0);
+
+    private static native int native_set_key_wakeup_type(int p0);
+
+    private static native int native_switch_usb_fast_charger(int p0);
+
+    private static native int native_update_led_brightness(int p0);
+
+    private static native int native_write_acceleration_sensor_value(int[] p0);
+
+    private static native int native_write_calibration_data(final String p0, String p1);
+
+    private static native int native_write_calibrator_cmd(String p0);
+
+    private static native int native_write_cfgparam(int p0, int[] p1);
+
+    private static native int native_write_earpod_adjust_cmd(String p0);
+
+    private static native int native_write_gp2ap(int p0);
+
+    private String readCalibrationData(String s) {
+        String s3;
+        String s2 = s3 = native_read_calibration_data(s);
+        if (s2 != null) {
+            s3 = s2.substring(0, s2.length() - 1);
+        }
+        if (DEBUG) {
+            Log.d(TAG, "readCalibrationData path: " + s + " ret: " + s3);
+        }
+        return s3;
+    }
+
+    private void setAccelerometerSensorEnabled(boolean b) {
+        if (DEBUG) {
+            Slog.d(TAG, "setAccelerometerSensorEnabled enable:" + b + ",mAccelerometerSensorEnabled:" + mAccelerometerSensorEnabled);
+        }
+        if (b) {
+            if (!mAccelerometerSensorEnabled) {
+                mAccelerometerSensorEnabled = true;
+                mSensorManager.registerListener(mAccelerometerListener, mAccelerometer, 0);
+            }
+        } else if (mAccelerometerSensorEnabled) {
+            mAccelerometerSensorEnabled = false;
+            mXValue = 0.0f;
+            mYValue = 0.0f;
+            mZValue = 0.0f;
+            mSensorManager.unregisterListener(mAccelerometerListener);
+        }
+    }
+
+    private void threadSleep(long n) {
+        try {
+            Thread.sleep(n);
+        }
+        catch (Exception ex) {}
+    }
+
+    private int writeCalibrationData(String s, String s2) {
+        if (DEBUG) {
+            Log.d(TAG, "writeCalibrationData path: " + s + " data: " + s2);
+        }
+        return native_write_calibration_data(s, s2);
+    }
+
+    private int writeSensorCalibVals(String s, int n) {
+        int[] array = new int[7];
+        for (int i = 0; i < 7; ++i) {
+            array[i] = 0;
+        }
+        int n2 = 0;
+        for (int j = 0; j < 27; ++j) {
+            int index = s.indexOf(" ", n2);
+            int int1 = Integer.parseInt(s.substring(n2, index).trim());
+            int n3 = j / 4;
+            array[n3] |= (int1 & 0xFF) << (3 - j % 4) * 8;
+            n2 = index + 1;
+        }
+        if (n == 0) {
+            n = writeCfgParam(9, array);
+        }
+        else if (n == 2) {
+            n = writeCfgParam(10, array);
+        }
+        else {
+            n = -1;
+        }
+        return n;
+    }
+
+    public int adjustGravitySensor(int[] array) {
+        if (DEBUG) {
+            Log.d(TAG, "adjustGravitySensor");
+        }
+        return native_adjust_gravity_sensor(array);
+    }
+
+    public int calibrateAcceAndGyroSensor() {
+        return calibrateAccelerometerSensor();
+    }
+
+    public int calibrateAccelerationSensor() {
+        if (DEBUG) {
+            Log.d(TAG, "calibrateAccelerationSensor");
+        }
+        return native_calibrate_acceleration_sensor();
+    }
+
+    public int calibrateGp2ap() {
+        if (DEBUG) {
+            Log.d(TAG, "calibrateGp2ap");
+        }
+        return native_calibrate_gp2ap();
+    }
+
+    public int calibrateGravitySensor() {
+        if (DEBUG) {
+            Log.d(TAG, "calibrateGravitySensor");
+        }
+        return native_calibrate_gravity_sensor();
+    }
+
+    public int enableTouchAdjust() {
+        if (DEBUG) {
+            Log.d(TAG, "enableTouchAdjust");
+        }
+        return native_enable_touch_adjust();
+    }
+
+    public int readAccelerationSensorCalibValue(int[] array) {
+        if (DEBUG) {
+            Log.d(TAG, "readAccelerationSensorCalibValue");
+        }
+        return native_read_acceleration_sensor_value(array);
+    }
+
+    public int readAutoCabc() {
+        int native_read_auto_cabc = native_read_auto_cabc();
+        if (DEBUG) {
+            Log.d(TAG, "readAutoCabc--value:" + native_read_auto_cabc);
+        }
+        return native_read_auto_cabc;
+    }
+
+    public int readCPUfreq() {
+        int native_read_cpu_value = native_read_cpu_value();
+        if (DEBUG) {
+            Log.d(TAG, "readCPUfreq----value:" + native_read_cpu_value);
+        }
+        return native_read_cpu_value;
+    }
+
+    public int readCfgParam(int n, int[] array) {
+        if (DEBUG) {
+            Log.d(TAG, "readCfgParam dev:" + n);
+        }
+        int native_read_cfgparam = native_read_cfgparam(n, array);
+        if (DEBUG) {
+            Log.d(TAG, "readCfgParam dev over:" + n);
+        }
+        return native_read_cfgparam;
+    }
+
+    public String readEarpodAdjustState() {
+        String s = null;
+        switch (native_read_earpod_adjust_state()) {
+            default: {
+                s = EARPOD_ADJUST_STATE_ERROR;
+                break;
+            }
+            case -1: {
+                s = EARPOD_ADJUST_STATE_ERROR;
+                break;
+            }
+            case 1: {
+                s = EARPOD_ADJUST_STATE_PENDING;
+                break;
+            }
+            case 2: {
+                s = EARPOD_ADJUST_STATE_COMPLETE;
+                break;
+            }
+        }
+        return s;
+    }
+
+    public int readGp2apValue() {
+        int native_read_gp2ap = native_read_gp2ap();
+        if (DEBUG) {
+            Log.d(TAG, "readGp2apValue--value:" + native_read_gp2ap);
+        }
+        return native_read_gp2ap;
+    }
+
+    public int readGravityValue(int[] array) {
+        if (DEBUG) {
+            Log.d(TAG, "readGravityValue");
+        }
+        return native_read_gravity_value(array);
+    }
+
+    public int resetCalibration() {
+        int native_reset_calibration = native_reset_calibration();
+        if (DEBUG) {
+            Log.d(TAG, "resetCalibration----value:" + native_reset_calibration);
+        }
+        return native_reset_calibration;
+    }
+
+    public int saveCPUfreq(int n) {
+        if (DEBUG) {
+            Log.d(TAG, "saveCPUfreq----value:" + n);
+        }
+        return native_save_cpu_value(n);
+    }
+
+    public int saveKeyWakeupType(int n) {
+        if (DEBUG) {
+            Log.d(TAG, "saveKeyWakeupType value:" + n);
+        }
+        return native_set_key_wakeup_type(n);
+    }
+
+    public int setAutoCabc(int n) {
+        if (DEBUG) {
+            Log.d(TAG, "setAutoCabc--value:" + n);
+        }
+        return native_set_auto_cabc(n);
+    }
+
+    public int set_hdmi_cable_status(int native_set_hdmi_cable_status) {
+        if (DEBUG) {
+            Log.d(TAG, "set_hdmi_cable_status value is " + native_set_hdmi_cable_status);
+        }
+        native_set_hdmi_cable_status = native_set_hdmi_cable_status(native_set_hdmi_cable_status);
+        if (DEBUG) {
+            Log.d(TAG, "set_hdmi_cable_status--value overy:" + native_set_hdmi_cable_status);
+        }
+        return native_set_hdmi_cable_status;
+    }
+
+    public int switchUsbFastCharger(int n) {
+        if (DEBUG) {
+            Log.d(TAG, "switchUsbFastCharger value:" + n);
+        }
+        return native_switch_usb_fast_charger(n);
+    }
+
+    public int updateLedBrightness(int native_update_led_brightness) {
+        final long currentTimeMillis = System.currentTimeMillis();
+        native_update_led_brightness = native_update_led_brightness(native_update_led_brightness);
+        if (DEBUG) {
+            Log.d(TAG, "updateLedBrightness--value:" + native_update_led_brightness + "time cost " + (System.currentTimeMillis() - currentTimeMillis));
+        }
+        return native_update_led_brightness;
+    }
+
+    public void writeAccelerationFactoryCalibValue() {
+        int[] array = new int[7];
+        if (readCfgParam(DEVCFG_ACCELERATION_SENSOR, array) > 0) {
+            if (DEBUG) {
+                Slog.d(TAG, "writeAccelerationFactoryCalibValue acceleration: " + array[0] + ",data[1]" + array[1] + ",data[2]" + array[2]);
+            }
+            writeAccelerationSensorCalibValue(new int[] { array[0], array[1], array[2] });
+        }
+    }
+
+    public int writeAccelerationSensorCalibValue(int[] array) {
+        if (DEBUG) {
+            Log.d(TAG, "writeAccelerationSensorCalibValue");
+        }
+        return native_write_acceleration_sensor_value(array);
+    }
+
+    public int writeCalibratorCmd(String s) {
+        if (DEBUG) {
+            Log.d(TAG, "writeCalibratorCmd");
+        }
+        return native_write_calibrator_cmd(s);
+    }
+
+    public int writeCfgParam(int n, int[] array) {
+        if (DEBUG) {
+            Log.d(TAG, "writeCfgParam dev:" + n);
+        }
+        return native_write_cfgparam(n, array);
+    }
+
+    public int writeEarpodAdjustCmd(String s) {
+        if (DEBUG) {
+            Log.d(TAG, "write earpod adjust cmd.");
+        }
+        return native_write_earpod_adjust_cmd(s);
+    }
+
+    public int writeGp2apValue(int native_write_gp2ap) {
+        if (DEBUG) {
+            Log.d(TAG, "writeGp2apValue value is " + native_write_gp2ap);
+        }
+        native_write_gp2ap = native_write_gp2ap(native_write_gp2ap);
+        if (DEBUG) {
+            Log.d(TAG, "writeGp2apValue--value overy:" + native_write_gp2ap);
+        }
+        return native_write_gp2ap;
+    }
+
+    public void writeGyroscopeFactoryCalibValue() {
+    }
+
+    public void writeProximitySensorFactoryCalibValue() {
+        final int[] array = new int[7];
+        int override = -1;
+        try {
+            override = Integer.parseInt(SystemProperties.get("persist.devcontrol.proximity", "undef"));
+        }
+        catch (NumberFormatException e) {};
+
+        if (override != 0) {
+            if (readCfgParam(DEVCFG_IR_CALIBRATE, array) < 0) {
+                Slog.d(TAG, "readCfgParam returned error, skipping proximity calibration");
+                return;
+            }
+        } else {
+            Slog.d(TAG, "skipping proximity calibration");
+            return;
+        }
+
+        if (override > 0) {
+            Slog.d(TAG, "override proximity calibration: " + array[0] + " => " + override);
+            array[0] = override;
+        } else {
+            Slog.d(TAG, "Use defcfg proximity calibration: " + array[0]);
+        }
+
+        Slog.d(TAG, "writeGp2apValue: " + array[0]);
+        writeGp2apValue(array[0]);
+    }
+
+    static class Sample
+    {
+        float x;
+        float y;
+        float z;
+    }
+}
diff --git a/services/core/java/com/android/server/GestureManagerService.java b/services/core/java/com/android/server/GestureManagerService.java
new file mode 100644
index 00000000..23fbeadc
--- /dev/null
+++ b/services/core/java/com/android/server/GestureManagerService.java
@@ -0,0 +1,491 @@
+//
+// Reworked decompiled by Procyon v0.5.30
+//
+
+package com.android.server;
+
+import android.net.Uri;
+import android.database.ContentObserver;
+import android.os.IBinder.DeathRecipient;
+import android.os.Binder;
+
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileNotFoundException;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.UnsupportedEncodingException;
+import android.os.RemoteException;
+import android.provider.MzSettings;
+import android.provider.Settings;
+import android.provider.Settings.System;
+import android.view.IGestureCallback;
+import android.view.IGestureManager;
+//import android.os.BuildExt;
+import android.util.Log;
+import android.content.Intent;
+import android.hardware.SensorEvent;
+import android.os.Vibrator;
+import android.hardware.SensorManager;
+import android.content.BroadcastReceiver;
+import android.content.ContentResolver;
+import android.hardware.SensorEventListener;
+import android.hardware.Sensor;
+import java.util.ArrayList;
+
+import android.os.Handler;
+import android.os.IBinder;
+import android.content.IntentFilter;
+import android.content.Context;
+
+import com.android.internal.R;
+
+public class GestureManagerService extends IGestureManager.Stub
+{
+    private static final int CONTORL_DISABLE_ALL = 0;
+    private static final int CONTORL_ENABLE_TAP = 0x1;
+    private static final int CONTORL_ENABLE_SLIDE_LEFT = 0x2;
+    private static final int CONTORL_ENABLE_SLIDE_RIGHT = 0x4;
+    private static final int CONTORL_ENABLE_SLIDE_UP = 0x8;
+    private static final int CONTORL_ENABLE_SLIDE_DOWN = 0x10;
+    private static final int CONTORL_ENABLE_DRAW_C = 0x20;
+    private static final int CONTORL_ENABLE_DRAW_E = 0x40;
+    private static final int CONTORL_ENABLE_DRAW_M = 0x80;
+    private static final int CONTORL_ENABLE_DRAW_O = 0x100;
+    private static final int CONTORL_ENABLE_DRAW_S = 0x200;
+    private static final int CONTORL_ENABLE_DRAW_V = 0x400;
+    private static final int CONTORL_ENABLE_DRAW_W = 0x800;
+    private static final int CONTORL_ENABLE_DRAW_Z = 0x1000;
+
+    private static final boolean DEBUG = true;
+    private static final String TAG = "GestureManager";
+    private static final int VIBRATE_TIME_LONG = 50;
+    private static final int VIBRATE_TIME_SHORT = 25;
+    private Context mContext;
+    private int mEasyModeEnable = 0;
+    private IntentFilter mFilter;
+    private int mGestureAllDisable = 0;
+    private String mGestureControlPath = null;
+    private int[] mGestureData = new int[] { 160, 176, 177, 178, 179, 193, 192, 195, 196, 197, 199, 194, 202 };
+    private String mGestureDataPath = null;
+    private int mGestureGlobalSwitch = 0;
+    GestureObserver mGestureObserver;
+    Handler mHandler = new Handler();;
+    ArrayList<GestureListener> mListeners = new ArrayList<GestureListener>();;
+    private Sensor mProximitySensor;
+    private SensorEventListener mProximitySensorListener;
+    private BroadcastReceiver mReceiver;
+    private SensorManager mSensorManager;
+    private Vibrator mVibrator;
+
+    public GestureManagerService(Context context) {
+        mProximitySensorListener = new SensorEventListener() {
+            public void onAccuracyChanged(Sensor sensor, int n) {
+            }
+
+            public void onSensorChanged(SensorEvent sensorEvent) {
+            }
+        };
+        mContext = context;
+        mSensorManager = (SensorManager)mContext.getSystemService("sensor");
+        mProximitySensor = mSensorManager.getDefaultSensor(Sensor.TYPE_PROXIMITY, false);
+        mReceiver = new BroadcastReceiver() {
+            public void onReceive(Context context, Intent intent) {
+                String action = intent.getAction();
+                if (action.equals(Intent.ACTION_SCREEN_ON)) {
+                    Log.d(TAG, "onReceive(), ACTION_SCREEN_ON");
+                    mSensorManager.unregisterListener(mProximitySensorListener);
+                }
+                else if (action.equals(Intent.ACTION_SCREEN_OFF) && mGestureAllDisable != 0 && mGestureGlobalSwitch == 1) {
+                    Log.d(TAG, "onReceive(), ACTION_SCREEN_OFF");
+                    mSensorManager.registerListener(mProximitySensorListener, mProximitySensor, SensorManager.SENSOR_DELAY_NORMAL);
+                }
+            }
+        };
+        mFilter = new IntentFilter();
+        mFilter.addAction(Intent.ACTION_SCREEN_ON);
+        mFilter.addAction(Intent.ACTION_SCREEN_OFF);
+        mContext.registerReceiver(mReceiver, mFilter);
+        mVibrator = (Vibrator)mContext.getSystemService("vibrator");
+        //if (!BuildExt.IS_MX2 && !BuildExt.IS_MX3) {
+            mGestureDataPath = mContext.getResources().getString(R.string.gesture_data_path_string);
+            mGestureControlPath = mContext.getResources().getString(R.string.gesture_control_path_string);
+        //}
+    }
+
+    private void disableAllGesture() {
+    }
+
+    private void enableAllGesture() {
+    }
+
+    private GestureListener findByCallbackLocked(IGestureCallback gestureCallback) {
+        for (int i = 0; i < this.mListeners.size(); ++i) {
+            GestureListener gestureListener = mListeners.get(i);
+            if (gestureCallback == gestureListener.mCallback) {
+                return gestureListener;
+            }
+        }
+        return null;
+    }
+
+    private void initGestureControl() {
+        if (Settings.System.getInt(mContext.getContentResolver(), MzSettings.System.MZ_QUICK_WAKEUP_DOUBLE_CLICK, 0) != 0) {
+            mGestureAllDisable = CONTORL_ENABLE_TAP;
+        }
+        if (Settings.System.getInt(mContext.getContentResolver(), MzSettings.System.MZ_QUICK_WAKEUP_SLIDE_LEFT_RIGHT, 0) == 1) {
+            mGestureAllDisable |= CONTORL_ENABLE_SLIDE_LEFT;
+            mGestureAllDisable |= CONTORL_ENABLE_SLIDE_RIGHT;
+        }
+        if (Settings.System.getInt(mContext.getContentResolver(), MzSettings.System.MZ_QUICK_WAKEUP_SLIDE_UP, 0) == 1) {
+            mGestureAllDisable |= CONTORL_ENABLE_SLIDE_UP;
+        }
+        if (Settings.System.getInt(mContext.getContentResolver(), MzSettings.System.MZ_QUICK_WAKEUP_SLIDE_DOWN, 0) == 1) {
+            mGestureAllDisable |= CONTORL_ENABLE_SLIDE_DOWN;
+        }
+        if (Settings.System.getInt(mContext.getContentResolver(), MzSettings.System.MZ_QUICK_WAKEUP_DRAW_C, 0) == 1) {
+            mGestureAllDisable |= CONTORL_ENABLE_DRAW_C;
+        }
+        if (Settings.System.getInt(mContext.getContentResolver(), MzSettings.System.MZ_QUICK_WAKEUP_DRAW_E, 0) == 1) {
+            mGestureAllDisable |= CONTORL_ENABLE_DRAW_E;
+        }
+        if (Settings.System.getInt(mContext.getContentResolver(), MzSettings.System.MZ_QUICK_WAKEUP_DRAW_M, 0) == 1) {
+            mGestureAllDisable |= CONTORL_ENABLE_DRAW_M;
+        }
+        if (Settings.System.getInt(mContext.getContentResolver(), MzSettings.System.MZ_QUICK_WAKEUP_DRAW_O, 0) == 1) {
+            mGestureAllDisable |= CONTORL_ENABLE_DRAW_O;
+        }
+        if (Settings.System.getInt(mContext.getContentResolver(), MzSettings.System.MZ_QUICK_WAKEUP_DRAW_S, 0) == 1) {
+            mGestureAllDisable |= CONTORL_ENABLE_DRAW_S;
+        }
+        if (Settings.System.getInt(mContext.getContentResolver(), MzSettings.System.MZ_QUICK_WAKEUP_DRAW_V, 0) == 1) {
+            mGestureAllDisable |= CONTORL_ENABLE_DRAW_V;
+        }
+        if (Settings.System.getInt(mContext.getContentResolver(), MzSettings.System.MZ_QUICK_WAKEUP_DRAW_W, 0) == 1) {
+            mGestureAllDisable |= CONTORL_ENABLE_DRAW_W;
+        }
+        if (Settings.System.getInt(mContext.getContentResolver(), MzSettings.System.MZ_QUICK_WAKEUP_DRAW_Z, 0) == 1) {
+            mGestureAllDisable |= CONTORL_ENABLE_DRAW_Z;
+        }
+        Log.d(TAG, "initGestureControl , mGestureAllDisable = " + mGestureAllDisable);
+        mGestureGlobalSwitch = Settings.System.getInt(mContext.getContentResolver(), MzSettings.System.MZ_QUICK_WAKEUP_SWITCH, 0);
+        Log.d(TAG, "initGestureControl , mGestureGlobalSwitch = " + mGestureGlobalSwitch);
+        mEasyModeEnable = Settings.System.getInt(mContext.getContentResolver(), MzSettings.System.MZ_EASY_MODE, 0);
+        Log.d(TAG, "initGestureControl , mEasyModeEnable = " + mEasyModeEnable);
+        if (mGestureAllDisable == 0 || mGestureGlobalSwitch == 0 || mEasyModeEnable == 1) {
+            writeToControl(mGestureControlPath, 0);
+        }
+        else {
+            writeToControl(mGestureControlPath, 1);
+        }
+    }
+
+    private void notifyListeners(int n) {
+        for (GestureListener gestureListener : mListeners) {
+            if (gestureListener != null) {
+                try {
+                    gestureListener.mCallback.onGestureTrigger(n);
+                    Log.d(TAG, "notifyListeners " + gestureListener.mTag + ", type is " + n);
+                }
+                catch (RemoteException ex) {
+                    Log.e(TAG, "Fails to notify listener ", ex);
+                }
+            }
+        }
+    }
+
+    private int readFrom(String p0) {
+        int result = -1;
+        byte[] read  = new byte[8];
+        try (FileInputStream fis = new FileInputStream(p0)){
+            int n = fis.read(read);
+            if (n > 0) {
+                String strValue = new String(read, "UTF-8").substring(0, n-1);
+                Log.d(TAG, "readFrom: read: " + strValue);
+                result = Integer.parseInt(strValue, 10);
+            }
+            fis.close();
+        } catch (UnsupportedEncodingException e) {
+            Log.e(TAG, "readFrom: Cannot convert value", e);
+        } catch (FileNotFoundException e) {
+            Log.e(TAG, "readFrom: file not found:", e);
+        } catch (IOException e) {
+            Log.e(TAG, "readFrom: cannot read from file " + p0, e);
+        }
+        return result;
+    }
+
+    private String toString(byte[] array, int n) {
+        byte[] array2 = new byte[n];
+        for (int i = 0; i < n; ++i) {
+            array2[i] = (byte)(array[i] + 48);
+        }
+        array = null;
+        try {
+            array = (byte[])(Object)new String(array2, "UTF-8");
+            return (String)(Object)array;
+        }
+        catch (UnsupportedEncodingException ex) {
+            Log.e(TAG, "Failed to convert ", ex);
+            return (String)(Object)array;
+        }
+    }
+
+    private void writeToControl(String p0, int p1) {
+        if (p0 == null || p0.length() == 0) {
+            throw new NullPointerException();
+        }
+        Log.d(TAG, "writeToControl , deviceNode: " + p0 + " enable:" + p1);
+        try (FileOutputStream fos = new FileOutputStream(new File(p0))) {
+            fos.write(p1 + '0');
+        } catch (IOException e) {
+            Log.d(TAG, "writeToControl , cannot write to" + p0);
+        }
+    }
+
+    public void pauseAllGesture() throws RemoteException {
+    }
+
+    public void registeCallback(IGestureCallback gestureCallback, String s) throws RemoteException {
+        synchronized (this) {
+            if (findByCallbackLocked(gestureCallback) != null) {
+                Log.e("GestureManager", "Object tried to add another listeners", new Exception("Called by tag"));
+            }
+            GestureListener gestureListener = new GestureListener(gestureCallback, s);
+            gestureCallback.asBinder().linkToDeath(new BinderDeath(s, Binder.getCallingUid(), gestureListener), 0);
+            mListeners.add(gestureListener);
+            Log.d("GestureManager", "Object tried to add listeners: " + s + ", mListeners.size = " + mListeners.size());
+        }
+    }
+
+    public void removeCallback(IGestureCallback gestureCallback) throws RemoteException {
+        synchronized (this) {
+            GestureListener byCallbackLocked = findByCallbackLocked(gestureCallback);
+            boolean removed = false;
+            if (byCallbackLocked != null) {
+                removed = mListeners.remove(byCallbackLocked);
+                Log.d("GestureManager", "remove tried to add listeners: " + byCallbackLocked.mTag + ", mListeners.size = " + mListeners.size());
+            }
+            if (!removed) {
+                Log.e("GestureManager", "can't find the listener. ", new Exception("Called by"));
+            }
+        }
+    }
+
+    public void resumeAllGesture() throws RemoteException {
+    }
+
+    public void systemReady() {
+        initGestureControl();
+        mGestureObserver = new GestureObserver(this.mHandler);
+        ContentResolver cr = mContext.getContentResolver();
+        cr.registerContentObserver(Settings.System.getUriFor(MzSettings.System.MZ_QUICK_WAKEUP_SLIDE_LEFT_RIGHT), false, (ContentObserver)mGestureObserver);
+        cr.registerContentObserver(Settings.System.getUriFor(MzSettings.System.MZ_QUICK_WAKEUP_SLIDE_UP), false, (ContentObserver)mGestureObserver);
+        cr.registerContentObserver(Settings.System.getUriFor(MzSettings.System.MZ_QUICK_WAKEUP_SLIDE_DOWN), false, (ContentObserver)mGestureObserver);
+        cr.registerContentObserver(Settings.System.getUriFor(MzSettings.System.MZ_QUICK_WAKEUP_DRAW_C), false, (ContentObserver)mGestureObserver);
+        cr.registerContentObserver(Settings.System.getUriFor(MzSettings.System.MZ_QUICK_WAKEUP_DRAW_E), false, (ContentObserver)mGestureObserver);
+        cr.registerContentObserver(Settings.System.getUriFor(MzSettings.System.MZ_QUICK_WAKEUP_DRAW_M), false, (ContentObserver)mGestureObserver);
+        cr.registerContentObserver(Settings.System.getUriFor(MzSettings.System.MZ_QUICK_WAKEUP_DRAW_O), false, (ContentObserver)mGestureObserver);
+        cr.registerContentObserver(Settings.System.getUriFor(MzSettings.System.MZ_QUICK_WAKEUP_DRAW_S), false, (ContentObserver)mGestureObserver);
+        cr.registerContentObserver(Settings.System.getUriFor(MzSettings.System.MZ_QUICK_WAKEUP_DRAW_V), false, (ContentObserver)mGestureObserver);
+        cr.registerContentObserver(Settings.System.getUriFor(MzSettings.System.MZ_QUICK_WAKEUP_DRAW_W), false, (ContentObserver)mGestureObserver);
+        cr.registerContentObserver(Settings.System.getUriFor(MzSettings.System.MZ_QUICK_WAKEUP_DRAW_Z), false, (ContentObserver)mGestureObserver);
+        cr.registerContentObserver(Settings.System.getUriFor(MzSettings.System.MZ_QUICK_WAKEUP_DOUBLE_CLICK), false, (ContentObserver)mGestureObserver);
+        cr.registerContentObserver(Settings.System.getUriFor(MzSettings.System.MZ_QUICK_WAKEUP_SWITCH), false, (ContentObserver)mGestureObserver);
+        cr.registerContentObserver(Settings.System.getUriFor(MzSettings.System.MZ_EASY_MODE), false, (ContentObserver)mGestureObserver);
+        Log.d("GestureManager", "system startWatching");
+    }
+
+    public boolean triggerGesture() throws RemoteException {
+        int gesture = 0;
+        boolean result = false;
+        int n = -1;
+        if (mGestureDataPath != null) {
+            gesture = readFrom(mGestureDataPath);
+        }
+        if (gesture != 0) {
+            int idx = -1;
+            for (int i = 0; i < mGestureData.length; i++) {
+                if (gesture == mGestureData[i]) {
+                    idx = i;
+                    break;
+                }
+            }
+            if (idx == -1 || (mGestureAllDisable & (1 << idx)) == 0x0) {
+                Log.e("GestureManager", "This gesture (type = " + gesture + ") is off!");
+            }
+            else {
+                result = true;
+                //if (BuildExt.IS_M1) {
+                //    mVibrator.vibrate(VIBRATE_TIME_LONG);
+                //}
+                //else {
+                    mVibrator.vibrate(VIBRATE_TIME_SHORT);
+                //}
+                final int aGesture = gesture;
+                mHandler.post(new Runnable() {
+                    @Override
+                    public void run() {
+                        notifyListeners(aGesture);
+                    }
+                });
+            }
+        }
+        return result;
+    }
+
+    private final class BinderDeath implements IBinder.DeathRecipient
+    {
+        private GestureListener mListener;
+        private String mTag;
+        private int mUid;
+
+        BinderDeath(String tag, int uid, GestureListener listener) {
+            mTag = tag;
+            mUid = uid;
+            mListener = listener;
+        }
+
+        public void binderDied() {
+            synchronized (this) {
+                Log.w("GestureManager", "Death received from " + mTag + " for uid " + mUid);
+                mListeners.remove(mListener);
+            }
+        }
+    }
+
+    private final class GestureListener
+    {
+        IGestureCallback mCallback;
+        String mTag;
+
+        GestureListener(IGestureCallback callback, String tag) {
+            mTag = tag;
+            mCallback = callback;
+        }
+    }
+
+    class GestureObserver extends ContentObserver
+    {
+        public GestureObserver(Handler handler) {
+            super(handler);
+        }
+
+        public void onChange(boolean selfChange, Uri uri) {
+            super.onChange(selfChange, uri);
+            if (Settings.System.getUriFor(MzSettings.System.MZ_QUICK_WAKEUP_SLIDE_UP).equals(uri)) {
+                if (Settings.System.getInt(mContext.getContentResolver(), MzSettings.System.MZ_QUICK_WAKEUP_SLIDE_UP, 0) == 1) {
+                    mGestureAllDisable |= CONTORL_ENABLE_SLIDE_UP;
+                }
+                else {
+                    mGestureAllDisable &= ~CONTORL_ENABLE_SLIDE_UP;
+                }
+            }
+            else if (Settings.System.getUriFor(MzSettings.System.MZ_QUICK_WAKEUP_SLIDE_LEFT_RIGHT).equals(uri)) {
+                if (Settings.System.getInt(mContext.getContentResolver(), MzSettings.System.MZ_QUICK_WAKEUP_SLIDE_LEFT_RIGHT, 0) == 1) {
+                    mGestureAllDisable |= CONTORL_ENABLE_SLIDE_LEFT;
+                    mGestureAllDisable |= CONTORL_ENABLE_SLIDE_RIGHT;
+                }
+                else {
+                    mGestureAllDisable &= ~CONTORL_ENABLE_SLIDE_LEFT;
+                    mGestureAllDisable &= ~CONTORL_ENABLE_SLIDE_RIGHT;
+                }
+            }
+            else if (Settings.System.getUriFor(MzSettings.System.MZ_QUICK_WAKEUP_DOUBLE_CLICK).equals(uri)) {
+                if (Settings.System.getInt(mContext.getContentResolver(), MzSettings.System.MZ_QUICK_WAKEUP_DOUBLE_CLICK, 0) == 1) {
+                    mGestureAllDisable |= CONTORL_ENABLE_TAP;
+                }
+                else {
+                    mGestureAllDisable &= ~CONTORL_ENABLE_TAP;
+                }
+            }
+            else if (Settings.System.getUriFor(MzSettings.System.MZ_QUICK_WAKEUP_SLIDE_DOWN).equals(uri)) {
+                if (Settings.System.getInt(mContext.getContentResolver(), MzSettings.System.MZ_QUICK_WAKEUP_SLIDE_DOWN, 0) == 1) {
+                    mGestureAllDisable |= CONTORL_ENABLE_SLIDE_DOWN;
+                }
+                else {
+                    mGestureAllDisable &= ~CONTORL_ENABLE_SLIDE_DOWN;
+                }
+            }
+            else if (Settings.System.getUriFor(MzSettings.System.MZ_QUICK_WAKEUP_DRAW_C).equals(uri)) {
+                if (Settings.System.getInt(mContext.getContentResolver(), MzSettings.System.MZ_QUICK_WAKEUP_DRAW_C, 0) == 1) {
+                    mGestureAllDisable |= CONTORL_ENABLE_DRAW_C;
+                }
+                else {
+                    mGestureAllDisable &= ~CONTORL_ENABLE_DRAW_C;
+                }
+            }
+            else if (Settings.System.getUriFor(MzSettings.System.MZ_QUICK_WAKEUP_DRAW_E).equals(uri)) {
+                if (Settings.System.getInt(mContext.getContentResolver(), MzSettings.System.MZ_QUICK_WAKEUP_DRAW_E, 0) == 1) {
+                    mGestureAllDisable |= CONTORL_ENABLE_DRAW_E;
+                }
+                else {
+                    mGestureAllDisable &= ~CONTORL_ENABLE_DRAW_E;
+                }
+            }
+            else if (Settings.System.getUriFor(MzSettings.System.MZ_QUICK_WAKEUP_DRAW_M).equals(uri)) {
+                if (Settings.System.getInt(mContext.getContentResolver(), MzSettings.System.MZ_QUICK_WAKEUP_DRAW_M, 0) == 1) {
+                    mGestureAllDisable |= CONTORL_ENABLE_DRAW_M;
+                }
+                else {
+                    mGestureAllDisable &= ~CONTORL_ENABLE_DRAW_M;
+                }
+            }
+            else if (Settings.System.getUriFor(MzSettings.System.MZ_QUICK_WAKEUP_DRAW_O).equals(uri)) {
+                if (Settings.System.getInt(mContext.getContentResolver(), MzSettings.System.MZ_QUICK_WAKEUP_DRAW_O, 0) == 1) {
+                    mGestureAllDisable |= CONTORL_ENABLE_DRAW_O;
+                }
+                else {
+                    mGestureAllDisable &= ~CONTORL_ENABLE_DRAW_O;
+                }
+            }
+            else if (Settings.System.getUriFor(MzSettings.System.MZ_QUICK_WAKEUP_DRAW_S).equals(uri)) {
+                if (Settings.System.getInt(mContext.getContentResolver(), MzSettings.System.MZ_QUICK_WAKEUP_DRAW_S, 0) == 1) {
+                    mGestureAllDisable |= CONTORL_ENABLE_DRAW_S;
+                }
+                else {
+                    mGestureAllDisable &= ~CONTORL_ENABLE_DRAW_S;
+                }
+            }
+            else if (Settings.System.getUriFor(MzSettings.System.MZ_QUICK_WAKEUP_DRAW_V).equals(uri)) {
+                if (Settings.System.getInt(mContext.getContentResolver(), MzSettings.System.MZ_QUICK_WAKEUP_DRAW_V, 0) == 1) {
+                    mGestureAllDisable |= CONTORL_ENABLE_DRAW_V;
+                }
+                else {
+                    mGestureAllDisable &= ~CONTORL_ENABLE_DRAW_V;
+                }
+            }
+            else if (Settings.System.getUriFor(MzSettings.System.MZ_QUICK_WAKEUP_DRAW_W).equals(uri)) {
+                if (Settings.System.getInt(mContext.getContentResolver(), MzSettings.System.MZ_QUICK_WAKEUP_DRAW_W, 0) == 1) {
+                    mGestureAllDisable |= CONTORL_ENABLE_DRAW_W;
+                }
+                else {
+                    mGestureAllDisable &= ~CONTORL_ENABLE_DRAW_W;
+                }
+            }
+            else if (Settings.System.getUriFor(MzSettings.System.MZ_QUICK_WAKEUP_DRAW_Z).equals(uri)) {
+                if (Settings.System.getInt(mContext.getContentResolver(), MzSettings.System.MZ_QUICK_WAKEUP_DRAW_Z, 0) == 1) {
+                    mGestureAllDisable |= CONTORL_ENABLE_DRAW_Z;
+                }
+                else {
+                    mGestureAllDisable &= ~CONTORL_ENABLE_DRAW_Z;
+                }
+            }
+            Log.d(TAG, "onChange , mGestureAllDisable = " + mGestureAllDisable);
+            if (Settings.System.getUriFor(MzSettings.System.MZ_QUICK_WAKEUP_SWITCH).equals(uri)) {
+                mGestureGlobalSwitch = Settings.System.getInt(mContext.getContentResolver(), MzSettings.System.MZ_QUICK_WAKEUP_SWITCH, 0);
+            }
+            Log.d(TAG, "onChange , mGestureGlobalSwitch = " + mGestureGlobalSwitch);
+            if (Settings.System.getUriFor(MzSettings.System.MZ_EASY_MODE).equals(uri)) {
+                mEasyModeEnable = Settings.System.getInt(mContext.getContentResolver(), MzSettings.System.MZ_EASY_MODE, 0);
+            }
+            Log.d(TAG, "onChange , mEasyModeEnable = " + mEasyModeEnable);
+            if (mGestureAllDisable == 0 || mGestureGlobalSwitch == 0 || mEasyModeEnable == 1) {
+                writeToControl(mGestureControlPath, 0);
+            }
+            else {
+                writeToControl(mGestureControlPath, 1);
+            }
+        }
+    }
+}
diff --git a/services/core/java/com/android/server/PerfMgrStateNotifier.java b/services/core/java/com/android/server/PerfMgrStateNotifier.java
new file mode 100644
index 00000000..70a1094f
--- /dev/null
+++ b/services/core/java/com/android/server/PerfMgrStateNotifier.java
@@ -0,0 +1,57 @@
+//
+// Decompiled by Procyon v0.5.30
+//
+
+package com.android.server;
+
+import java.util.Iterator;
+import java.util.HashSet;
+import com.android.server.am.IActivityStateNotifier;
+
+import com.mediatek.perfservice.PerfServiceWrapper;
+
+public final class PerfMgrStateNotifier implements IActivityStateNotifier
+{
+    static final String TAG = "PerfMgrStateNotifier";
+
+    private PerfServiceWrapper mPerfService = new PerfServiceWrapper(null);
+
+    public PerfMgrStateNotifier() {
+        super();
+    }
+
+    @Override
+    public void notifyActivityState(String s, String s2, ActivityState activityState) {
+        int n = 0;
+        switch (activityState) {
+            default: {
+                return;
+            }
+            case Paused: {
+                n = PerfServiceWrapper.STATE_PAUSED;
+                break;
+            }
+            case Resumed: {
+                n = PerfServiceWrapper.STATE_RESUMED;
+                break;
+            }
+            case Destroyed: {
+                n = PerfServiceWrapper.STATE_DESTROYED;
+                break;
+            }
+            case Stopped: {
+                n = PerfServiceWrapper.STATE_STOPPED;
+                break;
+            }
+        }
+        mPerfService.notifyAppState(s, s2, n);
+    }
+
+    @Override
+    public void notifyAppDied(int pid, HashSet<String> set) {
+        Iterator<String> iterator = set.iterator();
+        while (iterator.hasNext()) {
+            mPerfService.notifyAppState(iterator.next(), null, PerfServiceWrapper.STATE_DEAD);
+        }
+    }
+}
diff --git a/services/core/java/com/android/server/am/ActivityManagerService.java b/services/core/java/com/android/server/am/ActivityManagerService.java
index 7bb80738..a365356a 100644
--- a/services/core/java/com/android/server/am/ActivityManagerService.java
+++ b/services/core/java/com/android/server/am/ActivityManagerService.java
@@ -244,6 +244,7 @@ import java.util.Map;
 import java.util.Set;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicLong;
+import com.mediatek.perfservice.PerfServiceWrapper;
 
 public final class ActivityManagerService extends ActivityManagerNative
         implements Watchdog.Monitor, BatteryStatsImpl.BatteryCallback {
@@ -18407,6 +18408,14 @@ public final class ActivityManagerService extends ActivityManagerNative
                     + " target=" + app.adjTarget);
         }
 
+        if ("top-activity".equals(app.adjType)) {
+            if (mPerfServiceWrapper == null) {
+                mPerfServiceWrapper = new PerfServiceWrapper(null);
+            }
+            if (mPerfServiceWrapper != null) {
+                mPerfServiceWrapper.setFavorPid(app.pid);
+            }
+        }
         return success;
     }
 
@@ -20120,4 +20129,29 @@ public final class ActivityManagerService extends ActivityManagerNative
             }
         }
     }
+
+    // MTK
+
+    ArrayList<IActivityStateNotifier> mActStateNotifiers = new ArrayList<IActivityStateNotifier>();
+
+    PerfServiceWrapper mPerfServiceWrapper = null;
+
+    public void registerActivityStateNotifier(final IActivityStateNotifier activityStateNotifier) {
+        Slog.i("ActivityManager", "registerActivityStateNotifier");
+        if (!this.mActStateNotifiers.contains(activityStateNotifier)) {
+            this.mActStateNotifiers.add(activityStateNotifier);
+        }
+    }
+
+    void notifyActivityState(String s, String s2, IActivityStateNotifier.ActivityState activityState) {
+        for (int i = 0; i < mActStateNotifiers.size(); ++i) {
+            mActStateNotifiers.get(i).notifyActivityState(s, s2, activityState);
+        }
+    }
+
+    void notifyAppDied(int n, HashSet<String> set) {
+        for (int i = 0; i < mActStateNotifiers.size(); ++i) {
+            mActStateNotifiers.get(i).notifyAppDied(n, set);
+        }
+    }
 }
diff --git a/services/core/java/com/android/server/am/ActivityStack.java b/services/core/java/com/android/server/am/ActivityStack.java
index c98732b2..ddecd0aa 100644
--- a/services/core/java/com/android/server/am/ActivityStack.java
+++ b/services/core/java/com/android/server/am/ActivityStack.java
@@ -913,11 +913,13 @@ final class ActivityStack {
                     finishCurrentActivityLocked(r, FINISH_AFTER_VISIBLE, false);
                 }
             }
+            mService.notifyActivityState(r.packageName, r.realActivity.getShortClassName(), IActivityStateNotifier.ActivityState.Paused);
         }
     }
 
     final void activityStoppedLocked(ActivityRecord r, Bundle icicle,
             PersistableBundle persistentState, CharSequence description) {
+        mService.notifyActivityState(r.packageName, r.realActivity.getShortClassName(), IActivityStateNotifier.ActivityState.Stopped);
         if (r.state != ActivityState.STOPPING) {
             Slog.i(TAG, "Activity reported stop, but no longer stopping: " + r);
             mHandler.removeMessages(STOP_TIMEOUT_MSG, r);
@@ -3272,6 +3274,7 @@ final class ActivityStack {
 
         boolean removedFromHistory = false;
 
+        mService.notifyActivityState(r.packageName, r.realActivity.getShortClassName(), IActivityStateNotifier.ActivityState.Destroyed);
         cleanUpActivityLocked(r, false, false);
 
         final boolean hadApp = r.app != null;
diff --git a/services/core/java/com/android/server/am/ActivityStackSupervisor.java b/services/core/java/com/android/server/am/ActivityStackSupervisor.java
index 1aa24321..3d0ed90d 100644
--- a/services/core/java/com/android/server/am/ActivityStackSupervisor.java
+++ b/services/core/java/com/android/server/am/ActivityStackSupervisor.java
@@ -2905,6 +2905,7 @@ public final class ActivityStackSupervisor implements DisplayListener {
         if (isFrontStack(stack)) {
             mService.updateUsageStats(r, true);
         }
+        mService.notifyActivityState(r.packageName, r.realActivity.getShortClassName(), IActivityStateNotifier.ActivityState.Resumed);
         if (allResumedActivitiesComplete()) {
             ensureActivitiesVisibleLocked(null, 0);
             mWindowManager.executeAppTransition();
diff --git a/services/core/java/com/android/server/am/IActivityStateNotifier.java b/services/core/java/com/android/server/am/IActivityStateNotifier.java
new file mode 100644
index 00000000..ed63d520
--- /dev/null
+++ b/services/core/java/com/android/server/am/IActivityStateNotifier.java
@@ -0,0 +1,22 @@
+//
+// Decompiled by Procyon v0.5.30
+//
+
+package com.android.server.am;
+
+import java.util.HashSet;
+
+public interface IActivityStateNotifier
+{
+    void notifyActivityState(String p0, String p1, ActivityState p2);
+
+    void notifyAppDied(int p0, HashSet<String> p1);
+
+    public enum ActivityState
+    {
+        Destroyed,
+        Paused,
+        Resumed,
+        Stopped;
+    }
+}
diff --git a/services/core/java/com/android/server/location/GpsLocationProvider.java b/services/core/java/com/android/server/location/GpsLocationProvider.java
index 4e58c6c2..92a74eab 100644
--- a/services/core/java/com/android/server/location/GpsLocationProvider.java
+++ b/services/core/java/com/android/server/location/GpsLocationProvider.java
@@ -1718,6 +1718,72 @@ public class GpsLocationProvider implements LocationProviderInterface {
         }
     }
 
+    /**
+     * Count number of GNSS satellites used in fix.
+     *
+     * We could not rely on Integer.bitCount as GNSS used-in-fix info is not
+     * represented as a bit-mask.
+     */
+    private int countGnssSvUsedInFix(final int gnssSvCount) {
+        int result = 0;
+
+        for (int i = 0; i < gnssSvCount; i++) {
+            if (mSvUsedInFix[i]) {
+                result++;
+            }
+        }
+
+        return result;
+    }
+
+    /**
+     * called from native code to update GNSS SV info
+     */
+    private void reportGnssSvStatus() {
+        final int svCount = native_read_gnss_sv_status(
+                mSvs,
+                mSnrs,
+                mSvElevations,
+                mSvAzimuths,
+                mSvEphemerisPresences,
+                mSvAlmanacPresences,
+                mSvUsedInFix);
+        mListenerHelper.onGnssSvStatusChanged(
+                svCount,
+                mSvs,
+                mSnrs,
+                mSvElevations,
+                mSvAzimuths,
+                mSvEphemerisPresences,
+                mSvAlmanacPresences,
+                mSvUsedInFix);
+
+        if (VERBOSE) {
+            Log.v(TAG, "GNSS SV count: " + svCount);
+            for (int i = 0; i < svCount; i++) {
+                Log.v(TAG, "sv: " + mSvs[i] +
+                        " snr: " + mSnrs[i]/10 +
+                        " elev: " + mSvElevations[i] +
+                        " azimuth: " + mSvAzimuths[i] +
+                        (!mSvEphemerisPresences[i] ? "  " : " E") +
+                        (!mSvAlmanacPresences[i] ? "  " : " A") +
+                        (!mSvUsedInFix[i] ? "" : "U"));
+            }
+        }
+
+        // return number of sets used in fix instead of total
+        updateStatus(mStatus, countGnssSvUsedInFix(svCount));
+
+        if (mNavigating && mStatus == LocationProvider.AVAILABLE && mLastFixTime > 0 &&
+            System.currentTimeMillis() - mLastFixTime > RECENT_FIX_TIMEOUT) {
+            // send an intent to notify that the GPS is no longer receiving fixes.
+            Intent intent = new Intent(LocationManager.GPS_FIX_CHANGE_ACTION);
+            intent.putExtra(LocationManager.EXTRA_GPS_ENABLED, false);
+            mContext.sendBroadcastAsUser(intent, UserHandle.ALL);
+            updateStatus(LocationProvider.TEMPORARILY_UNAVAILABLE, mSvCount);
+        }
+    }
+
     /**
      * called from native code to update AGPS status
      */
@@ -2352,12 +2418,18 @@ public class GpsLocationProvider implements LocationProviderInterface {
     private static final int ALMANAC_MASK = 1;
     private static final int USED_FOR_FIX_MASK = 2;
 
+    // GNSS extension
+    private static final int MAX_GNSS_SVS = 256;
+
     // preallocated arrays, to avoid memory allocation in reportStatus()
-    private int mSvs[] = new int[MAX_SVS];
-    private float mSnrs[] = new float[MAX_SVS];
-    private float mSvElevations[] = new float[MAX_SVS];
-    private float mSvAzimuths[] = new float[MAX_SVS];
+    private int mSvs[] = new int[MAX_GNSS_SVS];
+    private float mSnrs[] = new float[MAX_GNSS_SVS];
+    private float mSvElevations[] = new float[MAX_GNSS_SVS];
+    private float mSvAzimuths[] = new float[MAX_GNSS_SVS];
     private int mSvMasks[] = new int[3];
+    private boolean mSvEphemerisPresences[] = new boolean[MAX_GNSS_SVS];
+    private boolean mSvAlmanacPresences[] = new boolean[MAX_GNSS_SVS];
+    private boolean mSvUsedInFix[] = new boolean[MAX_GNSS_SVS];
     private int mSvCount;
     // preallocated to avoid memory allocation in reportNmea()
     private byte[] mNmeaBuffer = new byte[120];
@@ -2377,6 +2449,12 @@ public class GpsLocationProvider implements LocationProviderInterface {
     // mask[0] is ephemeris mask and mask[1] is almanac mask
     private native int native_read_sv_status(int[] svs, float[] snrs,
             float[] elevations, float[] azimuths, int[] masks);
+    // returns number of GNSS SVs
+    private native int native_read_gnss_sv_status(int[] svs, float[] snrs,
+            float[] elevations, float[] azimuths,
+            boolean[] ephemerisPresences,
+            boolean[] almanacPresences,
+            boolean[] usedInFix);
     private native int native_read_nmea(byte[] buffer, int bufferSize);
     private native void native_inject_location(double latitude, double longitude, float accuracy);
 
diff --git a/services/core/java/com/android/server/location/GpsStatusListenerHelper.java b/services/core/java/com/android/server/location/GpsStatusListenerHelper.java
index 376b4a53..9155c7f3 100644
--- a/services/core/java/com/android/server/location/GpsStatusListenerHelper.java
+++ b/services/core/java/com/android/server/location/GpsStatusListenerHelper.java
@@ -104,6 +104,32 @@ abstract class GpsStatusListenerHelper extends RemoteListenerHelper<IGpsStatusLi
         foreach(operation);
     }
 
+    public void onGnssSvStatusChanged(
+            final int svCount,
+            final int[] prns,
+            final float[] snrs,
+            final float[] elevations,
+            final float[] azimuths,
+            final boolean[] ephemerisPresences,
+            final boolean[] almanacPresences,
+            final boolean[] usedInFix) {
+        Operation operation = new Operation() {
+            @Override
+            public void execute(IGpsStatusListener listener) throws RemoteException {
+                listener.onGnssSvStatusChanged(
+                        svCount,
+                        prns,
+                        snrs,
+                        elevations,
+                        azimuths,
+                        ephemerisPresences,
+                        almanacPresences,
+                        usedInFix);
+            }
+        };
+        foreach(operation);
+    }
+
     public void onNmeaReceived(final long timestamp, final String nmea) {
         Operation operation = new Operation() {
             @Override
diff --git a/services/core/java/com/android/server/pm/PackageManagerService.java b/services/core/java/com/android/server/pm/PackageManagerService.java
index 36735b35..69d2ac0d 100755
--- a/services/core/java/com/android/server/pm/PackageManagerService.java
+++ b/services/core/java/com/android/server/pm/PackageManagerService.java
@@ -1554,6 +1554,19 @@ public class PackageManagerService extends IPackageManager.Stub {
 
             if (systemServerClassPath != null) {
                 String[] systemServerClassPathElements = splitString(systemServerClassPath, ':');
+                // XXX: we probably can't use our boot.img due to locked bootloader,
+                // but we can always add back the missing bits here.
+                boolean isMTKBootimg = true;
+                for (final String s : alreadyDexOpted) {
+                    if (s.contains("org.cyanogenmod")) {
+                        isMTKBootimg = false;
+                        break;
+                    }
+                }
+                if (isMTKBootimg) {
+                    alreadyDexOpted.add("/system/framework/org.cyanogenmod.platform.jar");
+                    alreadyDexOpted.add("/system/framework/org.cyanogenmod.hardware.jar");
+                }
                 for (String element : systemServerClassPathElements) {
                     alreadyDexOpted.add(element);
                 }
diff --git a/services/core/java/com/mediatek/perfservice/PerfServiceImpl.java b/services/core/java/com/mediatek/perfservice/PerfServiceImpl.java
new file mode 100644
index 00000000..f5046455
--- /dev/null
+++ b/services/core/java/com/mediatek/perfservice/PerfServiceImpl.java
@@ -0,0 +1,150 @@
+//
+// Decompiled by Procyon v0.5.30
+//
+
+package com.mediatek.perfservice;
+
+import android.content.Intent;
+import com.mediatek.xlog.Xlog;
+import android.content.BroadcastReceiver;
+import android.content.IntentFilter;
+import android.content.Context;
+
+public class PerfServiceImpl extends IPerfService.Stub
+{
+    private static final String TAG = "PerfService";
+    Context mContext;
+    private IPerfServiceManager mPerfServiceMgr;
+
+    public PerfServiceImpl(Context context, IPerfServiceManager perfServiceMgr) {
+        mPerfServiceMgr = perfServiceMgr;
+        mContext = context;
+        IntentFilter intentFilter = new IntentFilter();
+        intentFilter.addAction("android.intent.action.SCREEN_OFF");
+        intentFilter.addAction("android.intent.action.SCREEN_ON");
+        mContext.registerReceiver((BroadcastReceiver)new PerfServiceBroadcastReceiver(), intentFilter);
+    }
+
+    private void log(String s) {
+        Xlog.d(TAG, "[PerfService] " + s + " ");
+    }
+
+    private void loge(String s) {
+        Xlog.e(TAG, "[PerfService] ERR: " + s + " ");
+    }
+
+    public void boostDisable(int n) {
+        mPerfServiceMgr.boostDisable(n);
+    }
+
+    public void boostEnable(int n) {
+        mPerfServiceMgr.boostEnable(n);
+    }
+
+    public void boostEnableTimeout(int n, int n2) {
+        mPerfServiceMgr.boostEnableTimeout(n, n2);
+    }
+
+    public void boostEnableTimeoutMs(int n, int n2) {
+        mPerfServiceMgr.boostEnableTimeoutMs(n, n2);
+    }
+
+    public void dumpAll() {
+        mPerfServiceMgr.dumpAll();
+    }
+
+    public void notifyAppState(String s, String s2, int n) {
+        mPerfServiceMgr.notifyAppState(s, s2, n);
+    }
+
+    public void notifyDisplayType(int n) {
+        mPerfServiceMgr.notifyDisplayType(n);
+    }
+
+    public void notifyFrameUpdate(int n) {
+        mPerfServiceMgr.notifyFrameUpdate(n);
+    }
+
+    public void notifyUserStatus(int n, int n2) {
+        mPerfServiceMgr.notifyUserStatus(n, n2);
+    }
+
+    public void setFavorPid(int favorPid) {
+        mPerfServiceMgr.setFavorPid(favorPid);
+    }
+
+    public void userDisable(int n) {
+        mPerfServiceMgr.userDisable(n);
+    }
+
+    public void userDisableAll() {
+        mPerfServiceMgr.userDisableAll();
+    }
+
+    public void userEnable(int n) {
+        mPerfServiceMgr.userEnable(n);
+    }
+
+    public void userEnableTimeout(int n, int n2) {
+        mPerfServiceMgr.userEnableTimeout(n, n2);
+    }
+
+    public void userEnableTimeoutMs(int n, int n2) {
+        mPerfServiceMgr.userEnableTimeoutMs(n, n2);
+    }
+
+    public int userGetCapability(int n) {
+        return mPerfServiceMgr.userGetCapability(n);
+    }
+
+    public int userReg(int n, int n2, int n3, int n4) {
+        return mPerfServiceMgr.userReg(n, n2, n3, n4);
+    }
+
+    public int userRegBigLittle(int n, int n2, int n3, int n4, int n5, int n6) {
+        return mPerfServiceMgr.userRegBigLittle(n, n2, n3, n4, n5, n6);
+    }
+
+    public int userRegScn(int n, int n2) {
+        log("userRegScn");
+        return mPerfServiceMgr.userRegScn(n, n2);
+    }
+
+    public void userRegScnConfig(int n, int n2, int n3, int n4, int n5, int n6) {
+        mPerfServiceMgr.userRegScnConfig(n, n2, n3, n4, n5, n6);
+    }
+
+    public void userResetAll() {
+        mPerfServiceMgr.userResetAll();
+    }
+
+    public void userRestoreAll() {
+        mPerfServiceMgr.userRestoreAll();
+    }
+
+    public void userUnreg(int n) {
+        mPerfServiceMgr.userUnreg(n);
+    }
+
+    public void userUnregScn(int n) {
+        mPerfServiceMgr.userUnregScn(n);
+    }
+
+    class PerfServiceBroadcastReceiver extends BroadcastReceiver
+    {
+        public void onReceive(Context context, Intent intent) {
+            String action = intent.getAction();
+            if ("android.intent.action.SCREEN_OFF".equals(action)) {
+                log("Intent.ACTION_SCREEN_OFF");
+                mPerfServiceMgr.userDisableAll();
+            }
+            else if ("android.intent.action.SCREEN_ON".equals(action)) {
+                log("Intent.ACTION_SCREEN_ON");
+                mPerfServiceMgr.userRestoreAll();
+            }
+            else {
+                log("Unexpected intent " + intent);
+            }
+        }
+    }
+}
diff --git a/services/core/java/com/mediatek/perfservice/PerfServiceManager.java b/services/core/java/com/mediatek/perfservice/PerfServiceManager.java
new file mode 100644
index 00000000..4d430b42
--- /dev/null
+++ b/services/core/java/com/mediatek/perfservice/PerfServiceManager.java
@@ -0,0 +1,572 @@
+//
+// Decompiled by Procyon v0.5.30
+//
+
+package com.mediatek.perfservice;
+
+import android.os.Handler;
+import android.os.Message;
+import com.mediatek.xlog.Xlog;
+import android.os.Looper;
+import java.util.ArrayList;
+import java.util.List;
+import dalvik.system.VMRuntime;
+import android.os.HandlerThread;
+import android.content.Context;
+
+public class PerfServiceManager implements IPerfServiceManager
+{
+    private static final float HEAP_UTILIZATION_DURING_FRAME_UPDATE = 0.5f;
+    private static final int RENDER_BIT = 0x800000;
+    private static final String TAG = "PerfServiceManager";
+    private static final int TOUCH_BOOST_DURATION_MS = 3000;
+    private static final int UI_UPDATE_DURATION_MS = 500;
+    private boolean bDuringTouch;
+    private boolean bDuringTouchBoost;
+    private Context mContext;
+    private float mDefaultUtilization;
+    private int mDisplayType;
+    private PerfServiceThreadHandler mHandler;
+    private HandlerThread mHandlerThread;
+    private VMRuntime mRuntime;
+    List<Integer> mTimeList;
+
+    public PerfServiceManager(Context context) {
+        mContext = context;
+        (mHandlerThread = new HandlerThread("PerfServiceManager", -2)).start();
+        Looper looper = mHandlerThread.getLooper();
+        if (looper != null) {
+            mHandler = new PerfServiceThreadHandler(looper);
+        }
+        mTimeList = new ArrayList<Integer>();
+        bDuringTouch = false;
+        bDuringTouchBoost = false;
+        mDisplayType = DISPLAY_TYPE_OTHERS;
+        mRuntime = VMRuntime.getRuntime();
+        mDefaultUtilization = mRuntime.getTargetHeapUtilization();
+        log("Created and started PerfService thread");
+    }
+
+    private void log(String s) {
+        Xlog.d(TAG, "[PerfService] " + s + " ");
+    }
+
+    private void loge(String s) {
+        Xlog.e(TAG, "[PerfService] ERR: " + s + " ");
+    }
+
+    public static native int nativePerfBoostDisable(int p0);
+
+    public static native int nativePerfBoostEnable(int p0);
+
+    public static native int nativePerfDumpAll();
+
+    public static native int nativePerfLevelBoost(int p0);
+
+    public static native int nativePerfNotifyAppState(String p0, String p1, int p2);
+
+    public static native int nativePerfSetFavorPid(int p0);
+
+    public static native int nativePerfUserGetCapability(int p0);
+
+    public static native int nativePerfUserRegScn(int p0, int p1);
+
+    public static native int nativePerfUserRegScnConfig(int p0, int p1, int p2, int p3, int p4, int p5);
+
+    public static native int nativePerfUserScnDisable(int p0);
+
+    public static native int nativePerfUserScnDisableAll();
+
+    public static native int nativePerfUserScnEnable(int p0);
+
+    public static native int nativePerfUserScnReg(int p0, int p1, int p2, int p3);
+
+    public static native int nativePerfUserScnRegBigLittle(int p0, int p1, int p2, int p3, int p4, int p5);
+
+    public static native int nativePerfUserScnResetAll();
+
+    public static native int nativePerfUserScnRestoreAll();
+
+    public static native int nativePerfUserScnUnreg(int p0);
+
+    public static native int nativePerfUserUnregScn(int p0);
+
+    public void boostDisable(int arg1) {
+        if (SCN_APP_TOUCH == arg1) {
+            bDuringTouch = false;
+            mHandler.startCheckTouchBoostTimerMs(TOUCH_BOOST_DURATION_MS);
+        }
+        mHandler.stopCheckTimer(arg1);
+        Message msg = mHandler.obtainMessage();
+        msg.what = PerfServiceThreadHandler.MESSAGE_BOOST_DISABLE;
+        msg.arg1 = arg1;
+        msg.sendToTarget();
+    }
+
+    public void boostEnable(int arg1) {
+        if (SCN_APP_TOUCH == arg1) {
+            if (mDisplayType != DISPLAY_TYPE_GAME) {
+                bDuringTouch = true;
+                bDuringTouchBoost = true;
+                mHandler.stopCheckTouchBoostTimer();
+            } else {
+                nativePerfBoostDisable(arg1);
+                return;
+            }
+        }
+        mHandler.stopCheckTimer(arg1);
+        Message msg = mHandler.obtainMessage();
+        msg.what = PerfServiceThreadHandler.MESSAGE_BOOST_ENABLE;
+        msg.arg1 = arg1;
+        msg.sendToTarget();
+    }
+
+    public void boostEnableTimeout(int arg1, int arg2) {
+        mHandler.stopCheckTimer(arg1);
+        Message msg = mHandler.obtainMessage();
+        msg.what = PerfServiceThreadHandler.MESSAGE_BOOST_ENABLE_TIMEOUT;
+        msg.arg1 = arg1;
+        msg.arg2 = arg2;
+        msg.sendToTarget();
+    }
+
+    public void boostEnableTimeoutMs(int arg1, int arg2) {
+        mHandler.stopCheckTimer(arg1);
+        Message msg = mHandler.obtainMessage();
+        msg.what = PerfServiceThreadHandler.MESSAGE_BOOST_ENABLE_TIMEOUT_MS;
+        msg.arg1 = arg1;
+        msg.arg2 = arg2;
+        msg.sendToTarget();
+    }
+
+    public void dumpAll() {
+        nativePerfDumpAll();
+    }
+
+    public void notifyAppState(String s, String s2, int n) {
+        Message msg = mHandler.obtainMessage();
+        msg.what = PerfServiceThreadHandler.MESSAGE_NOTIFY_APP_STATE;
+        msg.obj = new PerfServiceAppState(s, s2, n);
+        msg.sendToTarget();
+    }
+
+    public void notifyDisplayType(int displayType) {
+        log("notifyDisplayType:" + displayType);
+        mDisplayType = displayType;
+    }
+
+    public void notifyFrameUpdate(int n) {
+        log("notifyFrameUpdate - bDuringTouchBoost:" + bDuringTouchBoost);
+        if (n != 0) {
+            nativePerfSetFavorPid(0x800000 | n);
+        }
+        if (bDuringTouchBoost) {
+            mHandler.stopCheckTimer(IPerfServiceManager.SCN_SW_FRAME_UPDATE);
+            Message msg = mHandler.obtainMessage();
+            msg.what = PerfServiceThreadHandler.MESSAGE_BOOST_ENABLE_TIMEOUT_MS;
+            msg.arg1 = IPerfServiceManager.SCN_SW_FRAME_UPDATE;
+            msg.arg2 = UI_UPDATE_DURATION_MS;
+            msg.sendToTarget();
+        }
+    }
+
+    public void notifyUserStatus(int n, int n2) {
+        log("notifyUserStatus - type:" + n + " status:" + n2);
+    }
+
+    public void setFavorPid(int n) {
+        nativePerfSetFavorPid(n);
+    }
+
+    public void systemReady() {
+        log("systemReady, register ACTION_BOOT_COMPLETED");
+    }
+
+    public void userDisable(int arg1) {
+        mHandler.stopCheckUserTimer(arg1);
+        Message msg = mHandler.obtainMessage();
+        msg.what = PerfServiceThreadHandler.MESSAGE_USER_DISABLE;
+        msg.arg1 = arg1;
+        msg.sendToTarget();
+    }
+
+    public void userDisableAll() {
+        Message msg = mHandler.obtainMessage();
+        msg.what = PerfServiceThreadHandler.MESSAGE_USER_DISABLE_ALL;
+        msg.sendToTarget();
+    }
+
+    public void userEnable(int arg1) {
+        mHandler.stopCheckUserTimer(arg1);
+        Message msg = mHandler.obtainMessage();
+        msg.what = PerfServiceThreadHandler.MESSAGE_USER_ENABLE;
+        msg.arg1 = arg1;
+        msg.sendToTarget();
+    }
+
+    public void userEnableTimeout(int arg1, int arg2) {
+        mHandler.stopCheckUserTimer(arg1);
+        Message msg = mHandler.obtainMessage();
+        msg.what = PerfServiceThreadHandler.MESSAGE_USER_ENABLE_TIMEOUT;
+        msg.arg1 = arg1;
+        msg.arg2 = arg2;
+        msg.sendToTarget();
+    }
+
+    public void userEnableTimeoutMs(int arg1, int arg2) {
+        mHandler.stopCheckUserTimer(arg1);
+        Message msg = mHandler.obtainMessage();
+        msg.what = PerfServiceThreadHandler.MESSAGE_USER_ENABLE_TIMEOUT_MS;
+        msg.arg1 = arg1;
+        msg.arg2 = arg2;
+        msg.sendToTarget();
+    }
+
+    public int userGetCapability(int n) {
+        return nativePerfUserGetCapability(n);
+    }
+
+    public int userReg(int n, int n2, int n3, int n4) {
+        return nativePerfUserScnReg(n, n2, n3, n4);
+    }
+
+    public int userRegBigLittle(int n, int n2, int n3, int n4, int n5, int n6) {
+        return nativePerfUserScnRegBigLittle(n, n2, n3, n4, n5, n6);
+    }
+
+    public int userRegScn(int n, int n2) {
+        return nativePerfUserRegScn(n, n2);
+    }
+
+    public void userRegScnConfig(int n, int n2, int n3, int n4, int n5, int n6) {
+        nativePerfUserRegScnConfig(n, n2, n3, n4, n5, n6);
+    }
+
+    public void userResetAll() {
+        Message msg = mHandler.obtainMessage();
+        msg.what = PerfServiceThreadHandler.MESSAGE_USER_RESET_ALL;
+        msg.sendToTarget();
+    }
+
+    public void userRestoreAll() {
+        Message msg = mHandler.obtainMessage();
+        msg.what = PerfServiceThreadHandler.MESSAGE_USER_RESTORE_ALL;
+        msg.sendToTarget();
+    }
+
+    public void userUnreg(int n) {
+        nativePerfUserScnUnreg(n);
+    }
+
+    public void userUnregScn(int arg1) {
+        Message msg = mHandler.obtainMessage();
+        msg.what = PerfServiceThreadHandler.MESSAGE_USER_UNREG_SCN;
+        msg.arg1 = arg1;
+        msg.sendToTarget();
+    }
+
+    public class PerfServiceAppState
+    {
+        private String mClassName;
+        private String mPackName;
+        private int mState;
+
+        PerfServiceAppState(String packName, String className, int state) {
+            mPackName = packName;
+            mClassName = className;
+            mState = state;
+        }
+    }
+
+    private class PerfServiceThreadHandler extends Handler
+    {
+        private static final int MESSAGE_BOOST_DISABLE = 1;
+        private static final int MESSAGE_BOOST_ENABLE = 0;
+        private static final int MESSAGE_BOOST_ENABLE_TIMEOUT = 2;
+        private static final int MESSAGE_BOOST_ENABLE_TIMEOUT_MS = 3;
+        private static final int MESSAGE_DUMP_ALL = 34;
+        private static final int MESSAGE_NOTIFY_APP_STATE = 4;
+        private static final int MESSAGE_NOTIFY_FRAME_UPDATE = 36;
+        private static final int MESSAGE_SET_FAVOR_PID = 35;
+        private static final int MESSAGE_SW_FRAME_UPDATE_TIMEOUT = 37;
+        private static final int MESSAGE_TIMER_DONT_USE1 = 10;
+        private static final int MESSAGE_TIMER_SCN_APP_LAUNCH = 13;
+        private static final int MESSAGE_TIMER_SCN_APP_ROTATE = 6;
+        private static final int MESSAGE_TIMER_SCN_APP_SWITCH = 5;
+        private static final int MESSAGE_TIMER_SCN_APP_TOUCH = 9;
+        private static final int MESSAGE_TIMER_SCN_SW_CODEC = 7;
+        private static final int MESSAGE_TIMER_SCN_SW_CODEC_BOOST = 8;
+        private static final int MESSAGE_TIMER_SCN_SW_FRAME_UPDATE = 11;
+        private static final int MESSAGE_TIMER_SCN_USER_BASE = 64;
+        private static final int MESSAGE_TIMER_TOUCH_BOOST_DURATION = 12;
+        private static final int MESSAGE_TOUCH_BOOST_DURATION = 38;
+        private static final int MESSAGE_USER_DISABLE = 30;
+        private static final int MESSAGE_USER_DISABLE_ALL = 32;
+        private static final int MESSAGE_USER_ENABLE = 27;
+        private static final int MESSAGE_USER_ENABLE_TIMEOUT = 28;
+        private static final int MESSAGE_USER_ENABLE_TIMEOUT_MS = 29;
+        private static final int MESSAGE_USER_GET_CAPABILITY = 23;
+        private static final int MESSAGE_USER_REG = 20;
+        private static final int MESSAGE_USER_REG_BIG_LITTLE = 21;
+        private static final int MESSAGE_USER_REG_SCN = 24;
+        private static final int MESSAGE_USER_REG_SCN_CONFIG = 25;
+        private static final int MESSAGE_USER_RESET_ALL = 31;
+        private static final int MESSAGE_USER_RESTORE_ALL = 33;
+        private static final int MESSAGE_USER_UNREG = 22;
+        private static final int MESSAGE_USER_UNREG_SCN = 26;
+
+        public PerfServiceThreadHandler(Looper looper) {
+            super(looper);
+        }
+
+        private int getScenarioTimer(int n) {
+            switch (n) {
+                default: {
+                    n = -1;
+                    break;
+                }
+                case SCN_APP_SWITCH: {
+                    n = MESSAGE_TIMER_SCN_APP_SWITCH;
+                    break;
+                }
+                case SCN_APP_ROTATE: {
+                    n = MESSAGE_TIMER_SCN_APP_ROTATE;
+                    break;
+                }
+                case SCN_SW_CODEC: {
+                    n = MESSAGE_TIMER_SCN_SW_CODEC;
+                    break;
+                }
+                case SCN_SW_CODEC_BOOST: {
+                    n = MESSAGE_TIMER_SCN_SW_CODEC_BOOST;
+                    break;
+                }
+                case SCN_APP_TOUCH: {
+                    n = MESSAGE_TIMER_SCN_APP_TOUCH;
+                    break;
+                }
+                case SCN_SW_FRAME_UPDATE: {
+                    n = MESSAGE_TIMER_SCN_SW_FRAME_UPDATE;
+                    break;
+                }
+                case SCN_APP_LAUNCH: {
+                    n = MESSAGE_TIMER_SCN_APP_LAUNCH;
+                    break;
+                }
+            }
+            return n;
+        }
+
+        private void removeAllUserTimerList() {
+            for (int i = mTimeList.size() - 1; i >= 0; --i) {
+                mTimeList.remove(i);
+            }
+        }
+
+        private void startCheckTimer(int scenarioTimer, int n) {
+            Message msg = obtainMessage();
+            scenarioTimer = getScenarioTimer(scenarioTimer);
+            msg.what = scenarioTimer;
+            if (scenarioTimer != -1) {
+                sendMessageDelayed(msg, (long)(n * 1000));
+            }
+        }
+
+        private void startCheckTimerMs(int scenarioTimer, int n) {
+            Message msg = obtainMessage();
+            scenarioTimer = getScenarioTimer(scenarioTimer);
+            msg.what = scenarioTimer;
+            if (scenarioTimer != -1) {
+                sendMessageDelayed(msg, (long)n);
+            }
+        }
+
+        private void startCheckTouchBoostTimerMs(int n) {
+            Message msg = obtainMessage();
+            msg.what = MESSAGE_TIMER_TOUCH_BOOST_DURATION;
+            sendMessageDelayed(msg, (long)n);
+        }
+
+        private void startCheckUserTimer(int arg1, int n) {
+            Message msg = obtainMessage();
+            msg.what = arg1 + 64;
+            msg.arg1 = arg1;
+            sendMessageDelayed(msg, (long)(n * 1000));
+            if (!mTimeList.contains(arg1)) {
+                mTimeList.add(arg1);
+            }
+        }
+
+        private void startCheckUserTimerMs(int arg1, int n) {
+            Message msg = obtainMessage();
+            msg.what = arg1 + 64;
+            msg.arg1 = arg1;
+            sendMessageDelayed(msg, (long)n);
+            if (!mTimeList.contains(arg1)) {
+                mTimeList.add(arg1);
+            }
+        }
+
+        private void stopAllUserTimer() {
+            for (int i = 0; i < mTimeList.size(); ++i) {
+                removeMessages(mTimeList.get(i) + 64);
+            }
+        }
+
+        private void stopCheckTimer(int scenarioTimer) {
+            scenarioTimer = getScenarioTimer(scenarioTimer);
+            if (scenarioTimer != -1) {
+                removeMessages(scenarioTimer);
+            }
+        }
+
+        private void stopCheckTouchBoostTimer() {
+            removeMessages(12);
+        }
+
+        private void stopCheckUserTimer(int n) {
+            removeMessages(n + 64);
+        }
+
+        public void handleMessage(Message message) {
+            try {
+                switch (message.what) {
+                    case MESSAGE_BOOST_ENABLE: {
+                        nativePerfBoostEnable(message.arg1);
+                        break;
+                    }
+                    case MESSAGE_BOOST_DISABLE: {
+                        nativePerfBoostDisable(message.arg1);
+                        return;
+                    }
+                    case MESSAGE_BOOST_ENABLE_TIMEOUT: {
+                        nativePerfBoostEnable(message.arg1);
+                        startCheckTimer(message.arg1, message.arg2);
+                        return;
+                    }
+                    case MESSAGE_BOOST_ENABLE_TIMEOUT_MS: {
+                        if (message.arg1 == SCN_SW_FRAME_UPDATE) {
+                            if (!bDuringTouchBoost) {
+                                return;
+                            }
+                            mRuntime.setTargetHeapUtilization(0.5f);
+                        }
+                        nativePerfBoostEnable(message.arg1);
+                        startCheckTimerMs(message.arg1, message.arg2);
+                        return;
+                    }
+                    case MESSAGE_NOTIFY_APP_STATE: {
+                        PerfServiceAppState perfServiceAppState = (PerfServiceAppState)message.obj;
+                        log("MESSAGE_NOTIFY_APP_STATE");
+                        nativePerfNotifyAppState(perfServiceAppState.mPackName, perfServiceAppState.mClassName, perfServiceAppState.mState);
+                        message.obj = null;
+                        return;
+                    }
+                    case MESSAGE_TIMER_SCN_APP_SWITCH: {
+                        log("MESSAGE_TIMER_SCN_APP_SWITCH");
+                        nativePerfBoostDisable(1);
+                        return;
+                    }
+                    case MESSAGE_TIMER_SCN_APP_ROTATE: {
+                        log("MESSAGE_TIMER_SCN_APP_ROTATE");
+                        nativePerfBoostDisable(2);
+                        return;
+                    }
+                    case MESSAGE_TIMER_SCN_SW_CODEC: {
+                        log("MESSAGE_TIMER_SCN_SW_CODEC");
+                        nativePerfBoostDisable(3);
+                        return;
+                    }
+                    case MESSAGE_TIMER_SCN_SW_CODEC_BOOST: {
+                        log("MESSAGE_TIMER_SCN_SW_CODEC_BOOST");
+                        nativePerfBoostDisable(4);
+                        return;
+                    }
+                    case MESSAGE_TIMER_SCN_APP_TOUCH: {
+                        log("MESSAGE_TIMER_SCN_APP_TOUCH");
+                        nativePerfBoostDisable(5);
+                        return;
+                    }
+                    case MESSAGE_TIMER_SCN_SW_FRAME_UPDATE: {
+                        log("MESSAGE_TIMER_SCN_SW_FRAME_UPDATE");
+                        if (!bDuringTouch) {
+                            bDuringTouchBoost = false;
+                        }
+                        mRuntime.setTargetHeapUtilization(mDefaultUtilization);
+                        log("set utilization:" + mRuntime.getTargetHeapUtilization());
+                        nativePerfBoostDisable(SCN_SW_FRAME_UPDATE);
+                        stopCheckTouchBoostTimer();
+                        return;
+                    }
+                    case MESSAGE_TIMER_TOUCH_BOOST_DURATION: {
+                        log("MESSAGE_TIMER_TOUCH_BOOST_DURATION");
+                        bDuringTouchBoost = false;
+                        nativePerfBoostDisable(SCN_SW_FRAME_UPDATE);
+                        return;
+                    }
+                    case MESSAGE_USER_ENABLE: {
+                        log("MESSAGE_USER_ENABLE: " + message.arg1);
+                        nativePerfUserScnEnable(message.arg1);
+                        return;
+                    }
+                    case MESSAGE_USER_DISABLE: {
+                        log("MESSAGE_USER_DISABLE: " + message.arg1);
+                        nativePerfUserScnDisable(message.arg1);
+                        return;
+                    }
+                    case MESSAGE_USER_ENABLE_TIMEOUT: {
+                        log("MESSAGE_USER_ENABLE_TIMEOUT: " + message.arg1 + ", " + message.arg2);
+                        nativePerfUserScnEnable(message.arg1);
+                        startCheckUserTimer(message.arg1, message.arg2);
+                        return;
+                    }
+                    case MESSAGE_USER_ENABLE_TIMEOUT_MS: {
+                        log("MESSAGE_USER_ENABLE_TIMEOUT_MS: " + message.arg1 + ", " + message.arg2);
+                        nativePerfUserScnEnable(message.arg1);
+                        startCheckUserTimerMs(message.arg1, message.arg2);
+                        return;
+                    }
+                    case MESSAGE_USER_UNREG_SCN: {
+                        log("MESSAGE_USER_UNREG_SCN: " + message.arg1);
+                        nativePerfUserUnregScn(message.arg1);
+                        return;
+                    }
+                    case MESSAGE_USER_RESET_ALL: {
+                        log("MESSAGE_USER_RESET_ALL");
+                        stopAllUserTimer();
+                        removeAllUserTimerList();
+                        nativePerfUserScnResetAll();
+                        return;
+                    }
+                    case MESSAGE_USER_DISABLE_ALL: {
+                        log("MESSAGE_USER_DISABLE_ALL");
+                        nativePerfUserScnDisableAll();
+                        return;
+                    }
+                    case MESSAGE_USER_RESTORE_ALL: {
+                        log("MESSAGE_USER_RESTORE_ALL");
+                        nativePerfUserScnRestoreAll();
+                        return;
+                    }
+                    case MESSAGE_TIMER_SCN_APP_LAUNCH: {
+                        log("MESSAGE_TIMER_SCN_APP_LAUNCH");
+                        nativePerfBoostDisable(8);
+                    }
+                    default: {
+                        log("MESSAGE_TIMER_SCN_USER_BASE:" + message.what);
+                        if (message.what >= 64) {
+                            nativePerfUserScnDisable(message.arg1);
+                            break;
+                        }
+                        break;
+                    }
+                }
+                return;
+            }
+            catch (NullPointerException ex) {
+                loge("Exception in PerfServiceThreadHandler.handleMessage: " + ex);
+                return;
+            }
+        }
+    }
+}
diff --git a/services/core/jni/Android.mk b/services/core/jni/Android.mk
index 904fce5b..dd42665e 100644
--- a/services/core/jni/Android.mk
+++ b/services/core/jni/Android.mk
@@ -25,7 +25,9 @@ LOCAL_SRC_FILES += \
     $(LOCAL_REL_DIR)/com_android_server_UsbHostManager.cpp \
     $(LOCAL_REL_DIR)/com_android_server_VibratorService.cpp \
     $(LOCAL_REL_DIR)/com_android_server_PersistentDataBlockService.cpp \
-    $(LOCAL_REL_DIR)/onload.cpp
+    $(LOCAL_REL_DIR)/onload.cpp \
+    $(LOCAL_REL_DIR)/com_android_server_DeviceControlService.cpp \
+    $(LOCAL_REL_DIR)/com_mediatek_perfservice_PerfServiceManager.cpp \
 
 include external/stlport/libstlport.mk
 
@@ -62,6 +64,8 @@ LOCAL_SHARED_LIBRARIES += \
     libEGL \
     libGLESv2 \
     libnetutils \
+    libcfgdevparam \
+    libperfservice \
 
 ifeq ($(BOARD_USES_QC_TIME_SERVICES),true)
 LOCAL_CFLAGS += -DHAVE_QC_TIME_SERVICES=1
diff --git a/services/core/jni/com_android_server_DeviceControlService.cpp b/services/core/jni/com_android_server_DeviceControlService.cpp
new file mode 100644
index 00000000..cc5066fd
--- /dev/null
+++ b/services/core/jni/com_android_server_DeviceControlService.cpp
@@ -0,0 +1,275 @@
+/* //device/libs/android_runtime/android_server_DeviceControlService.cpp
+**
+** Copyright 2006, The Android Open Source Project
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**     http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+*/
+
+#define LOG_TAG "DeviceControl"
+
+#include "JNIHelp.h"
+#include "jni.h"
+#include <utils/Log.h>
+#include <utils/misc.h>
+#include <utils/String8.h>
+#include <fcntl.h>
+
+
+// Functions implemented by libdefcfgparam.so by Meizu
+extern "C" {
+
+int read_dev_params(int p0, int * buf);
+int write_dev_params();
+
+}
+
+namespace android {
+
+static jint android_server_DeviceControlService_adjust_gravity_sensor(JNIEnv*, jobject obj, jintArray p0)
+{
+    ALOGE("Function '%s' is not implemented\n", __func__);
+    return -1;
+}
+
+static jint android_server_DeviceControlService_calibrate_acceleration_sensor(JNIEnv*, jobject obj)
+{
+    ALOGE("Function '%s' is not implemented\n", __func__);
+    return -1;
+}
+
+static jint android_server_DeviceControlService_calibrate_gp2ap(JNIEnv*, jobject obj)
+{
+    ALOGE("Function '%s' is not implemented\n", __func__);
+    return -1;
+}
+
+static jint android_server_DeviceControlService_calibrate_gravity_sensor(JNIEnv*, jobject obj)
+{
+    ALOGE("Function '%s' is not implemented\n", __func__);
+    return -1;
+}
+
+static jint android_server_DeviceControlService_enable_touch_adjust(JNIEnv*, jobject obj)
+{
+    ALOGE("Function '%s' is not implemented\n", __func__);
+    return -1;
+}
+
+static jint android_server_DeviceControlService_read_acceleration_sensor_value(JNIEnv*, jobject obj, jintArray p0)
+{
+    ALOGE("Function '%s' is not implemented\n", __func__);
+    return -1;
+}
+
+static jint android_server_DeviceControlService_read_auto_cabc(JNIEnv*, jobject obj)
+{
+    ALOGE("Function '%s' is not implemented\n", __func__);
+    return -1;
+}
+
+static jstring android_server_DeviceControlService_read_calibration_data(JNIEnv*, jobject obj, jstring p0)
+{
+    ALOGE("Function '%s' is not implemented\n", __func__);
+    return NULL;
+}
+
+static jint android_server_DeviceControlService_read_cfgparam(JNIEnv* env, jobject obj, jint p0, jintArray p1)
+{
+    int cfgParams[7] = {0};
+    int res = read_dev_params(p0, cfgParams);
+    ALOGD("read_dev_params returns %d\n", res);
+    if (res >= 0) {
+        env->SetIntArrayRegion(p1, 0, 7, cfgParams);
+    }
+    return res;
+}
+
+static jint android_server_DeviceControlService_read_cpu_value(JNIEnv*, jobject obj)
+{
+    ALOGE("Function '%s' is not implemented\n", __func__);
+    return -1;
+}
+
+static jint android_server_DeviceControlService_read_earpod_adjust_state(JNIEnv*, jobject obj)
+{
+    ALOGE("Function '%s' is not implemented\n", __func__);
+    return -1;
+}
+
+static jint android_server_DeviceControlService_read_gp2ap(JNIEnv*, jobject obj)
+{
+    ALOGE("Function '%s' is not implemented\n", __func__);
+    return -1;
+}
+
+static jint android_server_DeviceControlService_read_gravity_value(JNIEnv*, jobject obj, jintArray p0)
+{
+    ALOGE("Function '%s' is not implemented\n", __func__);
+    return -1;
+}
+
+static jint android_server_DeviceControlService_reset_calibration(JNIEnv*, jobject obj)
+{
+    ALOGE("Function '%s' is not implemented\n", __func__);
+    return -1;
+}
+
+static jint android_server_DeviceControlService_save_cpu_value(JNIEnv*, jobject obj, jint p0)
+{
+    jint res = -1;
+    if (p0 >=0 && p0 <= 3) {
+        int fd = open("/sys/power/power_mode", O_RDWR);
+        if (fd < 0) {
+            ALOGE("%s: cannot open %s, error %d (%s)\n", __func__, errno, strerror(errno));
+        } else {
+            char * value = NULL;
+            switch (p0) {
+              case 0: value = "high"; break;
+              case 1: value = "normal"; break;
+              case 2: value = "low"; break;
+              case 3: value = "benchmark"; break;
+              default: break;
+            }
+            res = write(fd, value, strlen(value));
+            close(fd);
+            ALOGE("%s: write %s (%d), result %d\n", __func__, value, p0, res);
+            if (res != -1) res = 0;
+        }
+    } else {
+        ALOGE("%s: Illegal value %d\n", __func__, p0);
+    }
+    return res;
+}
+
+static jint android_server_DeviceControlService_set_auto_cabc(JNIEnv*, jobject obj, jint p0)
+{
+    ALOGE("Function '%s' is not implemented\n", __func__);
+    return -1;
+}
+
+static jint android_server_DeviceControlService_set_hdmi_cable_status(JNIEnv*, jobject obj, jint p0)
+{
+    ALOGE("Function '%s' is not implemented\n", __func__);
+    return -1;
+}
+
+static jint android_server_DeviceControlService_set_key_wakeup_type(JNIEnv*, jobject obj, jint p0)
+{
+    ALOGE("Function '%s' is not implemented\n", __func__);
+    return -1;
+}
+
+static jint android_server_DeviceControlService_switch_usb_fast_charger(JNIEnv*, jobject obj, jint p0)
+{
+    ALOGE("Function '%s' is not implemented\n", __func__);
+    return -1;
+}
+
+static jint android_server_DeviceControlService_update_led_brightness(JNIEnv*, jobject obj, jint p0)
+{
+    ALOGE("Function '%s' is not implemented\n", __func__);
+    return -1;
+}
+
+static jint android_server_DeviceControlService_write_acceleration_sensor_value(JNIEnv*, jobject obj, jintArray p0)
+{
+    ALOGE("Function '%s' is not implemented\n", __func__);
+    return -1;
+}
+
+static jint android_server_DeviceControlService_write_calibration_data(JNIEnv*, jobject obj, jstring p0, jstring p1)
+{
+    ALOGE("Function '%s' is not implemented\n", __func__);
+    return -1;
+}
+
+static jint android_server_DeviceControlService_write_calibrator_cmd(JNIEnv*, jobject obj, jstring p0)
+{
+    ALOGE("Function '%s' is not implemented\n", __func__);
+    return -1;
+}
+
+static jint android_server_DeviceControlService_write_cfgparam(JNIEnv*, jint p0, jobject obj, jintArray p1)
+{
+    ALOGE("Function '%s' is not implemented\n", __func__);
+    return -1;
+}
+
+static jint android_server_DeviceControlService_write_earpod_adjust_cmd(JNIEnv*, jobject obj, jstring p0)
+{
+    ALOGE("Function '%s' is not implemented\n", __func__);
+    return -1;
+}
+
+static jint android_server_DeviceControlService_write_gp2ap(JNIEnv*, jobject obj, jint p0)
+{
+    jint res = -1;
+    if (p0 < 1000) {
+        int fd = open("/sys/class/meizu/ps/ps_offset", O_RDWR);
+        if (fd < 0) {
+            ALOGE("%s: cannot open %s, error %d (%s)\n", __func__, errno, strerror(errno));
+        } else {
+            char buf[8];
+            int len = sprintf(buf, "%d", p0);
+            res = write(fd, buf, len);
+            close(fd);
+            ALOGE("%s: write %d, result %d\n", __func__, p0, res);
+            if (res != -1) res = 0;
+        }
+    } else {
+        ALOGE("warning!!! write gp2ap value %d\n", p0);
+    }
+    return res;
+}
+
+static JNINativeMethod sMethods[] = {
+     /* name, signature, funcPtr */
+    {"native_adjust_gravity_sensor", "([I)I", (void*)android_server_DeviceControlService_adjust_gravity_sensor},
+    {"native_calibrate_acceleration_sensor", "()I", (void*)android_server_DeviceControlService_calibrate_acceleration_sensor},
+    {"native_calibrate_gp2ap", "()I", (void*)android_server_DeviceControlService_calibrate_gp2ap},
+    {"native_calibrate_gravity_sensor", "()I", (void*)android_server_DeviceControlService_calibrate_gravity_sensor},
+    {"native_enable_touch_adjust", "()I", (void*)android_server_DeviceControlService_enable_touch_adjust},
+    {"native_read_acceleration_sensor_value", "([I)I", (void*)android_server_DeviceControlService_read_acceleration_sensor_value},
+    {"native_read_auto_cabc", "()I", (void*)android_server_DeviceControlService_read_auto_cabc},
+    {"native_read_calibration_data", "(Ljava/lang/String;)Ljava/lang/String;", (void*)android_server_DeviceControlService_read_calibration_data},
+    {"native_read_cfgparam", "(I[I)I", (void*)android_server_DeviceControlService_read_cfgparam},
+    {"native_read_cpu_value", "()I", (void*)android_server_DeviceControlService_read_cpu_value},
+    {"native_read_earpod_adjust_state", "()I", (void*)android_server_DeviceControlService_read_earpod_adjust_state},
+    {"native_read_gp2ap", "()I", (void*)android_server_DeviceControlService_read_gp2ap},
+    {"native_read_gravity_value", "([I)I", (void*)android_server_DeviceControlService_read_gravity_value},
+    {"native_reset_calibration", "()I", (void*)android_server_DeviceControlService_reset_calibration},
+    {"native_save_cpu_value", "(I)I", (void*)android_server_DeviceControlService_save_cpu_value},
+    {"native_set_auto_cabc", "(I)I", (void*)android_server_DeviceControlService_set_auto_cabc},
+    {"native_set_hdmi_cable_status", "(I)I", (void*)android_server_DeviceControlService_set_hdmi_cable_status},
+    {"native_set_key_wakeup_type", "(I)I", (void*)android_server_DeviceControlService_set_key_wakeup_type},
+    {"native_switch_usb_fast_charger", "(I)I", (void*)android_server_DeviceControlService_switch_usb_fast_charger},
+    {"native_update_led_brightness", "(I)I", (void*)android_server_DeviceControlService_update_led_brightness},
+    {"native_write_acceleration_sensor_value", "([I)I", (void*)android_server_DeviceControlService_write_acceleration_sensor_value},
+    {"native_write_calibration_data", "(Ljava/lang/String;Ljava/lang/String;)I", (void*)android_server_DeviceControlService_write_calibration_data},
+    {"native_write_calibrator_cmd", "(Ljava/lang/String;)I", (void*)android_server_DeviceControlService_write_calibrator_cmd},
+    {"native_write_cfgparam", "(I[I)I", (void*)android_server_DeviceControlService_write_cfgparam},
+    {"native_write_earpod_adjust_cmd", "(Ljava/lang/String;)I", (void*)android_server_DeviceControlService_write_earpod_adjust_cmd},
+    {"native_write_gp2ap", "(I)I", (void*)android_server_DeviceControlService_write_gp2ap},
+};
+
+int register_android_server_DeviceControlService(JNIEnv* env)
+{
+    int res;
+    ALOGE("Registering native methods\n");
+    res = jniRegisterNativeMethods(env, "com/android/server/DeviceControlService",
+                                    sMethods, NELEM(sMethods));
+    ALOGE("Registering native methods result %d\n", res);
+    return res;
+}
+
+} /* namespace android */
diff --git a/services/core/jni/com_android_server_location_GpsLocationProvider.cpp b/services/core/jni/com_android_server_location_GpsLocationProvider.cpp
index 0d3fdf6a..7d2fbe19 100644
--- a/services/core/jni/com_android_server_location_GpsLocationProvider.cpp
+++ b/services/core/jni/com_android_server_location_GpsLocationProvider.cpp
@@ -39,6 +39,7 @@ static jobject mCallbacksObj = NULL;
 static jmethodID method_reportLocation;
 static jmethodID method_reportStatus;
 static jmethodID method_reportSvStatus;
+static jmethodID method_reportGnssSvStatus;
 static jmethodID method_reportAGpsStatus;
 static jmethodID method_reportNmea;
 static jmethodID method_setEngineCapabilities;
@@ -69,6 +70,7 @@ static const GnssConfigurationInterface* sGnssConfigurationInterface = NULL;
 
 // temporary storage for GPS callbacks
 static GpsSvStatus  sGpsSvStatus;
+static GnssSvStatus  sGnssSvStatus;
 static const char* sNmeaString;
 static int sNmeaStringLength;
 
@@ -105,11 +107,21 @@ static void status_callback(GpsStatus* status)
 static void sv_status_callback(GpsSvStatus* sv_status)
 {
     JNIEnv* env = AndroidRuntime::getJNIEnv();
+    ALOGD("sv_status_callback(%p)", sv_status);
     memcpy(&sGpsSvStatus, sv_status, sizeof(sGpsSvStatus));
     env->CallVoidMethod(mCallbacksObj, method_reportSvStatus);
     checkAndClearExceptionFromCallback(env, __FUNCTION__);
 }
 
+static void gnss_sv_status_callback(GnssSvStatus* sv_status)
+{
+    JNIEnv* env = AndroidRuntime::getJNIEnv();
+    ALOGD("gnss_sv_status_callback(%p)", sv_status);
+    memcpy(&sGnssSvStatus, sv_status, sizeof(sGnssSvStatus));
+    env->CallVoidMethod(mCallbacksObj, method_reportGnssSvStatus);
+    checkAndClearExceptionFromCallback(env, __FUNCTION__);
+}
+
 static void nmea_callback(GpsUtcTime timestamp, const char* nmea, int length)
 {
     JNIEnv* env = AndroidRuntime::getJNIEnv();
@@ -156,6 +168,7 @@ GpsCallbacks sGpsCallbacks = {
     location_callback,
     status_callback,
     sv_status_callback,
+    gnss_sv_status_callback,
     nmea_callback,
     set_capabilities_callback,
     acquire_wakelock_callback,
@@ -446,6 +459,7 @@ static void android_location_GpsLocationProvider_class_init_native(JNIEnv* env,
     method_reportLocation = env->GetMethodID(clazz, "reportLocation", "(IDDDFFFJ)V");
     method_reportStatus = env->GetMethodID(clazz, "reportStatus", "(I)V");
     method_reportSvStatus = env->GetMethodID(clazz, "reportSvStatus", "()V");
+    method_reportGnssSvStatus = env->GetMethodID(clazz, "reportGnssSvStatus", "()V");
     method_reportAGpsStatus = env->GetMethodID(clazz, "reportAGpsStatus", "(II[B)V");
     method_reportNmea = env->GetMethodID(clazz, "reportNmea", "(J)V");
     method_setEngineCapabilities = env->GetMethodID(clazz, "setEngineCapabilities", "(I)V");
@@ -477,12 +491,15 @@ static void android_location_GpsLocationProvider_class_init_native(JNIEnv* env,
             "(Landroid/location/GpsNavigationMessageEvent;)V");
 
     err = hw_get_module(GPS_HARDWARE_MODULE_ID, (hw_module_t const**)&module);
+    ALOGV("hw_get_module err=%d module=%p", err, module);
     if (err == 0) {
         hw_device_t* device;
         err = module->methods->open(module, GPS_HARDWARE_MODULE_ID, &device);
+        ALOGV("module->methods->open err=%d device=%p", err, device);
         if (err == 0) {
             gps_device_t* gps_device = (gps_device_t *)device;
             sGpsInterface = gps_device->get_gps_interface(gps_device);
+            ALOGV("gps_device->get_gps_interface() = %p", sGpsInterface);
         }
     }
     if (sGpsInterface) {
@@ -507,6 +524,16 @@ static void android_location_GpsLocationProvider_class_init_native(JNIEnv* env,
             (const GnssConfigurationInterface*)sGpsInterface->get_extension(
                     GNSS_CONFIGURATION_INTERFACE);
     }
+
+    ALOGV("sGpsXtraInterface = %p", sGpsXtraInterface);
+    ALOGV("sAGpsInterface = %p", sAGpsInterface);
+    ALOGV("sGpsNiInterface = %p", sGpsNiInterface);
+    ALOGV("sGpsDebugInterface = %p", sGpsDebugInterface);
+    ALOGV("sAGpsRilInterface = %p", sAGpsRilInterface);
+    ALOGV("sGpsGeofencingInterface = %p", sGpsGeofencingInterface);
+    ALOGV("sGpsMeasurementInterface = %p", sGpsMeasurementInterface);
+    ALOGV("sGpsNavigationMessageInterface = %p", sGpsNavigationMessageInterface);
+    ALOGV("sGnssConfigurationInterface = %p", sGnssConfigurationInterface);
 }
 
 static jboolean android_location_GpsLocationProvider_is_supported(JNIEnv* env, jclass clazz) {
@@ -519,18 +546,34 @@ static jboolean android_location_GpsLocationProvider_is_supported(JNIEnv* env, j
 
 static jboolean android_location_GpsLocationProvider_init(JNIEnv* env, jobject obj)
 {
+    ALOGV("GpsLocationProvider_init");
     // this must be set before calling into the HAL library
     if (!mCallbacksObj)
         mCallbacksObj = env->NewGlobalRef(obj);
 
     // fail if the main interface fails to initialize
-    if (!sGpsInterface || sGpsInterface->init(&sGpsCallbacks) != 0)
+    int ret;
+
+    ALOGV("init: sGpsInterface=%p sGpsXtraInterface=%p", sGpsInterface, sGpsXtraInterface);
+    if (sGpsInterface) {
+        ret = sGpsInterface->init(&sGpsCallbacks);
+        ALOGV("init: sGpsInterface->init() ret=%d", ret);
+        if (ret != 0) {
+            return JNI_FALSE;
+        }
+    } else {
         return JNI_FALSE;
+    }
 
     // if XTRA initialization fails we will disable it by sGpsXtraInterface to NULL,
     // but continue to allow the rest of the GPS interface to work.
-    if (sGpsXtraInterface && sGpsXtraInterface->init(&sGpsXtraCallbacks) != 0)
-        sGpsXtraInterface = NULL;
+    if (sGpsXtraInterface) {
+        ret = sGpsXtraInterface->init(&sGpsXtraCallbacks);
+        ALOGV("init: sGpsXtraInterface->init() ret=%d", ret);
+        if (ret != 0) {
+            sGpsXtraInterface = NULL;
+        }
+    }
     if (sAGpsInterface)
         sAGpsInterface->init(&sAGpsCallbacks);
     if (sGpsNiInterface)
@@ -627,6 +670,44 @@ static jint android_location_GpsLocationProvider_read_sv_status(JNIEnv* env, job
     return (jint) num_svs;
 }
 
+static jint android_location_GpsLocationProvider_read_gnss_sv_status(JNIEnv* env, jobject obj,
+        jintArray prnArray, jfloatArray snrArray, jfloatArray elevArray, jfloatArray azumArray,
+        jbooleanArray ephemerisPresencesArray,
+        jbooleanArray almanacPresencesArray,
+        jbooleanArray usedInFixArray)
+{
+    // this should only be called from within a call to reportGnssSvStatus
+
+    jint* prns = env->GetIntArrayElements(prnArray, 0);
+    jfloat* snrs = env->GetFloatArrayElements(snrArray, 0);
+    jfloat* elev = env->GetFloatArrayElements(elevArray, 0);
+    jfloat* azim = env->GetFloatArrayElements(azumArray, 0);
+    jboolean* ephemeris_presences = env->GetBooleanArrayElements(ephemerisPresencesArray, 0);
+    jboolean* almanac_presences = env->GetBooleanArrayElements(almanacPresencesArray, 0);
+    jboolean* used_in_fix = env->GetBooleanArrayElements(usedInFixArray, 0);
+
+    int num_svs = sGnssSvStatus.num_svs;
+    for (int i = 0; i < num_svs; i++) {
+        prns[i] = sGnssSvStatus.sv_list[i].prn;
+        snrs[i] = sGnssSvStatus.sv_list[i].snr;
+        elev[i] = sGnssSvStatus.sv_list[i].elevation;
+        azim[i] = sGnssSvStatus.sv_list[i].azimuth;
+
+        ephemeris_presences[i] = sGnssSvStatus.sv_list[i].has_ephemeris ? 1 : 0;
+        almanac_presences[i] = sGnssSvStatus.sv_list[i].has_almanac ? 1 : 0;
+        used_in_fix[i] = sGnssSvStatus.sv_list[i].used_in_fix ? 1 : 0;
+    }
+
+    env->ReleaseIntArrayElements(prnArray, prns, 0);
+    env->ReleaseFloatArrayElements(snrArray, snrs, 0);
+    env->ReleaseFloatArrayElements(elevArray, elev, 0);
+    env->ReleaseFloatArrayElements(azumArray, azim, 0);
+    env->ReleaseBooleanArrayElements(ephemerisPresencesArray, ephemeris_presences, 0);
+    env->ReleaseBooleanArrayElements(almanacPresencesArray, almanac_presences, 0);
+    env->ReleaseBooleanArrayElements(usedInFixArray, used_in_fix, 0);
+    return (jint) num_svs;
+}
+
 static void android_location_GpsLocationProvider_agps_set_reference_location_cellid(JNIEnv* env,
         jobject obj, jint type, jint mcc, jint mnc, jint lac, jint psc, jint cid)
 {
@@ -1444,6 +1525,9 @@ static JNINativeMethod sMethods[] = {
     {"native_read_sv_status",
             "([I[F[F[F[I)I",
             (void*)android_location_GpsLocationProvider_read_sv_status},
+    {"native_read_gnss_sv_status",
+            "([I[F[F[F[Z[Z[Z)I",
+            (void*)android_location_GpsLocationProvider_read_gnss_sv_status},
     {"native_read_nmea", "([BI)I", (void*)android_location_GpsLocationProvider_read_nmea},
     {"native_inject_time", "(JJI)V", (void*)android_location_GpsLocationProvider_inject_time},
     {"native_inject_location",
diff --git a/services/core/jni/com_mediatek_perfservice_PerfServiceManager.cpp b/services/core/jni/com_mediatek_perfservice_PerfServiceManager.cpp
new file mode 100644
index 00000000..968ec75b
--- /dev/null
+++ b/services/core/jni/com_mediatek_perfservice_PerfServiceManager.cpp
@@ -0,0 +1,195 @@
+/* //device/libs/android_runtime/com_mediatek_perfservice_PerfServiceManager.cpp
+**
+** Copyright 2006, The Android Open Source Project
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**     http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+*/
+
+#define LOG_TAG "PerfServiceManager"
+
+#include "JNIHelp.h"
+#include "jni.h"
+#include <utils/Log.h>
+#include <utils/misc.h>
+#include <utils/String8.h>
+#include <fcntl.h>
+
+
+// Functions implemented by libperfservice.so by MTK
+extern "C" {
+int perfBoostDisable(int p0);
+int perfBoostEnable(int p0);
+int perfDumpAll();
+int perfLevelBoost(int p0);
+int perfNotifyAppState(const char * p0, const char * p1, int p2);
+int perfSetFavorPid(int p0);
+int perfUserGetCapability(int p0);
+int perfUserRegScn(int p0);
+int perfUserRegScnConfig(int p0, int p1, int p2, int p3, int p4, int p5);
+int perfUserScnDisable(int p0);
+int perfUserScnDisableAll();
+int perfUserScnEnable(int p0);
+int perfUserScnReg(int p0, int p1, int p2, int p3);
+int perfUserScnRegBigLittle(int p0, int p1, int p2, int p3, int p4, int p5);
+int perfUserScnResetAll();
+int perfUserScnRestoreAll();
+int perfUserScnUnreg(int p0);
+int perfUserUnregScn(int p0);
+}
+
+namespace android {
+
+static jint com_mediatek_perfservice_PerfServiceManager_boost_disable(JNIEnv*, jobject obj, jint p0)
+{
+    int result = perfBoostDisable((int)p0);
+    return (jint)result;
+}
+
+static jint com_mediatek_perfservice_PerfServiceManager_boost_enable(JNIEnv*, jobject obj, jint p0)
+{
+    int result = perfBoostEnable((int)p0);
+    return (jint)result;
+}
+
+static jint com_mediatek_perfservice_PerfServiceManager_dump_all(JNIEnv*, jobject obj)
+{
+    int result = perfDumpAll();
+    return (jint)result;
+}
+
+static jint com_mediatek_perfservice_PerfServiceManager_level_boost(JNIEnv*, jobject obj, jint p0)
+{
+    int result = perfLevelBoost((int)p0);
+    return (jint)result;
+}
+
+static jint com_mediatek_perfservice_PerfServiceManager_notify_app_state(JNIEnv* env, jobject obj, jstring p0, jstring p1, jint p2)
+{
+    const char *pkgStr = env->GetStringUTFChars(p0, NULL);
+    const char *classStr = env->GetStringUTFChars(p1, NULL);
+    int id = perfNotifyAppState(pkgStr, classStr, p2);
+    env->ReleaseStringUTFChars(p1, classStr);
+    env->ReleaseStringUTFChars(p0, pkgStr);
+    return id;
+}
+
+static jint com_mediatek_perfservice_PerfServiceManager_set_favor_pid(JNIEnv*, jobject obj, jint p0)
+{
+    int result = perfSetFavorPid((int)p0);
+    return (jint)result;;
+}
+
+static jint com_mediatek_perfservice_PerfServiceManager_user_get_capability(JNIEnv*, jobject obj, jint p0)
+{
+    int result = perfUserGetCapability((int)p0);
+    return (jint)result;
+}
+
+static jint com_mediatek_perfservice_PerfServiceManager_user_reg_scn(JNIEnv*, jobject obj, jint p0)
+{
+    int result = perfUserRegScn((int)p0);
+    return (jint)result;
+}
+
+static jint com_mediatek_perfservice_PerfServiceManager_user_reg_scn_config(JNIEnv* env, jobject obj, jint p0, jint p1, jint p2, jint p3, jint p4, jint p5)
+{
+    int result = perfUserRegScnConfig((int)p0, (int)p1, (int)p2, (int)p3, (int)p4, (int)p5);
+    return (jint)result;
+}
+
+static jint com_mediatek_perfservice_PerfServiceManager_user_scn_disable(JNIEnv*, jobject obj, jint p0)
+{
+    int result = perfUserScnDisable((int)p0);
+    return (jint)result;
+}
+
+static jint com_mediatek_perfservice_PerfServiceManager_user_scn_disable_all(JNIEnv*, jobject obj)
+{
+    int result = perfUserScnDisableAll();
+    return (jint)result;
+}
+
+static jint com_mediatek_perfservice_PerfServiceManager_user_scn_enable(JNIEnv*, jobject obj, jint p0)
+{
+    int result = perfUserScnEnable((int)p0);
+    return (jint)result;
+}
+
+static jint com_mediatek_perfservice_PerfServiceManager_user_scn_reg(JNIEnv*, jobject obj, jint p0, jint p1, jint p2, jint p3)
+{
+    int result = perfUserScnReg((int)p0, (int)p1, (int)p2, (int)p3);
+    return (jint)result;
+}
+
+static jint com_mediatek_perfservice_PerfServiceManager_user_scn_reg_big_little(JNIEnv*, jobject obj, jint p0, jint p1, jint p2, jint p3, jint p4, jint p5)
+{
+    int result = perfUserScnRegBigLittle((int)p0, (int)p1, (int)p2, (int)p3, (int)p4, (int)p5);
+    return (jint)result;}
+
+static jint com_mediatek_perfservice_PerfServiceManager_user_scn_reset_all(JNIEnv*, jobject obj)
+{
+    int result = perfUserScnResetAll();
+    return (jint)result;
+}
+
+static jint com_mediatek_perfservice_PerfServiceManager_user_scn_restore_all(JNIEnv*, jobject obj)
+{
+    int result = perfUserScnRestoreAll();
+    return (jint)result;
+}
+
+static jint com_mediatek_perfservice_PerfServiceManager_user_scn_unreg(JNIEnv*, jobject obj, jint p0)
+{
+    int result = perfUserScnUnreg((int)p0);
+    return (jint)result;
+}
+
+static jint com_mediatek_perfservice_PerfServiceManager_user_unreg_scn(JNIEnv*, jobject obj, jint p0)
+{
+    int result = perfUserUnregScn((int)p0);
+    return (jint)result;
+}
+
+static JNINativeMethod sMethods[] = {
+     /* name, signature, funcPtr */
+    {"nativePerfBoostDisable", "(I)I", (void*)com_mediatek_perfservice_PerfServiceManager_boost_disable},
+    {"nativePerfBoostEnable", "(I)I", (void*)com_mediatek_perfservice_PerfServiceManager_boost_enable},
+    {"nativePerfDumpAll", "()I", (void*)com_mediatek_perfservice_PerfServiceManager_dump_all},
+    {"nativePerfLevelBoost", "(I)I", (void*)com_mediatek_perfservice_PerfServiceManager_level_boost},
+    {"nativePerfNotifyAppState", "(Ljava/lang/String;Ljava/lang/String;I)I", (void*)com_mediatek_perfservice_PerfServiceManager_notify_app_state},
+    {"nativePerfSetFavorPid", "(I)I", (void*)com_mediatek_perfservice_PerfServiceManager_set_favor_pid},
+    {"nativePerfUserGetCapability", "(I)I", (void*)com_mediatek_perfservice_PerfServiceManager_user_get_capability},
+    {"nativePerfUserRegScn", "(II)I", (void*)com_mediatek_perfservice_PerfServiceManager_user_reg_scn},
+    {"nativePerfUserRegScnConfig", "(IIIIII)I", (void*)com_mediatek_perfservice_PerfServiceManager_user_reg_scn_config},
+    {"nativePerfUserScnDisable", "(I)I", (void*)com_mediatek_perfservice_PerfServiceManager_user_scn_disable},
+    {"nativePerfUserScnDisableAll", "()I", (void*)com_mediatek_perfservice_PerfServiceManager_user_scn_disable_all},
+    {"nativePerfUserScnEnable", "(I)I", (void*)com_mediatek_perfservice_PerfServiceManager_user_scn_enable},
+    {"nativePerfUserScnReg", "(IIII)I", (void*)com_mediatek_perfservice_PerfServiceManager_user_scn_reg},
+    {"nativePerfUserScnRegBigLittle", "(IIIIII)I", (void*)com_mediatek_perfservice_PerfServiceManager_user_scn_reg_big_little},
+    {"nativePerfUserScnResetAll", "()I", (void*)com_mediatek_perfservice_PerfServiceManager_user_scn_reset_all},
+    {"nativePerfUserScnRestoreAll", "()I", (void*)com_mediatek_perfservice_PerfServiceManager_user_scn_restore_all},
+    {"nativePerfUserScnUnreg", "(I)I", (void*)com_mediatek_perfservice_PerfServiceManager_user_scn_unreg},
+    {"nativePerfUserUnregScn", "(I)I", (void*)com_mediatek_perfservice_PerfServiceManager_user_unreg_scn},
+};
+
+int register_com_mediatek_perfservice_PerfServiceManager(JNIEnv* env)
+{
+    int res;
+    ALOGE("Registering native methods\n");
+    res = jniRegisterNativeMethods(env, "com/mediatek/perfservice/PerfServiceManager",
+                                    sMethods, NELEM(sMethods));
+    ALOGE("Registering native methods result %d\n", res);
+    return res;
+}
+
+} /* namespace android */
diff --git a/services/core/jni/onload.cpp b/services/core/jni/onload.cpp
index 7b2e4080..1781f394 100644
--- a/services/core/jni/onload.cpp
+++ b/services/core/jni/onload.cpp
@@ -42,6 +42,8 @@ int register_android_server_tv_TvInputHal(JNIEnv* env);
 int register_android_server_PersistentDataBlockService(JNIEnv* env);
 int register_android_server_fingerprint_FingerprintService(JNIEnv* env);
 int register_android_server_Watchdog(JNIEnv* env);
+int register_android_server_DeviceControlService(JNIEnv* env);
+int register_com_mediatek_perfservice_PerfServiceManager(JNIEnv* env);
 };
 
 using namespace android;
@@ -79,6 +81,8 @@ extern "C" jint JNI_OnLoad(JavaVM* vm, void* reserved)
     register_android_server_PersistentDataBlockService(env);
     register_android_server_fingerprint_FingerprintService(env);
     register_android_server_Watchdog(env);
+    register_android_server_DeviceControlService(env);
+    register_com_mediatek_perfservice_PerfServiceManager(env);
 
     return JNI_VERSION_1_4;
 }
diff --git a/services/java/com/android/server/SystemServer.java b/services/java/com/android/server/SystemServer.java
index e8be4df3..9c8c6aac 100644
--- a/services/java/com/android/server/SystemServer.java
+++ b/services/java/com/android/server/SystemServer.java
@@ -108,6 +108,9 @@ import com.android.server.usb.UsbService;
 import com.android.server.wallpaper.WallpaperManagerService;
 import com.android.server.webkit.WebViewUpdateService;
 import com.android.server.wm.WindowManagerService;
+import com.mediatek.common.thermal.MtkThermalSwitchManager;
+import com.mediatek.perfservice.PerfServiceImpl;
+import com.mediatek.perfservice.PerfServiceManager;
 
 import dalvik.system.VMRuntime;
 import dalvik.system.PathClassLoader;
@@ -561,6 +564,12 @@ public final class SystemServer {
         GestureService gestureService = null;
         ThemeService themeService = null;
         KillSwitchService killSwitchService = null;
+        // MTK/Meizu
+        GestureManagerService gestureManagerService = null;
+        DeviceControlService deviceControlService = null;
+        MtkThermalSwitchManager thermalManager = null;
+        PerfServiceImpl perfService = null;
+        PerfMgrStateNotifier perfNotifier = null;
 
         // Bring up services needed for UI.
         if (mFactoryTestMode != FactoryTest.FACTORY_TEST_LOW_LEVEL) {
@@ -1083,6 +1092,54 @@ public final class SystemServer {
             } catch (Throwable e) {
                 Slog.e(TAG, "Failure starting EdgeGesture service", e);
             }
+
+            // MTK/Meizu
+            try {
+                gestureManagerService = new GestureManagerService(context);
+                ServiceManager.addService("gesture_manager", (IBinder)gestureManagerService);
+                gestureManagerService.systemReady();
+            } catch (Throwable e) {
+                Slog.e(TAG, "Failure starting GestureManagerService service", e);
+            }
+
+            try {
+                Slog.i(TAG, "FlymeDeviceControlService");
+                deviceControlService = new DeviceControlService(context);
+                ServiceManager.addService("device_control", deviceControlService);
+                deviceControlService.writeAccelerationFactoryCalibValue();
+                deviceControlService.writeGyroscopeFactoryCalibValue();
+                deviceControlService.writeProximitySensorFactoryCalibValue();
+            } catch (Throwable e) {
+                Slog.e(TAG, "Failure starting FlymeDeviceControlService service", e);
+            }
+
+            try {
+                Slog.i(TAG, "MtkThermalSwitchManager");
+                thermalManager = new MtkThermalSwitchManager(context);
+                //ServiceManager.addService("??", thermalManager);
+                // TODO: register in Activity manager
+                thermalManager.systemReady();
+            } catch (Throwable e) {
+                Slog.e(TAG, "Failure starting FlymeDeviceControlService service", e);
+            }
+
+            if (SystemProperties.getInt("ro.mtk_perfservice_support", 0) == 1) {
+                try {
+                    PerfServiceManager perfServiceManager = new PerfServiceManager(context);
+                    perfService = new PerfServiceImpl(context, perfServiceManager);
+                    ServiceManager.addService("mtk-perfservice", perfService);
+                    // TODO: should we call PerfServiceManager.systemReady() sometime later?
+                    try {
+                        perfNotifier = new PerfMgrStateNotifier();
+                        mActivityManagerService.registerActivityStateNotifier(perfNotifier);
+                    } catch (Throwable e) {
+                        Slog.e(TAG, "Failure starting PerfMgrStateNotifier", e);
+                    }
+                } catch (Throwable e) {
+                    Slog.e(TAG, "Failure starting PerfService service", e);
+                }
+            }
+
         }
 
         if (!disableNonCoreServices) {
diff --git a/telephony/java/android/telephony/PhoneNumberUtils.java b/telephony/java/android/telephony/PhoneNumberUtils.java
index d6d56a15..dbcdd27a 100644
--- a/telephony/java/android/telephony/PhoneNumberUtils.java
+++ b/telephony/java/android/telephony/PhoneNumberUtils.java
@@ -47,6 +47,14 @@ import java.util.Locale;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 
+import java.util.ArrayList;
+import java.util.HashMap;
+import org.xmlpull.v1.XmlPullParser;
+import org.xmlpull.v1.XmlPullParserException;
+import org.xmlpull.v1.XmlPullParserFactory;
+import java.io.FileReader;
+import java.io.IOException;
+
 /**
  * Various utilities for dealing with phone number strings.
  */
@@ -89,6 +97,78 @@ public class PhoneNumberUtils
     private static final Pattern GLOBAL_PHONE_NUMBER_PATTERN =
             Pattern.compile("[\\+]?[0-9.-]+");
 
+    // MTK
+
+    /** @hide */
+    public static class EccEntry {
+        public static final String ECC_LIST_PATH = "/system/etc/ecc_list.xml";
+        public static final String ECC_ENTRY_TAG = "EccEntry";
+        public static final String ECC_ATTR = "Ecc";
+        public static final String CATEGORY_ATTR = "Category";
+        public static final String CONDITION_ATTR = "Condition";
+
+        public static final String ECC_NO_SIM = "0";
+        public static final String ECC_ALWAYS = "1";
+        public static final String ECC_FOR_MMI = "2";
+
+        private String mEcc;
+        private String mCategory;
+        private String mCondition; // ECC_NO_SIM, ECC_ALWAYS, or ECC_FOR_MMI
+
+        public EccEntry() {
+            mEcc = new String("");
+            mCategory = new String("");
+            mCondition = new String("");
+        }
+
+        public void setEcc(String strEcc) {
+            mEcc = strEcc;
+        }
+        public void setCategory(String strCategory) {
+            mCategory = strCategory;
+        }
+        public void setCondition(String strCondition) {
+            mCondition = strCondition;
+        }
+
+        public String getEcc() {
+            return mEcc;
+        }
+        public String getCategory() {
+            return mCategory;
+        }
+        public String getCondition() {
+            return mCondition;
+        }
+
+        @Override
+        public String toString() {
+            return ("\n" + ECC_ATTR + "=" + getEcc() + ", " + CATEGORY_ATTR + "="
+                    + getCategory() + ", " + CONDITION_ATTR + "=" + getCondition());
+        }
+    }
+
+    private static ArrayList<EccEntry> mCustomizedEccList = null;
+    private static HashMap<String, Integer> mHashMapForNetworkEccCategory = null;
+
+    // private static IPhoneNumberExt sPhoneNumberExt = null;
+
+    private static boolean sIsCtaSupport = false;
+    private static boolean sIsCtaSet = false;
+
+    static {
+        sIsCtaSupport = "1".equals(SystemProperties.get("persist.mtk_cta_support"));
+        sIsCtaSet = "1".equals(SystemProperties.get("ro.mtk_cta_set"));
+        /*
+        if (!SystemProperties.get("ro.mtk_bsp_package").equals("1")) {
+            sPhoneNumberExt = MPlugin.createInstance(IPhoneNumberExt.class.getName());
+        }
+        */
+        mCustomizedEccList = new ArrayList<EccEntry>();
+        parseEccList();
+        mHashMapForNetworkEccCategory = new HashMap<String, Integer>();
+    }
+
     /** True if c is ISO-LATIN characters 0-9 */
     public static boolean
     isISODigit (char c) {
@@ -1855,6 +1935,8 @@ public class PhoneNumberUtils
     private static boolean isEmergencyNumberInternal(int subId, String number,
                                                      String defaultCountryIso,
                                                      boolean useExactMatch) {
+        boolean bSIMInserted = false;
+
         // If the number passed in is null, just return false:
         if (number == null) return false;
 
@@ -1876,6 +1958,28 @@ public class PhoneNumberUtils
         Rlog.d(LOG_TAG, "subId:" + subId + ", number: " +  number + ", defaultCountryIso:" +
                 ((defaultCountryIso == null) ? "NULL" : defaultCountryIso));
 
+        // MTK
+        // 1. Check ECCs updated by network
+        mHashMapForNetworkEccCategory.clear();
+        String strEccCategoryList = SystemProperties.get("ril.ecc.service.category.list");
+        if (!TextUtils.isEmpty(strEccCategoryList)) {
+            for (String strEccCategory : strEccCategoryList.split(";")) {
+                if (!strEccCategory.isEmpty()) {
+                    String[] strEccCategoryAry = strEccCategory.split(",");
+                    if (2 == strEccCategoryAry.length)
+                        mHashMapForNetworkEccCategory.put(strEccCategoryAry[0], Integer.parseInt(strEccCategoryAry[1]));
+                }
+            }
+        }
+        for (String emergencyNum : mHashMapForNetworkEccCategory.keySet()) {
+            String numberPlus = emergencyNum + "+";
+            if (emergencyNum.equals(number)
+                 || numberPlus.equals(number)) {
+                Rlog.d(LOG_TAG, "[isEmergencyNumber] match network ecc list");
+                return true;
+            }
+        }
+
         String emergencyNumbers = "";
         int slotId = SubscriptionManager.getSlotId(subId);
 
@@ -1885,6 +1989,7 @@ public class PhoneNumberUtils
             String ecclist = (slotId == 0) ? "ril.ecclist" : ("ril.ecclist" + slotId);
 
             emergencyNumbers = SystemProperties.get(ecclist, "");
+            bSIMInserted = true;
         }
 
         Rlog.d(LOG_TAG, "slotId:" + slotId + ", emergencyNumbers: " +  emergencyNumbers);
@@ -1916,6 +2021,36 @@ public class PhoneNumberUtils
             return false;
         }
 
+        // MTK
+        // 3. Check ECCs customized by user
+        if (bSIMInserted) {
+            if (mCustomizedEccList != null) {
+                for (EccEntry eccEntry : mCustomizedEccList) {
+                    if (!eccEntry.getCondition().equals(EccEntry.ECC_NO_SIM)) {
+                        String ecc = eccEntry.getEcc();
+                        String numberPlus = ecc + "+";
+                        if (ecc.equals(number)
+                             || numberPlus.equals(number)) {
+                            Rlog.d(LOG_TAG, "[isEmergencyNumber] match customized ecc list");
+                            return true;
+                        }
+                    }
+                }
+            }
+        } else {
+            if (mCustomizedEccList != null) {
+                for (EccEntry eccEntry : mCustomizedEccList) {
+                    String ecc = eccEntry.getEcc();
+                    String numberPlus = ecc + "+";
+                    if (ecc.equals(number)
+                         || numberPlus.equals(number)) {
+                        Rlog.d(LOG_TAG, "[isEmergencyNumber] match customized ecc list when no sim");
+                        return true;
+                    }
+                }
+            }
+        }
+
         Rlog.d(LOG_TAG, "System property doesn't provide any emergency numbers."
                 + " Use embedded logic for determining ones.");
 
@@ -2990,4 +3125,149 @@ public class PhoneNumberUtils
         return SubscriptionManager.getDefaultVoiceSubId();
     }
     //==== End of utility methods used only in compareStrictly() =====
+
+    // MTK
+
+    /**
+     * Parse Ecc List From XML File
+     *
+     * @param none.
+     * @return none.
+     * @hide
+     */
+    private static void parseEccList() {
+        mCustomizedEccList.clear();
+
+        try {
+            XmlPullParserFactory factory = XmlPullParserFactory.newInstance();
+            XmlPullParser parser = factory.newPullParser();
+            if (parser == null) {
+                Rlog.d(LOG_TAG, "XmlPullParserFactory.newPullParser() return null");
+                return;
+            }
+            FileReader fileReader = new FileReader(EccEntry.ECC_LIST_PATH);
+            parser.setInput(fileReader);
+            int eventType = parser.getEventType();
+            EccEntry record = null;
+
+            while (eventType != XmlPullParser.END_DOCUMENT) {
+                switch (eventType) {
+                    case XmlPullParser.START_TAG:
+                        if (parser.getName().equals(EccEntry.ECC_ENTRY_TAG)) {
+                            record = new EccEntry();
+                            int attrNum = parser.getAttributeCount();
+                            for (int i = 0; i < attrNum; ++i) {
+                                String name = parser.getAttributeName(i);
+                                String value = parser.getAttributeValue(i);
+                                if (name.equals(EccEntry.ECC_ATTR))
+                                    record.setEcc(value);
+                                else if (name.equals(EccEntry.CATEGORY_ATTR))
+                                    record.setCategory(value);
+                                else if (name.equals(EccEntry.CONDITION_ATTR))
+                                    record.setCondition(value);
+                            }
+                        }
+                        break;
+                    case XmlPullParser.END_TAG:
+                        if (parser.getName().equals(EccEntry.ECC_ENTRY_TAG) && record != null)
+                            mCustomizedEccList.add(record);
+                        break;
+                }
+                eventType = parser.next();
+            }
+            fileReader.close();
+
+            if (sIsCtaSet) {
+                String [] emergencyCTAList = {"120", "122"};
+                for (String emergencyNum : emergencyCTAList) {
+                    record = new EccEntry();
+                    record.setEcc(emergencyNum);
+                    record.setCategory("0");
+                    record.setCondition(EccEntry.ECC_FOR_MMI);
+
+                    boolean bFound = false;
+                    int nIndex = 0;
+                    for (EccEntry eccEntry : mCustomizedEccList) {
+                        String ecc = eccEntry.getEcc();
+                        if (ecc.equals(emergencyNum)) {
+                            bFound = true;
+                            Rlog.d(LOG_TAG, "[parseEccList]"
+                                    + "CTA ecc match customized ecc list, ecc=" + ecc);
+                            break;
+                        }
+                        nIndex++;
+                    }
+
+                    if (bFound)
+                        mCustomizedEccList.set(nIndex, record);
+                    else
+                        mCustomizedEccList.add(record);
+                }
+            }
+        } catch (XmlPullParserException e) {
+            e.printStackTrace();
+        } catch (IOException e) {
+            e.printStackTrace();
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+
+        Rlog.d(LOG_TAG, "parseEccList: " + mCustomizedEccList);
+    }
+
+    /**
+     * Get Ecc List
+     *
+     * @param none.
+     * @return Ecc List with type ArrayList<EccEntry>.
+     * @hide
+     */
+    public static ArrayList<EccEntry> getEccList() {
+        return mCustomizedEccList;
+    }
+
+    /**
+     * Get the service category for the given ECC number.
+     * @param number The ECC number.
+     * @return The service category for the given number.
+     * @hide
+     */
+    public static int getServiceCategoryFromEcc(String number) {
+        String numberPlus = null;
+
+        // 1. Get category from network
+        for (String emergencyNum : mHashMapForNetworkEccCategory.keySet()) {
+            numberPlus = emergencyNum + "+";
+            if (emergencyNum.equals(number)
+                 || numberPlus.equals(number)) {
+                Integer nSC = mHashMapForNetworkEccCategory.get(emergencyNum);
+                if (nSC != null) {
+                    Rlog.d(LOG_TAG, "[getServiceCategoryFromEcc] match network ecc list, "
+                            + "Ecc= " + number + ", Category= " + nSC);
+                    return nSC;
+                }
+            }
+        }
+
+        // 2. Get category from sim
+        // ToDo: EF_Ecc will convey service category later
+
+        // 3. Get category from user-customized
+        if (mCustomizedEccList != null) {
+            for (EccEntry eccEntry : mCustomizedEccList) {
+                String ecc = eccEntry.getEcc();
+                numberPlus = ecc + "+";
+                if (ecc.equals(number)
+                     || numberPlus.equals(number)) {
+                    Rlog.d(LOG_TAG, "[getServiceCategoryFromEcc] match customized ecc list, "
+                            + "Ecc= " + ecc + ", Category= " + eccEntry.getCategory());
+                    return Integer.parseInt(eccEntry.getCategory());
+                }
+            }
+        }
+
+        Rlog.d(LOG_TAG, "[getServiceCategoryFromEcc] no matched for Ecc =" + number + ", return 0");
+        return 0;
+    }
+
 }
diff --git a/telephony/java/android/telephony/PhoneRatFamily.aidl b/telephony/java/android/telephony/PhoneRatFamily.aidl
new file mode 100755
index 00000000..dd7132c4
--- /dev/null
+++ b/telephony/java/android/telephony/PhoneRatFamily.aidl
@@ -0,0 +1,19 @@
+/*
+ * Copyright (C) 2014 MediaTek Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.telephony;
+
+parcelable PhoneRatFamily;
\ No newline at end of file
diff --git a/telephony/java/android/telephony/PhoneRatFamily.java b/telephony/java/android/telephony/PhoneRatFamily.java
new file mode 100755
index 00000000..158dccae
--- /dev/null
+++ b/telephony/java/android/telephony/PhoneRatFamily.java
@@ -0,0 +1,114 @@
+/*
+ * Copyright (C) 2014 MediaTek Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.telephony;
+
+import android.os.Parcel;
+import android.os.Parcelable;
+
+/**
+ * Object to indicate the phone RAT family.
+ *
+ * @hide
+ */
+public class PhoneRatFamily implements Parcelable {
+    /* Phone ID of phone */
+    private int mPhoneId;
+    /* New phone rat family */
+    private int mRatFamily;
+
+    public static final int PHONE_RAT_FAMILY_NONE = 0x00;
+    public static final int PHONE_RAT_FAMILY_2G = 0x01;
+    public static final int PHONE_RAT_FAMILY_3G = 0x02;
+    public static final int PHONE_RAT_FAMILY_4G = 0x04;
+
+    /**
+     * Constructor.
+     *
+     * @param phoneId the phone ID
+     * @param ratFamily the new RAT family
+     */
+    public PhoneRatFamily(int phoneId, int ratFamily) {
+        mPhoneId = phoneId;
+        mRatFamily = ratFamily;
+    }
+
+    /**
+     * Get phone ID.
+     *
+     * @return phone ID
+     */
+    public int getPhoneId() {
+        return mPhoneId;
+    }
+
+    /**
+     * Get RAT family.
+     *
+     * @return phone RAT family
+     */
+    public int getRatFamily() {
+        return mRatFamily;
+    }
+
+    @Override
+    public String toString() {
+        String ret = "{ mPhoneId = " + mPhoneId
+                + ", mRatFamily = " + mRatFamily
+                + "}";
+        return ret;
+    }
+
+    /**
+     * Implement the Parcelable interface.
+     *
+     * @return describe content
+     */
+    @Override
+    public int describeContents() {
+        return 0;
+    }
+
+    /**
+     * Implement the Parcelable interface.
+     *
+     * @param outParcel The Parcel in which the object should be written.
+     * @param flags Additional flags about how the object should be written.
+     */
+    public void writeToParcel(Parcel outParcel, int flags) {
+        outParcel.writeInt(mPhoneId);
+        outParcel.writeInt(mRatFamily);
+    }
+
+    /**
+     * Implement the Parcelable interface.
+     */
+    public static final Creator<PhoneRatFamily> CREATOR = new Creator<PhoneRatFamily>() {
+        @Override
+        public PhoneRatFamily createFromParcel(Parcel in) {
+            int phoneId = in.readInt();
+            int ratFamily = in.readInt();
+
+            return new PhoneRatFamily(phoneId, ratFamily);
+        }
+
+        @Override
+        public PhoneRatFamily[] newArray(int size) {
+            return new PhoneRatFamily[size];
+        }
+    };
+}
+
diff --git a/telephony/java/android/telephony/ServiceState.java b/telephony/java/android/telephony/ServiceState.java
index 2d72c2b1..5f5377f4 100644
--- a/telephony/java/android/telephony/ServiceState.java
+++ b/telephony/java/android/telephony/ServiceState.java
@@ -154,6 +154,30 @@ public class ServiceState implements Parcelable {
      * @hide
      */
     public static final int RIL_RADIO_TECHNOLOGY_IWLAN = 18;
+    // MTK-specific HSPAP radio technologies
+    /** @hide */
+    public static final int RIL_RADIO_TECHNOLOGY_MTK = 128;
+    /** @hide */
+    public static final int RIL_RADIO_TECHNOLOGY_HSDPAP = RIL_RADIO_TECHNOLOGY_MTK + 1;
+    /** @hide */
+    public static final int RIL_RADIO_TECHNOLOGY_HSDPAP_UPA = RIL_RADIO_TECHNOLOGY_MTK + 2;
+    /** @hide */
+    public static final int RIL_RADIO_TECHNOLOGY_HSUPAP = RIL_RADIO_TECHNOLOGY_MTK + 3;
+    /** @hide */
+    public static final int RIL_RADIO_TECHNOLOGY_HSUPAP_DPA = RIL_RADIO_TECHNOLOGY_MTK + 4;
+    /** @hide */
+    public static final int RIL_RADIO_TECHNOLOGY_DC_DPA = RIL_RADIO_TECHNOLOGY_MTK + 5;
+    /** @hide */
+    public static final int RIL_RADIO_TECHNOLOGY_DC_UPA = RIL_RADIO_TECHNOLOGY_MTK + 6;
+    /** @hide */
+    public static final int RIL_RADIO_TECHNOLOGY_DC_HSDPAP = RIL_RADIO_TECHNOLOGY_MTK + 7;
+    /** @hide */
+    public static final int RIL_RADIO_TECHNOLOGY_DC_HSDPAP_UPA = RIL_RADIO_TECHNOLOGY_MTK + 8;
+    /** @hide */
+    public static final int RIL_RADIO_TECHNOLOGY_DC_HSDPAP_DPA = RIL_RADIO_TECHNOLOGY_MTK + 9;
+    /** @hide */
+    public static final int RIL_RADIO_TECHNOLOGY_DC_HSPAP = RIL_RADIO_TECHNOLOGY_MTK + 10;
+
     /**
      * Available registration states for GSM, UMTS and CDMA.
      */
@@ -221,6 +245,25 @@ public class ServiceState implements Parcelable {
     private int mCdmaEriIconIndex = 1; //EriInfo.ROAMING_INDICATOR_OFF;;
     private int mCdmaEriIconMode;
 
+    // MTK
+    private int mRilVoiceRegState = REGISTRATION_STATE_NOT_REGISTERED_AND_NOT_SEARCHING;
+    private int mRilDataRegState  = REGISTRATION_STATE_NOT_REGISTERED_AND_NOT_SEARCHING;
+    //[ALPS01675318] -START
+    private int mProprietaryDataRadioTechnology;
+    //[ALPS01675318] -END
+
+    // MTK CDMA
+    /** @hide */
+    public static final int RIL_CDMA_NETWORK_MODE_UNKOWN    = 0;
+    /** @hide */
+    public static final int RIL_CDMA_NETWORK_MODE_1X_ONLY   = 2;
+    /** @hide */
+    public static final int RIL_CDMA_NETWORK_MODE_EVDO_ONLY = 4;
+    /** @hide */
+    public static final int RIL_CDMA_NETWORK_MODE_1X_EVDO   = 8;
+    /** @hide */
+    protected int mCdmaNetWorkMode = RIL_CDMA_NETWORK_MODE_UNKOWN;
+
     /**
      * get String description of roaming type
      * @hide
@@ -298,6 +341,12 @@ public class ServiceState implements Parcelable {
         mCdmaEriIconIndex = s.mCdmaEriIconIndex;
         mCdmaEriIconMode = s.mCdmaEriIconMode;
         mIsEmergencyOnly = s.mIsEmergencyOnly;
+
+        // MTK
+        mRilVoiceRegState = s.mRilVoiceRegState;
+        mRilDataRegState = s.mRilDataRegState;
+        mProprietaryDataRadioTechnology = s.mProprietaryDataRadioTechnology;
+        mCdmaNetWorkMode = s.mCdmaNetWorkMode;
     }
 
     /**
@@ -325,6 +374,12 @@ public class ServiceState implements Parcelable {
         mCdmaEriIconIndex = in.readInt();
         mCdmaEriIconMode = in.readInt();
         mIsEmergencyOnly = in.readInt() != 0;
+
+        // MTK
+        mRilVoiceRegState = in.readInt();
+        mRilDataRegState = in.readInt();
+        mProprietaryDataRadioTechnology = in.readInt();
+        mCdmaNetWorkMode = in.readInt();
     }
 
     public void writeToParcel(Parcel out, int flags) {
@@ -349,6 +404,12 @@ public class ServiceState implements Parcelable {
         out.writeInt(mCdmaEriIconIndex);
         out.writeInt(mCdmaEriIconMode);
         out.writeInt(mIsEmergencyOnly ? 1 : 0);
+
+        // MTK
+        out.writeInt(mRilVoiceRegState);
+        out.writeInt(mRilDataRegState);
+        out.writeInt(mProprietaryDataRadioTechnology);
+        out.writeInt(mCdmaNetWorkMode);
     }
 
     public int describeContents() {
@@ -636,7 +697,12 @@ public class ServiceState implements Parcelable {
                 && equalsHandlesNulls(mCdmaRoamingIndicator, s.mCdmaRoamingIndicator)
                 && equalsHandlesNulls(mCdmaDefaultRoamingIndicator,
                         s.mCdmaDefaultRoamingIndicator)
-                && mIsEmergencyOnly == s.mIsEmergencyOnly);
+                && mIsEmergencyOnly == s.mIsEmergencyOnly
+                // MTK
+                && mRilVoiceRegState == s.mRilVoiceRegState
+                && mRilDataRegState == s.mRilDataRegState
+                && equalsHandlesNulls(mProprietaryDataRadioTechnology, s.mProprietaryDataRadioTechnology)
+                && mCdmaNetWorkMode == s.mCdmaNetWorkMode);
     }
 
     /**
@@ -740,7 +806,12 @@ public class ServiceState implements Parcelable {
                 + " " + mSystemId
                 + " RoamInd=" + mCdmaRoamingIndicator
                 + " DefRoamInd=" + mCdmaDefaultRoamingIndicator
-                + " EmergOnly=" + mIsEmergencyOnly);
+                + " EmergOnly=" + mIsEmergencyOnly
+                // MTK
+                + " RilVoiceRegState=" + mRilVoiceRegState
+                + " RilDataRegState=" + mRilDataRegState
+                + " ProprietaryDataRadioTechnology=" + mProprietaryDataRadioTechnology
+                + " CdmaNetWorkMode=" + mCdmaNetWorkMode);
     }
 
     private void setNullState(int state) {
@@ -766,6 +837,11 @@ public class ServiceState implements Parcelable {
         mCdmaEriIconIndex = -1;
         mCdmaEriIconMode = -1;
         mIsEmergencyOnly = false;
+
+        // MTK
+        mRilVoiceRegState = REGISTRATION_STATE_NOT_REGISTERED_AND_NOT_SEARCHING;
+        mRilDataRegState  = REGISTRATION_STATE_NOT_REGISTERED_AND_NOT_SEARCHING;
+        mProprietaryDataRadioTechnology = 0;
     }
 
     public void setStateOutOfService() {
@@ -938,6 +1014,12 @@ public class ServiceState implements Parcelable {
         mCdmaRoamingIndicator = m.getInt("cdmaRoamingIndicator");
         mCdmaDefaultRoamingIndicator = m.getInt("cdmaDefaultRoamingIndicator");
         mIsEmergencyOnly = m.getBoolean("emergencyOnly");
+
+        // MTK
+        mRilVoiceRegState = m.getInt("RilVoiceRegState");
+        mRilDataRegState = m.getInt("RilDataRegState");
+        mProprietaryDataRadioTechnology = m.getInt("proprietaryDataRadioTechnology");
+        mCdmaNetWorkMode = m.getInt("cdmaNetWorkMode");
     }
 
     /**
@@ -966,6 +1048,12 @@ public class ServiceState implements Parcelable {
         m.putInt("cdmaRoamingIndicator", mCdmaRoamingIndicator);
         m.putInt("cdmaDefaultRoamingIndicator", mCdmaDefaultRoamingIndicator);
         m.putBoolean("emergencyOnly", Boolean.valueOf(mIsEmergencyOnly));
+
+        // MTK
+        m.putInt("RilVoiceRegState", mRilVoiceRegState);
+        m.putInt("RilDataRegState", mRilDataRegState);
+        m.putInt("proprietaryDataRadioTechnology", mProprietaryDataRadioTechnology);
+        m.putInt("cdmaNetWorkMode", mCdmaNetWorkMode);
     }
 
     /** @hide */
@@ -975,6 +1063,15 @@ public class ServiceState implements Parcelable {
 
     /** @hide */
     public void setRilDataRadioTechnology(int rt) {
+        // redirect MTK-specific RATs
+        if (rt > ServiceState.RIL_RADIO_TECHNOLOGY_MTK) {
+            if (DBG) Rlog.d(LOG_TAG, "[ServiceState] setDataRadioTechnology mProprietaryDataRadioTechnology=" + rt);
+            mProprietaryDataRadioTechnology = rt;
+            rt = ServiceState.RIL_RADIO_TECHNOLOGY_HSPAP;
+        } else {
+            mProprietaryDataRadioTechnology = 0;
+        }
+
         this.mRilDataRadioTechnology = rt;
         if (DBG) Rlog.d(LOG_TAG, "[ServiceState] setDataRadioTechnology=" + mRilDataRadioTechnology);
     }
@@ -1128,4 +1225,93 @@ public class ServiceState implements Parcelable {
 
         return newSs;
     }
+
+    // MTK
+
+    /** @hide */
+    public int getRegState() {
+        return getRilVoiceRegState();
+    }
+
+    /** @hide */
+    public int getRilVoiceRegState() {
+        return mRilVoiceRegState;
+    }
+
+    /** @hide */
+    public int getRilDataRegState() {
+        return mRilDataRegState;
+    }
+
+    /**
+     * @hide
+     */
+    public void setRegState(int nRegState) {
+        setRilVoiceRegState(nRegState);
+    }
+
+    /**
+     * @hide
+     */
+    public void setRilVoiceRegState(int nRegState) {
+        mRilVoiceRegState = nRegState;
+    }
+
+    /**
+     * @hide
+     */
+    public void setRilDataRegState(int nDataRegState) {
+        mRilDataRegState = nDataRegState;
+    }
+
+    /**
+     * @hide
+     */
+    public boolean isVoiceRadioTechnologyHigher(int nRadioTechnology) {
+        return compareTwoRadioTechnology(mRilVoiceRadioTechnology, nRadioTechnology);
+    }
+
+    /**
+     * @hide
+     */
+     public boolean isDataRadioTechnologyHigher(int nRadioTechnology) {
+        return compareTwoRadioTechnology(mRilDataRadioTechnology, nRadioTechnology);
+    }
+
+    /**
+     * @hide
+     */
+    public boolean compareTwoRadioTechnology(int nRadioTechnology1, int nRadioTechnology2) {
+        if (nRadioTechnology1 == nRadioTechnology2) {
+            return false;
+        } else if (nRadioTechnology1 == RIL_RADIO_TECHNOLOGY_LTE) {
+            return true;
+        } else if (nRadioTechnology2 == RIL_RADIO_TECHNOLOGY_LTE) {
+            return false;
+        } else if (nRadioTechnology1 == RIL_RADIO_TECHNOLOGY_GSM) {
+            return false;
+        } else if (nRadioTechnology2 == RIL_RADIO_TECHNOLOGY_GSM) {
+            return true;
+        } else if (nRadioTechnology1 > nRadioTechnology2) {
+            return true;
+        } else {
+            return false;
+        }
+    }
+
+    // MTK CDMA
+
+    /**
+     * @hide
+     */
+    public int getCdmaNetworkMode() {
+        return mCdmaNetWorkMode;
+    }
+
+    /**
+     * @hide
+     */
+    public void setCdmaNetworkMode(int networkMode) {
+        mCdmaNetWorkMode = networkMode;
+    }
 }
diff --git a/telephony/java/android/telephony/SubscriptionManager.java b/telephony/java/android/telephony/SubscriptionManager.java
index 2a41126d..8fc4043e 100644
--- a/telephony/java/android/telephony/SubscriptionManager.java
+++ b/telephony/java/android/telephony/SubscriptionManager.java
@@ -272,6 +272,9 @@ public class SubscriptionManager {
     /** {@hide} */
     public static final int DATA_ROAMING_DEFAULT = DATA_ROAMING_DISABLE;
 
+    //DS: MTK
+    public static final int LTE_DC_PHONE_ID = TelephonyManager.getDefault().getPhoneCount();
+
     /**
      * TelephonyProvider column name for the MCC associated with a SIM.
      * <P>Type: INTEGER (int)</P>
diff --git a/telephony/java/com/android/internal/telephony/ITelephony.aidl b/telephony/java/com/android/internal/telephony/ITelephony.aidl
index 8efc4a71..ca6c282f 100644
--- a/telephony/java/com/android/internal/telephony/ITelephony.aidl
+++ b/telephony/java/com/android/internal/telephony/ITelephony.aidl
@@ -989,4 +989,7 @@ interface ITelephony {
       *   {@link android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE}
       */
     String getDeviceId();
+
+    /* MTK */
+    int getRadioAccessFamily(int subId);
 }
diff --git a/telephony/java/com/android/internal/telephony/IccCardConstants.java b/telephony/java/com/android/internal/telephony/IccCardConstants.java
index e24664ba..79063f5c 100644
--- a/telephony/java/com/android/internal/telephony/IccCardConstants.java
+++ b/telephony/java/com/android/internal/telephony/IccCardConstants.java
@@ -51,6 +51,18 @@ public class IccCardConstants {
     /* PERM_DISABLED means ICC is permanently disabled due to puk fails */
     public static final String INTENT_VALUE_ABSENT_ON_PERM_DISABLED = "PERM_DISABLED";
 
+    // MTK ICC lock reasons
+    /* NETWORK means ICC is locked on NETWORK PERSONALIZATION */
+    public static final String INTENT_VALUE_LOCKED_NETWORK = "NETWORK";
+    /* NETWORK_SUBSET means ICC is locked on NETWORK SUBSET PERSONALIZATION */
+    public static final String INTENT_VALUE_LOCKED_NETWORK_SUBSET = "NETWORK_SUBSET";
+    /* CORPORATE means ICC is locked on CORPORATE PERSONALIZATION */
+    public static final String INTENT_VALUE_LOCKED_CORPORATE = "CORPORATE";
+    /* SERVICE_PROVIDER means ICC is locked on SERVICE_PROVIDER PERSONALIZATION */
+    public static final String INTENT_VALUE_LOCKED_SERVICE_PROVIDER = "SERVICE_PROVIDER";
+    /* SIM means ICC is locked on SIM PERSONALIZATION */
+    public static final String INTENT_VALUE_LOCKED_SIM = "SIM";
+
     /**
      * This is combination of IccCardStatus.CardState and IccCardApplicationStatus.AppState
      * for external apps (like PhoneApp) to use
diff --git a/telephony/java/com/android/internal/telephony/RILConstants.java b/telephony/java/com/android/internal/telephony/RILConstants.java
index b87cfac2..44433144 100644
--- a/telephony/java/com/android/internal/telephony/RILConstants.java
+++ b/telephony/java/com/android/internal/telephony/RILConstants.java
@@ -323,7 +323,8 @@ cat include/telephony/ril.h | \
     int RIL_REQUEST_GET_RADIO_CAPABILITY = 130;
     int RIL_REQUEST_SET_RADIO_CAPABILITY = 131;
     int RIL_REQUEST_GET_DATA_CALL_PROFILE = 132;
-    int RIL_REQUEST_SIM_GET_ATR = 133;
+    // MTK please
+    // int RIL_REQUEST_SIM_GET_ATR = 133;
 
     int RIL_UNSOL_RESPONSE_BASE = 1000;
     int RIL_UNSOL_RESPONSE_RADIO_STATE_CHANGED = 1000;
@@ -373,4 +374,325 @@ cat include/telephony/ril.h | \
     int RIL_UNSOL_STK_CC_ALPHA_NOTIFY = 1044;
 
     int RIL_UNSOL_STK_SEND_SMS_RESULT = 11002; /* Samsung STK */
+
+    // MediaTek Custom States
+    // oh no
+    // DS: static final int RIL_REQUEST_GET_PHONE_RAT_FAMILY = 130;
+    // DS: static final int RIL_REQUEST_SET_PHONE_RAT_FAMILY = 131;
+
+    static final int RIL_REQUEST_MTK_BASE = 2000;
+    static final int RIL_REQUEST_GET_COLP = (RIL_REQUEST_MTK_BASE + 0);
+    static final int RIL_REQUEST_SET_COLP = (RIL_REQUEST_MTK_BASE + 1);
+    static final int RIL_REQUEST_GET_COLR = (RIL_REQUEST_MTK_BASE + 2);
+    static final int RIL_REQUEST_GET_CCM = (RIL_REQUEST_MTK_BASE + 3);
+    static final int RIL_REQUEST_GET_ACM = (RIL_REQUEST_MTK_BASE + 4);
+    static final int RIL_REQUEST_GET_ACMMAX = (RIL_REQUEST_MTK_BASE + 5);
+    static final int RIL_REQUEST_GET_PPU_AND_CURRENCY = (RIL_REQUEST_MTK_BASE + 6);
+    static final int RIL_REQUEST_SET_ACMMAX = (RIL_REQUEST_MTK_BASE + 7);
+    static final int RIL_REQUEST_RESET_ACM = (RIL_REQUEST_MTK_BASE + 8);
+    static final int RIL_REQUEST_SET_PPU_AND_CURRENCY = (RIL_REQUEST_MTK_BASE + 9);
+    static final int RIL_REQUEST_MODEM_POWEROFF = (RIL_REQUEST_MTK_BASE + 10);
+    static final int RIL_REQUEST_DUAL_SIM_MODE_SWITCH = (RIL_REQUEST_MTK_BASE + 11);
+    static final int RIL_REQUEST_QUERY_PHB_STORAGE_INFO = (RIL_REQUEST_MTK_BASE + 12);
+    static final int RIL_REQUEST_WRITE_PHB_ENTRY = (RIL_REQUEST_MTK_BASE + 13);
+    static final int RIL_REQUEST_READ_PHB_ENTRY = (RIL_REQUEST_MTK_BASE + 14);
+    static final int RIL_REQUEST_SET_GPRS_CONNECT_TYPE = (RIL_REQUEST_MTK_BASE + 15);
+    static final int RIL_REQUEST_SET_GPRS_TRANSFER_TYPE = (RIL_REQUEST_MTK_BASE + 16);
+    static final int RIL_REQUEST_MOBILEREVISION_AND_IMEI = (RIL_REQUEST_MTK_BASE + 17); //Add by mtk80372 for Barcode Number
+    static final int RIL_REQUEST_QUERY_SIM_NETWORK_LOCK = (RIL_REQUEST_MTK_BASE + 18);
+    static final int RIL_REQUEST_SET_SIM_NETWORK_LOCK = (RIL_REQUEST_MTK_BASE + 19);
+    static final int RIL_REQUEST_SET_SCRI = (RIL_REQUEST_MTK_BASE + 20);
+    static final int RIL_REQUEST_BTSIM_CONNECT = (RIL_REQUEST_MTK_BASE + 21);
+    static final int RIL_REQUEST_BTSIM_DISCONNECT_OR_POWEROFF = (RIL_REQUEST_MTK_BASE + 22);
+    static final int RIL_REQUEST_BTSIM_POWERON_OR_RESETSIM = (RIL_REQUEST_MTK_BASE + 23);
+    static final int RIL_REQUEST_BTSIM_TRANSFERAPDU = (RIL_REQUEST_MTK_BASE + 24);
+    static final int RIL_REQUEST_SET_NETWORK_SELECTION_MANUAL_WITH_ACT = (RIL_REQUEST_MTK_BASE + 25);
+    static final int RIL_REQUEST_QUERY_ICCID = (RIL_REQUEST_MTK_BASE + 26);
+    static final int RIL_REQUEST_USIM_AUTHENTICATION = (RIL_REQUEST_MTK_BASE + 27);
+    static final int RIL_REQUEST_MODEM_POWERON = (RIL_REQUEST_MTK_BASE + 28);
+    static final int RIL_REQUEST_GET_SMS_SIM_MEM_STATUS = (RIL_REQUEST_MTK_BASE + 29);
+    /* 3G switch start */
+    static final int RIL_REQUEST_GET_PHONE_CAPABILITY = (RIL_REQUEST_MTK_BASE + 30);
+    static final int RIL_REQUEST_SET_PHONE_CAPABILITY = (RIL_REQUEST_MTK_BASE + 31);
+    /* 3G switch end */
+    /* User controlled PLMN selector with Access Technology  begin */
+    static final int RIL_REQUEST_GET_POL_CAPABILITY = (RIL_REQUEST_MTK_BASE + 32);
+    static final int RIL_REQUEST_GET_POL_LIST = (RIL_REQUEST_MTK_BASE + 33);
+    static final int RIL_REQUEST_SET_POL_ENTRY = (RIL_REQUEST_MTK_BASE + 34);
+    /* User controlled PLMN selector with Access Technology  end */
+    /* UPB start */
+    static final int RIL_REQUEST_QUERY_UPB_CAPABILITY = (RIL_REQUEST_MTK_BASE + 35);
+    static final int RIL_REQUEST_EDIT_UPB_ENTRY = (RIL_REQUEST_MTK_BASE + 36);
+    static final int RIL_REQUEST_DELETE_UPB_ENTRY = (RIL_REQUEST_MTK_BASE + 37);
+    static final int RIL_REQUEST_READ_UPB_GAS_LIST = (RIL_REQUEST_MTK_BASE + 38);
+    static final int RIL_REQUEST_READ_UPB_GRP = (RIL_REQUEST_MTK_BASE + 39);
+    static final int RIL_REQUEST_WRITE_UPB_GRP = (RIL_REQUEST_MTK_BASE + 40);
+    /* UPB end */
+    static final int RIL_REQUEST_SET_SIM_RECOVERY_ON = (RIL_REQUEST_MTK_BASE + 41);
+    static final int RIL_REQUEST_GET_SIM_RECOVERY_ON = (RIL_REQUEST_MTK_BASE + 42);
+    static final int RIL_REQUEST_SET_TRM = (RIL_REQUEST_MTK_BASE + 43);
+    static final int RIL_REQUEST_DETECT_SIM_MISSING = (RIL_REQUEST_MTK_BASE + 44);
+    static final int RIL_REQUEST_GET_CALIBRATION_DATA = (RIL_REQUEST_MTK_BASE + 45);
+
+     //For LGE APIs start
+    static final int RIL_REQUEST_GET_PHB_STRING_LENGTH = (RIL_REQUEST_MTK_BASE + 46);
+    static final int RIL_REQUEST_GET_PHB_MEM_STORAGE = (RIL_REQUEST_MTK_BASE + 47);
+    static final int RIL_REQUEST_SET_PHB_MEM_STORAGE = (RIL_REQUEST_MTK_BASE + 48);
+    static final int RIL_REQUEST_READ_PHB_ENTRY_EXT = (RIL_REQUEST_MTK_BASE + 49);
+    static final int RIL_REQUEST_WRITE_PHB_ENTRY_EXT = (RIL_REQUEST_MTK_BASE + 50);
+
+    // requests for read/write EFsmsp
+    static final int RIL_REQUEST_GET_SMS_PARAMS = (RIL_REQUEST_MTK_BASE + 51);
+    static final int RIL_REQUEST_SET_SMS_PARAMS = (RIL_REQUEST_MTK_BASE + 52);
+
+    // NFC SEEK start
+    static final int RIL_REQUEST_SIM_TRANSMIT_BASIC = (RIL_REQUEST_MTK_BASE + 53);
+    static final int RIL_REQUEST_SIM_TRANSMIT_CHANNEL = (RIL_REQUEST_MTK_BASE + 54);
+    static final int RIL_REQUEST_SIM_GET_ATR = (RIL_REQUEST_MTK_BASE + 55);
+    // NFC SEEK end
+
+    // MTK-START, SMS part, CB extension
+    static final int RIL_REQUEST_SET_CB_CHANNEL_CONFIG_INFO = (RIL_REQUEST_MTK_BASE + 56);
+    static final int RIL_REQUEST_SET_CB_LANGUAGE_CONFIG_INFO = (RIL_REQUEST_MTK_BASE + 57);
+    static final int RIL_REQUEST_GET_CB_CONFIG_INFO = (RIL_REQUEST_MTK_BASE + 58);
+    static final int RIL_REQUEST_SET_ALL_CB_LANGUAGE_ON = (RIL_REQUEST_MTK_BASE + 59);
+    // MTK-END, SMS part, CB extension
+
+    static final int RIL_REQUEST_SET_ETWS = (RIL_REQUEST_MTK_BASE + 60);
+
+    // [New R8 modem FD]
+    static final int RIL_REQUEST_SET_FD_MODE = (RIL_REQUEST_MTK_BASE + 61);
+
+    // detach PS service request
+    static final int RIL_REQUEST_DETACH_PS = (RIL_REQUEST_MTK_BASE + 62);
+
+    static final int RIL_REQUEST_SIM_OPEN_CHANNEL_WITH_SW = (RIL_REQUEST_MTK_BASE + 63); // NFC SEEK
+
+    static final int RIL_REQUEST_SET_REG_SUSPEND_ENABLED  = (RIL_REQUEST_MTK_BASE + 64);
+    static final int RIL_REQUEST_RESUME_REGISTRATION  = (RIL_REQUEST_MTK_BASE + 65);
+    static final int RIL_REQUEST_STORE_MODEM_TYPE = (RIL_REQUEST_MTK_BASE + 66);
+    static final int RIL_REQUEST_QUERY_MODEM_TYPE = (RIL_REQUEST_MTK_BASE + 67);
+    static final int RIL_REQUEST_SIM_INTERFACE_SWITCH = (RIL_REQUEST_MTK_BASE + 68);
+
+    //MTK-START [mtk80776] WiFi Calling
+    static final int RIL_REQUEST_UICC_SELECT_APPLICATION = (RIL_REQUEST_MTK_BASE + 69);
+    static final int RIL_REQUEST_UICC_DEACTIVATE_APPLICATION = (RIL_REQUEST_MTK_BASE + 70);
+    static final int RIL_REQUEST_UICC_APPLICATION_IO = (RIL_REQUEST_MTK_BASE + 71);
+    static final int RIL_REQUEST_UICC_AKA_AUTHENTICATE = (RIL_REQUEST_MTK_BASE + 72);
+    static final int RIL_REQUEST_UICC_GBA_AUTHENTICATE_BOOTSTRAP = (RIL_REQUEST_MTK_BASE + 73);
+    static final int RIL_REQUEST_UICC_GBA_AUTHENTICATE_NAF = (RIL_REQUEST_MTK_BASE + 74);
+    //MTK-END [mtk80776] WiFi Calling
+    static final int RIL_REQUEST_STK_EVDL_CALL_BY_AP = (RIL_REQUEST_MTK_BASE + 75);
+
+    // Femtocell (CSG)
+    static final int RIL_REQUEST_GET_FEMTOCELL_LIST  = (RIL_REQUEST_MTK_BASE + 76);
+    static final int RIL_REQUEST_ABORT_FEMTOCELL_LIST = (RIL_REQUEST_MTK_BASE + 77);
+    static final int RIL_REQUEST_SELECT_FEMTOCELL = (RIL_REQUEST_MTK_BASE + 78);
+
+    // For OPLMN update
+    static final int RIL_REQUEST_SEND_OPLMN = (RIL_REQUEST_MTK_BASE + 79);
+    static final int RIL_REQUEST_GET_OPLMN_VERSION = (RIL_REQUEST_MTK_BASE + 80);
+
+    // For PLMN List abort
+    static final int RIL_REQUEST_ABORT_QUERY_AVAILABLE_NETWORKS = (RIL_REQUEST_MTK_BASE + 81);
+    // CSD
+    static final int RIL_REQUEST_DIAL_UP_CSD = (RIL_REQUEST_MTK_BASE + 82);
+
+    // M: For telephony modes update
+    static final int RIL_REQUEST_SET_TELEPHONY_MODE = (RIL_REQUEST_MTK_BASE + 83);
+
+    /* M: call control part start */
+    static final int RIL_REQUEST_HANGUP_ALL = (RIL_REQUEST_MTK_BASE + 84);
+    static final int RIL_REQUEST_FORCE_RELEASE_CALL = (RIL_REQUEST_MTK_BASE + 85);
+    static final int RIL_REQUEST_SET_CALL_INDICATION = (RIL_REQUEST_MTK_BASE + 86);
+    static final int RIL_REQUEST_EMERGENCY_DIAL = (RIL_REQUEST_MTK_BASE + 87);
+    static final int RIL_REQUEST_SET_ECC_SERVICE_CATEGORY = (RIL_REQUEST_MTK_BASE + 88);
+    static final int RIL_REQUEST_SET_ECC_LIST = (RIL_REQUEST_MTK_BASE + 89);
+    /* M: call control part end */
+
+
+    //New SIM Authentication
+    static final int RIL_REQUEST_GENERAL_SIM_AUTH = (RIL_REQUEST_MTK_BASE + 90);
+    //ISIM
+    static final int RIL_REQUEST_OPEN_ICC_APPLICATION = (RIL_REQUEST_MTK_BASE + 91);
+    static final int RIL_REQUEST_GET_ICC_APPLICATION_STATUS = (RIL_REQUEST_MTK_BASE + 92);
+    //SIM_IO_EX
+    static final int RIL_REQUEST_SIM_IO_EX = (RIL_REQUEST_MTK_BASE + 93);
+
+    // IMS
+    static final int RIL_REQUEST_SET_IMS_ENABLE = (RIL_REQUEST_MTK_BASE + 94);
+    static final int RIL_REQUEST_QUERY_AVAILABLE_NETWORKS_WITH_ACT = (RIL_REQUEST_MTK_BASE + 95);
+
+    /* M: SS part */
+    ///M: For query CNAP
+    static final int RIL_REQUEST_SEND_CNAP = (RIL_REQUEST_MTK_BASE + 96);
+    static final int RIL_REQUEST_SET_CLIP = (RIL_REQUEST_MTK_BASE + 97);
+    /* M: SS part end */
+
+    /** M: VoLTE data start */
+    static final int RIL_REQUEST_SETUP_DEDICATE_DATA_CALL = (RIL_REQUEST_MTK_BASE + 98);
+    static final int RIL_REQUEST_DEACTIVATE_DEDICATE_DATA_CALL = (RIL_REQUEST_MTK_BASE + 99);
+    static final int RIL_REQUEST_MODIFY_DATA_CALL = (RIL_REQUEST_MTK_BASE + 100);
+    static final int RIL_REQUEST_ABORT_SETUP_DATA_CALL = (RIL_REQUEST_MTK_BASE + 101);
+    static final int RIL_REQUEST_PCSCF_DISCOVERY_PCO = (RIL_REQUEST_MTK_BASE + 102);
+    static final int RIL_REQUEST_CLEAR_DATA_BEARER = (RIL_REQUEST_MTK_BASE + 103);
+    /** M: VoLTE end */
+
+    // MTK-START, SMS part, CB extension
+    static final int RIL_REQUEST_REMOVE_CB_MESSAGE = (RIL_REQUEST_MTK_BASE + 104);
+    // MTK-END, SMS part, CB extension
+
+    // NAS configuration for voice call
+    // 0: voice centric
+    // 1: data centric
+    static final int RIL_REQUEST_SET_DATA_CENTRIC = (RIL_REQUEST_MTK_BASE + 105);
+
+    /// M: IMS feature. @{
+    static final int RIL_REQUEST_ADD_IMS_CONFERENCE_CALL_MEMBER = (RIL_REQUEST_MTK_BASE + 106);
+    static final int RIL_REQUEST_REMOVE_IMS_CONFERENCE_CALL_MEMBER = (RIL_REQUEST_MTK_BASE + 107);
+    static final int RIL_REQUEST_DIAL_WITH_SIP_URI = (RIL_REQUEST_MTK_BASE + 108);
+    static final int RIL_REQUEST_RETRIEVE_HELD_CALL = (RIL_REQUEST_MTK_BASE + 109);
+    /// @}
+
+    /* M: call control part start */
+    static final int RIL_REQUEST_SET_SPEECH_CODEC_INFO = (RIL_REQUEST_MTK_BASE + 110);
+    /* M: call control part end */
+    /// M: CC33 LTE
+    static final int RIL_REQUEST_SET_DATA_ON_TO_MD = (RIL_REQUEST_MTK_BASE + 111);
+    static final int RIL_REQUEST_SET_REMOVE_RESTRICT_EUTRAN_MODE = (RIL_REQUEST_MTK_BASE + 112);
+
+    /* M: call control part start */
+    static final int RIL_REQUEST_SET_IMS_CALL_STATUS = (RIL_REQUEST_MTK_BASE + 113);
+    /* M: call control part end */
+
+    static final int RIL_REQUEST_EVDO_SUPPORT_BASE = 2100;
+    static final int RIL_REQUEST_RADIO_POWER_CARD_SWITCH = (RIL_REQUEST_EVDO_SUPPORT_BASE + 0);
+
+    // oh no again
+    static final int RIL_UNSOL_SET_PHONE_RAT_FAMILY_COMPLETE = 1042;
+
+    static final int RIL_UNSOL_MTK_BASE = 3000;
+    static final int RIL_UNSOL_NEIGHBORING_CELL_INFO = (RIL_UNSOL_MTK_BASE + 0);
+    static final int RIL_UNSOL_NETWORK_INFO = (RIL_UNSOL_MTK_BASE + 1);
+    static final int RIL_UNSOL_PHB_READY_NOTIFICATION = (RIL_UNSOL_MTK_BASE + 2);
+    static final int RIL_UNSOL_SIM_INSERTED_STATUS = (RIL_UNSOL_MTK_BASE + 3);
+    static final int RIL_UNSOL_RADIO_TEMPORARILY_UNAVAILABLE = (RIL_UNSOL_MTK_BASE + 4);
+    static final int RIL_UNSOL_ME_SMS_STORAGE_FULL = (RIL_UNSOL_MTK_BASE + 5);
+    static final int RIL_UNSOL_SMS_READY_NOTIFICATION = (RIL_UNSOL_MTK_BASE + 6);
+    static final int RIL_UNSOL_SCRI_RESULT = (RIL_UNSOL_MTK_BASE + 7);
+    static final int RIL_UNSOL_SIM_MISSING = (RIL_UNSOL_MTK_BASE + 8);
+    static final int RIL_UNSOL_GPRS_DETACH = (RIL_UNSOL_MTK_BASE + 9);
+    //MTK-START [mtk04070][120208][ALPS00233196] ATCI for unsolicited response
+    static final int RIL_UNSOL_ATCI_RESPONSE = (RIL_UNSOL_MTK_BASE + 10);
+    //MTK-END [mtk04070][120208][ALPS00233196] ATCI for unsolicited response
+    static final int RIL_UNSOL_SIM_RECOVERY = (RIL_UNSOL_MTK_BASE + 11);
+    static final int RIL_UNSOL_VIRTUAL_SIM_ON = (RIL_UNSOL_MTK_BASE + 12);
+    static final int RIL_UNSOL_VIRTUAL_SIM_OFF = (RIL_UNSOL_MTK_BASE + 13);
+    static final int RIL_UNSOL_INVALID_SIM = (RIL_UNSOL_MTK_BASE + 14);
+    static final int RIL_UNSOL_RESPONSE_PS_NETWORK_STATE_CHANGED = (RIL_UNSOL_MTK_BASE + 15);
+    static final int RIL_UNSOL_RESPONSE_ACMT = (RIL_UNSOL_MTK_BASE + 16);
+    static final int RIL_UNSOL_EF_CSP_PLMN_MODE_BIT = (RIL_UNSOL_MTK_BASE + 17);
+    static final int RIL_UNSOL_IMEI_LOCK = (RIL_UNSOL_MTK_BASE + 18);
+    static final int RIL_UNSOL_RESPONSE_MMRR_STATUS_CHANGED = (RIL_UNSOL_MTK_BASE + 19);
+    static final int RIL_UNSOL_SIM_PLUG_OUT = (RIL_UNSOL_MTK_BASE + 20);
+    static final int RIL_UNSOL_SIM_PLUG_IN = (RIL_UNSOL_MTK_BASE + 21);
+    static final int RIL_UNSOL_RESPONSE_ETWS_NOTIFICATION = (RIL_UNSOL_MTK_BASE + 22);
+    static final int RIL_UNSOL_RESPONSE_PLMN_CHANGED = (RIL_UNSOL_MTK_BASE + 23);
+    static final int RIL_UNSOL_RESPONSE_REGISTRATION_SUSPENDED = (RIL_UNSOL_MTK_BASE + 24);
+    static final int RIL_UNSOL_STK_EVDL_CALL = (RIL_UNSOL_MTK_BASE + 25);
+    static final int RIL_UNSOL_DATA_PACKETS_FLUSH = (RIL_UNSOL_MTK_BASE + 26);
+    static final int RIL_UNSOL_FEMTOCELL_INFO = (RIL_UNSOL_MTK_BASE + 27);
+    static final int RIL_UNSOL_STK_SETUP_MENU_RESET = (RIL_UNSOL_MTK_BASE + 28);
+    static final int RIL_UNSOL_APPLICATION_SESSION_ID_CHANGED = (RIL_UNSOL_MTK_BASE + 29);
+    /// M: For updating call ids for conference call after SRVCC is done.
+    static final int RIL_UNSOL_ECONF_SRVCC_INDICATION = (RIL_UNSOL_MTK_BASE + 30);
+    // IMS
+    static final int RIL_UNSOL_IMS_ENABLE_DONE = (RIL_UNSOL_MTK_BASE + 31);
+    static final int RIL_UNSOL_IMS_DISABLE_DONE = (RIL_UNSOL_MTK_BASE + 32);
+    static final int RIL_UNSOL_IMS_REGISTRATION_INFO = (RIL_UNSOL_MTK_BASE + 33);
+    //VoLTE
+    static final int RIL_UNSOL_DEDICATE_BEARER_ACTIVATED = (RIL_UNSOL_MTK_BASE + 34);
+    static final int RIL_UNSOL_DEDICATE_BEARER_MODIFIED = (RIL_UNSOL_MTK_BASE + 35);
+    static final int RIL_UNSOL_DEDICATE_BEARER_DEACTIVATED = (RIL_UNSOL_MTK_BASE + 36);
+
+    //sm cause rac
+    static final int RIL_UNSOL_RAC_UPDATE = (RIL_UNSOL_MTK_BASE + 37);
+
+    //[VoLTE]Conf. call merged/added result
+    static final int RIL_UNSOL_ECONF_RESULT_INDICATION = (RIL_UNSOL_MTK_BASE + 38);
+
+    //Remote SIM ME lock related APIs [Start]
+    static final int RIL_UNSOL_MELOCK_NOTIFICATION = (RIL_UNSOL_MTK_BASE + 39);
+    //Remote SIM ME lock related APIs [END]
+
+    /* M: call control part start */
+    static final int RIL_UNSOL_CALL_FORWARDING = (RIL_UNSOL_MTK_BASE + 40);
+    static final int RIL_UNSOL_CRSS_NOTIFICATION = (RIL_UNSOL_MTK_BASE + 41);
+    static final int RIL_UNSOL_INCOMING_CALL_INDICATION = (RIL_UNSOL_MTK_BASE + 42);
+    static final int RIL_UNSOL_CIPHER_INDICATION = (RIL_UNSOL_MTK_BASE + 43);
+    static final int RIL_UNSOL_CNAP = (RIL_UNSOL_MTK_BASE + 44);
+    /* M: call control part end */
+    static final int RIL_UNSOL_SIM_COMMON_SLOT_NO_CHANGED = (RIL_UNSOL_MTK_BASE + 45);
+    //Combine attach
+    static final int RIL_UNSOL_DATA_ALLOWED = (RIL_UNSOL_MTK_BASE + 46);
+    static final int RIL_UNSOL_STK_CALL_CTRL = (RIL_UNSOL_MTK_BASE + 47);
+    static final int RIL_UNSOL_VOLTE_EPS_NETWORK_FEATURE_SUPPORT = (RIL_UNSOL_MTK_BASE + 48);
+
+    /// M: IMS feature. @{
+    static final int RIL_UNSOL_CALL_INFO_INDICATION = (RIL_UNSOL_MTK_BASE + 49);
+    /// @}
+
+    static final int RIL_UNSOL_VOLTE_EPS_NETWORK_FEATURE_INFO = (RIL_UNSOL_MTK_BASE + 50);
+    static final int RIL_UNSOL_SRVCC_HANDOVER_INFO_INDICATION = (RIL_UNSOL_MTK_BASE + 51);
+    /* M: call control part start */
+    static final int RIL_UNSOL_SPEECH_CODEC_INFO = (RIL_UNSOL_MTK_BASE + 52);
+    /* M: call control part end */
+
+    //MTK-START for MD state change
+    static final int RIL_UNSOL_MD_STATE_CHANGE = (RIL_UNSOL_MTK_BASE + 53);
+    //MTK-END for MD state change
+    // M: CC33 URC
+    static final int RIL_UNSOL_REMOVE_RESTRICT_EUTRAN = (RIL_UNSOL_MTK_BASE + 54);
+
+    // IMS client on AP shall get the information of MO Data Barring and SSAC barring
+    static final int RIL_UNSOL_MO_DATA_BARRING_INFO = (RIL_UNSOL_MTK_BASE + 55);
+    static final int RIL_UNSOL_SSAC_BARRING_INFO = (RIL_UNSOL_MTK_BASE + 56);
+
+//MTK_TC1_FEATURE for LGE CSMCC_MO_CALL_MODIFIED {
+    static final int RIL_UNSOL_RESPONSE_MO_CALL_STATE_CHANGED = (RIL_UNSOL_MTK_BASE + 57);
+//}
+
+    /* M: Add C2K proprietary start */
+    static final int RIL_REQUEST_C2K_BASE = 4000;
+    static final int RIL_REQUEST_GET_NITZ_TIME = (RIL_REQUEST_C2K_BASE + 0);
+    static final int RIL_REQUEST_QUERY_UIM_INSERTED = (RIL_REQUEST_C2K_BASE + 1);
+    static final int RIL_REQUEST_SWITCH_HPF = (RIL_REQUEST_C2K_BASE + 2);
+    static final int RIL_REQUEST_SET_AVOID_SYS = (RIL_REQUEST_C2K_BASE + 3);
+    static final int RIL_REQUEST_QUERY_AVOID_SYS = (RIL_REQUEST_C2K_BASE + 4);
+    static final int RIL_REQUEST_QUERY_CDMA_NETWORK_INFO = (RIL_REQUEST_C2K_BASE + 5);
+    static final int RIL_REQUEST_GET_LOCAL_INFO =  (RIL_REQUEST_C2K_BASE + 6);
+    static final int RIL_REQUEST_UTK_REFRESH = (RIL_REQUEST_C2K_BASE + 7);
+    static final int RIL_REQUEST_QUERY_SMS_AND_PHONEBOOK_STATUS = (RIL_REQUEST_C2K_BASE + 8);
+    static final int RIL_REQUEST_QUERY_NETWORK_REGISTRATION = (RIL_REQUEST_C2K_BASE + 9);
+    static final int RIL_REQUEST_AGPS_TCP_CONNIND = (RIL_REQUEST_C2K_BASE + 10);
+    static final int RIL_REQUEST_AGPS_SET_MPC_IPPORT = (RIL_REQUEST_C2K_BASE + 11);
+    static final int RIL_REQUEST_AGPS_GET_MPC_IPPORT = (RIL_REQUEST_C2K_BASE + 12);
+    static final int RIL_REQUEST_SET_MEID = (RIL_REQUEST_C2K_BASE + 13);
+    static final int RIL_REQUEST_SET_REG_RESUME = (RIL_REQUEST_C2K_BASE + 14);
+    static final int RIL_REQUEST_ENABLE_REG_PAUSE = (RIL_REQUEST_C2K_BASE + 15);
+    static final int RIL_REQUEST_SET_ETS_DEV = (RIL_REQUEST_C2K_BASE + 16);
+    static final int RIL_REQUEST_WRITE_MDN = (RIL_REQUEST_C2K_BASE + 17);
+    static final int RIL_REQUEST_SET_VIA_TRM = (RIL_REQUEST_C2K_BASE + 18);
+    static final int RIL_REQUEST_SET_ARSI_THRESHOLD = (RIL_REQUEST_C2K_BASE + 19);
+
+    static final int RIL_UNSOL_C2K_BASE = 5000;
+    static final int RIL_UNSOL_CDMA_CALL_ACCEPTED = (RIL_UNSOL_C2K_BASE + 0);
+    static final int RIL_UNSOL_UTK_SESSION_END = (RIL_UNSOL_C2K_BASE + 1);
+    static final int RIL_UNSOL_UTK_PROACTIVE_COMMAND = (RIL_UNSOL_C2K_BASE + 2);
+    static final int RIL_UNSOL_UTK_EVENT_NOTIFY = (RIL_UNSOL_C2K_BASE + 3);
+    static final int RIL_UNSOL_VIA_GPS_EVENT = (RIL_UNSOL_C2K_BASE + 4);
+    static final int RIL_UNSOL_VIA_NETWORK_TYPE_CHANGE = (RIL_UNSOL_C2K_BASE + 5);
+    static final int RIL_UNSOL_VIA_PLMN_CHANGE_REG_PAUSE = (RIL_UNSOL_C2K_BASE + 6);
+    static final int RIL_UNSOL_VIA_INVALID_SIM_DETECTED = (RIL_UNSOL_C2K_BASE + 7);
+    /* M: Add C2K proprietary end */
 }
diff --git a/telephony/java/com/android/internal/telephony/TelephonyIntents.java b/telephony/java/com/android/internal/telephony/TelephonyIntents.java
index 99f262af..5535edbb 100644
--- a/telephony/java/com/android/internal/telephony/TelephonyIntents.java
+++ b/telephony/java/com/android/internal/telephony/TelephonyIntents.java
@@ -424,4 +424,262 @@ public class TelephonyIntents {
     public static final String ACTION_CAPABILITY_SWITCH_DONE
             = "com.android.phone.ACTION_CAPABILITY_SWITCH_DONE";
 
+    // MTK additions
+
+    /**
+     * Broadcast Action: An attempt to set phone RAT family has changed.  This has the following
+     * extra values:</p>
+     * <ul>
+     *   <li><em>phones RAT family</em> - A PhoneRatFamily array,
+     *          contain phone ID and new RAT family for each phone.</li>
+     * </ul>
+     * @internal
+     */
+    public static final String ACTION_SET_PHONE_RAT_FAMILY_DONE =
+            "android.intent.action.ACTION_SET_PHONE_RAT_FAMILY_DONE";
+    /**
+     * @internal
+     */
+    public static final String EXTRA_PHONES_RAT_FAMILY = "phonesRatFamily";
+
+    /**
+     * Broadcast Action: An attempt to set phone RAT family has failed.
+     * <ul>
+     *   <li><em>phone ID</em> - A int, indicates the failed phone.</li>
+     * </ul>
+     * @internal
+     */
+    public static final String ACTION_SET_PHONE_RAT_FAMILY_FAILED =
+            "android.intent.action.ACTION_SET_PHONE_RAT_FAMILY_FAILED";
+    /**
+     * @internal
+     */
+    public static final String EXTRA_PHONES_ID = "phoneId";
+
+    // Added by M begin
+
+    /**
+     * <p>Broadcast Action: To activate an application to unlock SIM lock.
+     * The intent will have the following extra value:</p>
+     * <dl>
+     *   <dt>reason</dt><dd>The reason why ss is {@code LOCKED}; null otherwise.</dd>
+     *   <dl>
+     *       <dt>{@code PIN}</dt><dd>locked on PIN1</dd>
+     *       <dt>{@code PUK}</dt><dd>locked on PUK1</dd>
+     *       <dt>{@code NETWORK}</dt><dd>locked on network personalization</dd>
+     *       <dt>{@code NETWORK_SUBSET}</dt><dd>locked on network subset personalization</dd>
+     *       <dt>{@code CORPORATE}</dt><dd>locked on corporate personalization</dd>
+     *       <dt>{@code SERVICE_PROVIDER}</dt><dd>locked on service proiver personalization</dd>
+     *       <dt>{@code SIM}</dt><dd>locked on SIM personalization</dd>
+     *   </dl>
+     * </dl>
+     * @internal
+     */
+     // FIXME: need to add subId, slotId, phoneId extra value comments.
+     public static final String ACTION_UNLOCK_SIM_LOCK
+            = "mediatek.intent.action.ACTION_UNLOCK_SIM_LOCK";
+
+
+     /**
+      * Broadcast Action: The sim card application state has changed. (only support ISIM currently)
+      * The intent will have the following extra values:</p>
+      * <dl>
+      *   <dt>phoneName</dt><dd>A string version of the phone name.</dd>
+      *   <dt>ss</dt><dd>The sim state. One of:
+      *     <dl>
+      *       <dt>{@code ABSENT}</dt><dd>SIM card not found</dd>
+      *       <dt>{@code LOCKED}</dt><dd>SIM card locked (see {@code reason})</dd>
+      *       <dt>{@code READY}</dt><dd>SIM card ready</dd>
+      *       <dt>{@code IMSI}</dt><dd>FIXME: what is this state?</dd>
+      *       <dt>{@code LOADED}</dt><dd>SIM card data loaded</dd>
+      *     </dl></dd>
+      *   <dt>reason</dt><dd>The reason why ss is {@code LOCKED}; null otherwise.</dd>
+      *   <dl>
+      *       <dt>{@code PIN}</dt><dd>locked on PIN1</dd>
+      *       <dt>{@code PUK}</dt><dd>locked on PUK1</dd>
+      *       <dt>{@code NETWORK}</dt><dd>locked on network personalization</dd>
+      *   </dl>
+      *   <dt>appid</dt><dd>The application id.</dd>
+      * </dl>
+      *
+      * <p class="note">This is a protected intent that can only be sent
+      * by the system.
+      */
+      // FIXME: need to add subId, slotId, phoneId extra value comments.
+     public static final String ACTION_SIM_STATE_CHANGED_MULTI_APPLICATION
+             = "mediatek.intent.action.ACTION_SIM_STATE_CHANGED_MULTI_APPLICATION";
+
+    /**
+    * Do SIM Recovery Done.
+    */
+    public static final String ACTION_SIM_RECOVERY_DONE = "com.android.phone.ACTION_SIM_RECOVERY_DONE";
+
+    // ALPS00302698 ENS
+    /**
+       * This event is broadcasted when CSP PLMN is changed
+       * @internal
+       */
+    public static final String ACTION_EF_CSP_CONTENT_NOTIFY = "android.intent.action.ACTION_EF_CSP_CONTENT_NOTIFY";
+    public static final String INTENT_KEY_PLMN_MODE_BIT = "plmn_mode_bit";
+
+    // ALPS00302702 RAT balancing
+    public static final String ACTION_EF_RAT_CONTENT_NOTIFY = "android.intent.action.ACTION_EF_RAT_CONTENT_NOTIFY";
+    public static final String INTENT_KEY_EF_RAT_CONTENT = "ef_rat_content";
+    public static final String INTENT_KEY_EF_RAT_STATUS = "ef_rat_status";
+
+    public static final String ACTION_COMMON_SLOT_NO_CHANGED = "com.mediatek.phone.ACTION_COMMON_SLOT_NO_CHANGED";
+
+
+  /**
+      * Broadcast Action: ACMT Network Service Status Indicator
+      * The intent will have the following extra values:</p>
+      * <ul>
+      * <li><em>CauseCode</em> - specify the reject cause code from MM/GMM/EMM</li>
+      * <li><em>Cause</em> - the reject cause<li>
+      * </ul>
+      */
+    public static final String ACTION_ACMT_NETWORK_SERVICE_STATUS_INDICATOR
+            = "mediatek.intent.action.acmt_nw_service_status";
+
+    //MTK-START [mtk80589][121026][ALPS00376525] STK dialog pop up caused ISVR
+    public static final String ACTION_IVSR_NOTIFY
+        = "mediatek.intent.action.IVSR_NOTIFY";
+
+    public static final String INTENT_KEY_IVSR_ACTION = "action";
+    //MTK-END [mtk80589][121026][ALPS00376525] STK dialog pop up caused ISVR
+
+   /* ALPS01139189 */
+   /**
+     * This event is broadcasted when frmework start/stop hiding network state update
+     * @internal
+     */
+    public static final String ACTION_HIDE_NETWORK_STATE = "mediatek.intent.action.ACTION_HIDE_NETWORK_STATE";
+    public static final String EXTRA_ACTION = "action";
+    public static final String EXTRA_REAL_SERVICE_STATE = "state";
+
+    /**
+     * This event is broadcasted when the located PLMN is changed
+     * @internal
+     */
+    public static final String ACTION_LOCATED_PLMN_CHANGED = "mediatek.intent.action.LOCATED_PLMN_CHANGED";
+
+  /**
+     * This event is broadcasted when the IMS registeration state is changed
+     */
+    public static final String ACTION_IMS_STATE_CHANGED = "android.intent.action.IMS_SERVICE_STATE";
+
+  /**
+     * This extra value is the IMS registeration state
+     */
+    public static final String EXTRA_IMS_REG_STATE_KEY = "regState"; // 0: not registered  , 1: registered
+
+    // Femtocell (CSG) START
+    public static final String EXTRA_HNB_NAME   = "hnbName";
+    public static final String EXTRA_CSG_ID     = "csgId";
+    public static final String EXTRA_DOMAIN     = "domain";
+    // Femtocell (CSG) END
+
+    /**
+     * Broadcast Action: The PHB state has changed.
+     * The intent will have the following extra values:</p>
+     * <ul>
+     *   <li><em>ready</em> - The PHB ready state.  True for ready, false for not ready</li>
+     *   <li><em>simId</em> - The SIM ID</li>
+     * </ul>
+     *
+     * <p class="note">
+     * Requires the READ_PHONE_STATE permission.
+     *
+     * <p class="note">This is a protected intent that can only be sent
+     * by the system.
+     * @internal
+     */
+    public static final String ACTION_PHB_STATE_CHANGED
+            = "android.intent.action.PHB_STATE_CHANGED";
+
+    /* SIM switch start */
+    /**
+     * To notify the capability switch procedure start
+     */
+    public static String EVENT_PRE_CAPABILITY_SWITCH = "com.mediatek.PRE_CAPABILITY_SWITCH";
+    /**
+     * To notify the capability switch procedure end
+     */
+    public static String EVENT_CAPABILITY_SWITCH_DONE = "com.mediatek.CAPABILITY_SWITCH_DONE";
+    /**
+     * The target SIM Id where capability is going to set to.
+     * This is an extra information comes with EVENT_CAPABILITY_PRE_SWITCH event.
+     */
+    public static String EXTRA_MAIN_PROTOCOL_SIM = "MAIN_PROTOCOL_SIM";
+    // Added by M end
+
+    /**
+     * Broadcast Action: The modem type changed.
+     * @internal
+     * The intent will have the following extra values:</p>
+     * <ul>
+     *   <li><em>ready</em> - The modem type after switched.</li>
+     * </ul>
+     */
+    public static final String ACTION_MD_TYPE_CHANGE
+            = "android.intent.action.ACTION_MD_TYPE_CHANGE";
+    /** @internal */
+    public static final String EXTRA_MD_TYPE = "mdType";
+
+    /**
+     * This event is to notify when data bearer need to clear
+     */
+    public static final String ACTION_CLEAR_DATA_BEARER_NOTIFY = "android.intent.action.CLEAR_DATA_BEARER_NOTIFY";
+
+    // VOLTE
+    public static final String ACTION_ANY_DEDICATE_DATA_CONNECTION_STATE_CHANGED = "android.intent.action.ANY_DEDICATE_DATA_STATE";
+    /**
+     * This event is broadcasted when clear data bearer finished
+     */
+    public static final String ACTION_CLEAR_DATA_BEARER_FINISHED = "android.intent.action.CLEAR_DATA_BEARER_FINISHED";
+    public static final String ACTION_NOTIFY_GLOBAL_IP_ADDR = "android.intent.action.NOTIFY_GLOBAL_ADDR";
+    public static final String EXTRA_GLOBAL_IP_ADDR_KEY = "lte_global_ip_addr";
+
+    /**
+     * This event is broadcasted when ims or emergency pdn deactivated from NW in VOLTE
+     */
+    public static final String ACTION_NOTIFY_IMS_DEACTIVATED_CIDS = "android.intent.action.NOTIFY_IMS_DEACTIVATED_CIDS";
+    public static final String EXTRA_IMS_DEACTIVATED_CIDS = "ims_deactivate_cids";
+
+     /**
+     * This event is broadcasted when default pdn modified by NW in VOLTE
+     */
+     public static final String ACTION_NOTIFY_IMS_DEFAULT_PDN_MODIFICATION = "android.intent.action.NOTIFY_IMS_DEFAULT_PDN_MODIFICATION";
+     public static final String EXTRA_IMS_DEFAULT_RESPONSE_DATA_CALL = "ims_default_response_data_call";
+
+
+    /**
+    * This event is broadcasted when Stk Refresh with type REFRESH_RESULT_INIT,
+    * REFRESH_RESULT_RESET, REFRESH_INIT_FULL_FILE_UPDATED, REFRESH_INIT_FILE_UPDATED
+    * @internal
+    */
+    public static final String ACTION_REMOVE_IDLE_TEXT = "android.intent.aciton.stk.REMOVE_IDLE_TEXT";
+
+    /**
+    * @hide
+    */
+    public static final String ACTION_REMOVE_IDLE_TEXT_2 = "android.intent.aciton.stk.REMOVE_IDLE_TEXT_2";
+
+    /// M: IMS feature for SS Runtime  Indication. @{
+    public static final String ACTION_LTE_MESSAGE_WAITING_INDICATION = "android.intent.action.lte.mwi";
+    public static final String EXTRA_LTE_MWI_BODY = "lte_mwi_body";
+    /// @}
+
+    /// M: c2k modify, intents. @{
+    // MCC MNC Change
+    public static final String ACTION_MCC_MNC_CHANGED = "android.intent.action.MCC_MNC_CHANGED";
+    public static final String EXTRA_MCC_MNC_CHANGED_MCC = "mcc";
+    public static final String EXTRA_MCC_MNC_CHANGED_MNC = "mnc";
+    // RADIO AVAILABLE
+    public static final String ACTION_RADIO_AVAILABLE = "android.intent.action.RADIO_AVAILABLE";
+    public static final String EXTRA_RADIO_AVAILABLE_STATE = "radio_available_state";
+    /// @}
+
+    // DS: MTK
+    public static final String ACTION_SET_RADIO_CAPABILITY_DONE = "android.intent.action.ACTION_SET_RADIO_CAPABILITY_DONE";
 }
diff --git a/telephony/java/com/android/internal/telephony/TelephonyProperties.java b/telephony/java/com/android/internal/telephony/TelephonyProperties.java
index db84d595..ec79f9ce 100644
--- a/telephony/java/com/android/internal/telephony/TelephonyProperties.java
+++ b/telephony/java/com/android/internal/telephony/TelephonyProperties.java
@@ -248,4 +248,39 @@ public interface TelephonyProperties
      *     or Earpiece, based on the default audio routing strategy.
      */
     static final String PROPERTY_IMS_AUDIO_OUTPUT = "persist.radio.ims.audio.output";
+
+    // MTK additions
+
+    // Added by M begin
+    /** The IMSI of the SIM
+     *  Availability: SIM state must be "READY"
+     */
+    static final String PROPERTY_ICC_OPERATOR_IMSI   = "gsm.sim.operator.imsi";
+
+    /**
+    * Indicate if chaneing to SIM locale is processing
+    */
+    static final String PROPERTY_SIM_LOCALE_SETTINGS = "gsm.sim.locale.waiting";
+
+    /** PROPERTY_ICC_OPERATOR_DEFAULT_NAME is the operator name for plmn which origins the SIM.
+     *  Availablity: SIM state must be "READY"
+     */
+    static final String PROPERTY_ICC_OPERATOR_DEFAULT_NAME = "gsm.sim.operator.default-name";
+    // Added by M end
+
+    static final String PROPERTY_WORLD_PHONE = "ro.mtk_world_phone";
+    static final String PROPERTY_ACTIVE_MD = "ril.active.md";
+
+ /**
+    * Indicate the highest radio access capability(ex: UMTS,LTE,etc.) of modem
+    */
+    static final String PROPERTY_BASEBAND_CAPABILITY = "gsm.baseband.capability";
+    static final String PROPERTY_BASEBAND_CAPABILITY_MD2 = "gsm.baseband.capability.md2";
+
+ /**
+    * NITZ operator long name,short name, numeric (if ever received from MM information)
+    */
+    static final String PROPERTY_NITZ_OPER_CODE = "persist.radio.nitz_oper_code";
+    static final String PROPERTY_NITZ_OPER_LNAME = "persist.radio.nitz_oper_lname";
+    static final String PROPERTY_NITZ_OPER_SNAME = "persist.radio.nitz_oper_sname";
 }
